// fasta2struct.cpp : Defines the entry point for the console application.
// generates conformational characteristic profiles for input fasta or bioseq files 
#include "stdafx.h"
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#if _WIN32
#include "../libkit4b/commhdrs.h"
#else
#include "../libkit4b/commhdrs.h"
#endif

const unsigned int cMaxProcSeqLen = 2000;	// max length fasta sequence that will be processed, longer sequences are truncated (with warning) to cMaxRefSeqLen

const int cNumMedFreqBins = 10000;			// number of frquency bins per conformational characteristic 
const int cMaxConfChroms = 100;				// only process 1st cMaxConfChroms chromosomes

const int cMaxIncludeChroms = 20;			// max number of include chromosomes regular expressions
const int cMaxExcludeChroms = 20;			// max number of exclude chromosomes regular expressions


// processing modes
typedef enum TAG_ePMode {		
	ePMfastaconf,							// default processing mode is for fasta sequence conformation
	ePMfastaconfstats,						// fasta sequence conformation summary stats
	ePMextdfastaconfstats,					// extended fasta sequence conformation summary stats (also outputs each step's distribution)
	ePMgenome,								// genome wide conformation processing
	ePMHamm,								// conformational to hamming
	ePMplaceholder							// used to set the enumeration range
	} etPMode;

// permutation modes
typedef enum TAG_eRMode {		
	eRMdefault,								// no random permutation of input sequences
	eRMmono,								// permute monomers
	eRMdi,									// permute dimers
	eRMplaceholder							// used to set the enumeration range
	} etRMode;

// output format
typedef enum TAG_etFMode {
	eFMdefault,								// default is for csv
	eFMplaceholder							// used to set the enumeration range
	} etFMode;

CStopWatch gStopWatch;
CDiagnostics gDiagnostics;					// for writing diagnostics messages to log file
char gszProcName[_MAX_FNAME];				// process name


int
Process(etPMode PMode,					// processing mode
		etRMode RMode,					// sequence permutation mode
		etFMode FMode,					// output format mode
		bool bPermConf,					// if true then permutate the conformational characteristic values
		teOctStructStats ConfParam,		// which conformational parameter is of interest
		char *pszStructParamsFile,		// structural parameters file to use
		int TruncLength,				// truncate sequences longer than this
		int TrimPercentile,				// trim percentile when calculating summary stats
		int ConfWinLen,					// conformational processing window length
		char *pszFastaFile,				// fasta file
		char *szHamFile,				// hamming distance differentials file for fasta sequences
		char *pszResultsFile,			// write conformational structure values to this file
		int NumIncludeChroms,			// number of chromosomes explicitly defined to be included
		char **ppszIncludeChroms,		// ptr to array of reg expressions defining chroms to include - overides exclude
		int NumExcludeChroms,			// number of chromosomes explicitly defined to be excluded
		char **ppszExcludeChroms,		// ptr to array of reg expressions defining chroms to exclude
		char *pszIncludeRegionsFile);  // only process those regions specified in this biobed file



// TO-DO: pull the following class out into conservlib when it has settled down!
typedef struct TAG_sRunningStats {
	double Median;
	double Mean;
	double Variance;
	double StdDev;
	} tsRunningStats;

typedef struct TAG_sConfRange {
	int Min;
	int Max;
	int Range;
	int *pStepFreqs;
	tsRunningStats *pStats;
} tsConfRange;


class CProcessConformation  : public CErrorCodes {
		char m_szRsltsFile[_MAX_PATH];	// write results to this file 
		int m_hRslts;					// opened results file handle
		CFasta *m_pFasta;				// fasta file containing nucleosome wrap sequences
		CCSVFile *m_pCsvHDD;				// CSV file containing Hamming Distance Differentials
		CTwister *m_pTwister;			// contains hunter group dsDNA conformational characteristic values
		CBioSeqFile *m_pBioSeqFile;		// genome of interest to generate conformational characterics over
		CBEDfile *m_pBedFile;			// regions of interest over genome
		etSeqBase *m_pSeq;				// used to hold chromosome or sequence nucleosomes loaded from m_pFasta or m_pBioSeqFile
		int *m_pConfValues;				// conformational values corresponding to sequence in m_pSeq as generated by m_pTwister
		int *m_pRiseSums;				// sum of conformational values over window
		int *m_pHistBins;				// used to hold histogram bin counts for conformational values
		int *m_pConfRiseValues;			// used to hold windows of conformational rise values
		int *m_pConfTwistValues;		// used to hold windows of conformational twist values
		tsConfRange m_ConfRange[eSSNumStatParams]; // used when generating fasta sequence conformation summary stats - medians
		
		float *m_pMeanRises;
		float *m_pMeanTwists;
	

public:
	CProcessConformation();
	~CProcessConformation();
	void Reset(void);							// resets class back to that immediately following instantiation
	int	ProcessFastaStruct(etPMode PMode,		// processing mode
				etRMode RMode,					// sequence permutation mode
				bool bPermConf,					// if true then permutate the conformational characteristic values
				teOctStructStats ConfP,			// which conformational parameter is of interest
				char *pszStructParamsFile,		// structural parameters file to use
				int TruncLength,				// truncate sequences longer than this
				int TrimPercentile,				// trim percentile when calculating summary stats
				int ConfWinLen,					// conformational processing window length
				char *pszFastaFile,				// reference fasta file
				char *szHamFile,				// hamming distance differentials file for fasta sequences
				char *pszResultsFile);			// write conformation structure values to this file

	int ProcessBioseqStruct(etPMode PMode,	// processing mode
		etRMode RMode,				// sequence permutation mode
		bool bPermConf,				// if true then permutate the conformational characteristic values
		teOctStructStats ConfParam,	// conformational parameter of interest
		char *pszStructParamsFile,  // structural parameters file to use
		int WindowSize,				// conformation within this sized overlapping windows
		char *pszBioseqFile,		// reference bioseq file
		char *pszResultsFile,		// write rise conformation structure values to this file
		int NumIncludeChroms,		// number of chromosomes explicitly defined to be included
		char **ppszIncludeChroms,	// ptr to array of reg expressions defining chroms to include - overides exclude
		int NumExcludeChroms,		// number of chromosomes explicitly defined to be excluded
		char **ppszExcludeChroms,	// ptr to array of reg expressions defining chroms to exclude
		char *pszIncludeRegionsFile);  // only process those regions specified in this biobed file

	int GenNucleosomePredictions(etPMode PMode,	// processing mode
		etFMode FMode,					// output format mode
		char *pszStructParamsFile,  // structural parameters file to use
		char *pszBioseqFile,		// reference bioseq file
		char *pszResultsFile,		// write predictions to this file
		int NumIncludeChroms,			// number of chromosomes explicitly defined to be included
		char **ppszIncludeChroms,		// ptr to array of reg expressions defining chroms to include - overides exclude
		int NumExcludeChroms,			// number of chromosomes explicitly defined to be excluded
		char **ppszExcludeChroms);		// ptr to array of reg expressions defining chroms to exclude

	void ShowComposition(char *pszMsg,	// message to display/log
					 int Len,		// number of bases ptd to by pSeq
					 etSeqBase *pSeq); // bases over which to to show basic composition stats

};

int TrimQuotes(char *pszTxt);		// removes leading/trailing quotes

void ShowComposition(char *pszMsg,	// message to display
					 int Len,		// number of bases ptd to by pSeq
					 etSeqBase *pSeq); // bases over which to to show basic composition stats

#ifdef _WIN32
// required by str library
#if !defined(__AFX_H__)  ||  defined(STR_NO_WINSTUFF)
HANDLE STR_get_stringres()
{
	return NULL;	//Works for EXEs; in a DLL, return the instance handle
}
#endif

const STRCHAR* STR_get_debugname()
{
	return _T("fasta2struct");
}
// end of str library required code
#endif

#ifdef _WIN32
int _tmain(int argc, char* argv[])
{
// determine my process name
_splitpath(argv[0],NULL,NULL,gszProcName,NULL);
#else
int 
main(int argc, const char** argv)
{
// determine my process name
CUtility::splitpath((char *)argv[0],NULL,gszProcName);
#endif
int iScreenLogLevel;		// level of screen diagnostics
int iFileLogLevel;			// level of file diagnostics
char szLogFile[_MAX_PATH];	// write diagnostics to this file

int Rslt;
int Idx;
int LenReq;

etPMode PMode;				// processing mode
etRMode RMode;				// sequence permutation mode
etFMode FMode;				// output format mode

bool bPermConf;				// true if conformation characteristic values to be permuted

unsigned int iNumNucs;		// number of nucleotides to process - 0 if all
int TrimPercentile;			// trim percentile when calculating summary stats 
int ConfWinLen;				// conformational processing window length

teOctStructStats ConfParam;	 // which conformational parameter is of interest


char szResultsFile[_MAX_PATH];
char szInFile[_MAX_PATH];
char szStructParamsFile[_MAX_PATH];
char szHamFile[_MAX_PATH];								// conformational to hamming

int NumIncludeChroms;
char *pszIncludeChroms[cMaxIncludeChroms];
int NumExcludeChroms;
char *pszExcludeChroms[cMaxExcludeChroms];

char szIncludeRegionsFile[_MAX_PATH];

// command line args
struct arg_lit  *help    = arg_lit0("hH","help",                "print this help and exit");
struct arg_lit  *version = arg_lit0("v","version,ver",			"print version information and exit");
struct arg_int *FileLogLevel=arg_int0("f", "FileLogLevel",		"<int>","Level of diagnostics written to screen and logfile 0=fatal,1=errors,2=info,3=diagnostics,4=debug");
struct arg_file *LogFile = arg_file0("F","log","<file>",		"diagnostics log file");

struct arg_int *pmode = arg_int0("m","mode","<int>",		    "processing mode: 0 - fasta conformation, 1 - fasta summary stats, 2 - extended fasta summary stats, 3 - genome wide bioseq, 4 - conformation to hamming differential");
struct arg_int *rmode = arg_int0("r","rmode","<int>",		    "sequence permutation mode: 0 - none, 1- monomer, 2- dimer (default = 0)");
struct arg_lit *pconf = arg_lit0("P","permconf",                "permute conformation structural parameters");

struct arg_int *fmode = arg_int0("M","format","<int>",           "output format: 0 - csv");


struct arg_int *confparam = arg_int0("c","conf","<int>",		"conformational characteristic: 0-energy,1-minor groove,2-inferenced major groove,3-twist,4-roll,5-tilt,6-rise,7-slide,8-shift,9-rmsd,10-ORChid (default 1)");
struct arg_int *confwinlen = arg_int0("C","confwinlen","<int>",	"generate min/max conformational characteristics using window of this length (default is full sequence length)");

struct arg_file *InFile = arg_file1("i","in,input","<file>",	"input sequences from this fasta (mode 0) or bioseq (mode 1 and 2) file");
struct arg_file *InHamFile = arg_file0("x","hdd","<hammings>",	"Hamming distance differentials for input sequences from this csv (mode 4 only) file");

struct arg_int *NumNucs = arg_int0("n", "nucleotides","<int>",	"m=0: truncate sequences to this length (8..3999) (default is 100),\nm=1: number of nucleotides (2..3999) in sliding window (default is 147)");
struct arg_file *ResultsFile = arg_file1("o","output","<file>",	"results to");
struct arg_file *StructParams = arg_file1("p","params","<file>","file containing conformation structural parameters");

struct arg_int *trim = arg_int0("t", "trim","<int>",			"in summary stats (m=1) trim outliers outside this percentile (range 0..25)");

struct arg_str  *IncludeChroms = arg_strn("z","chromeinclude","<string>",0,cMaxIncludeChroms,"low priority - regular expressions defining chromosomes to include for processing");
struct arg_str  *ExcludeChroms = arg_strn("Z","chromexclude","<string>",0,cMaxExcludeChroms,"high priority - regular expressions defining chromosomes to exclude from processing");
struct arg_file *IncludeRegions = arg_file0("I","include","<file>", "process just the regions in this biobed file");


struct arg_end *end = arg_end(20);
void *argtable[] = {help,version,FileLogLevel,LogFile,
					pmode,rmode,pconf,fmode,confparam,NumNucs,confwinlen,trim,ResultsFile,StructParams,InFile,InHamFile,IncludeChroms,ExcludeChroms,IncludeRegions,end};
char **pAllArgs;
int argerrors;
argerrors = CUtility::arg_parsefromfile(argc,(char **)argv,&pAllArgs);
if(argerrors >= 0)
	argerrors = arg_parse(argerrors,pAllArgs,argtable);

/* special case: '--help' takes precedence over error reporting */
if (help->count > 0)
        {
		printf("\n%s fasta2struct, Version %s\nOptions ---\n", gszProcName,kit4bversion);
        arg_print_syntax(stdout,argtable,"\n");
        arg_print_glossary(stdout,argtable,"  %-25s %s\n");
		printf("\nNote: Parameters can be entered into a parameter file, one parameter per line.");
		printf("\n      To invoke this parameter file then precede its name with '@'");
		printf("\n      e.g. %s @myparams.txt\n",gszProcName);
		printf("\nPlease report any issues regarding usage of %s to https://github.com/kit4b/kit4b/issues\n\n",gszProcName);
		exit(1);
        }

    /* special case: '--version' takes precedence error reporting */
if (version->count > 0)
        {
		printf("\n%s Version %s\n",gszProcName,kit4bversion);
		exit(1);
        }

if (!argerrors)
	{
	if(FileLogLevel->count && !LogFile->count)
		{
		printf("\nError: FileLogLevel '-f%d' specified but no logfile '-F<logfile>'",FileLogLevel->ival[0]);
		exit(1);
		}

	iScreenLogLevel = iFileLogLevel = FileLogLevel->count ? FileLogLevel->ival[0] : eDLInfo;
	if(iFileLogLevel < eDLNone || iFileLogLevel > eDLDebug)
		{
		printf("\nError: FileLogLevel '-l%d' specified outside of range %d..%d",iFileLogLevel,eDLNone,eDLDebug);
		exit(1);
		}
	if(LogFile->count)
		{
		strncpy(szLogFile,LogFile->filename[0],_MAX_PATH);
		szLogFile[_MAX_PATH-1] = '\0';
		}
	else
		{
		iFileLogLevel = eDLNone;
		szLogFile[0] = '\0';
		}

			// now that log parameters have been parsed then initialise diagnostics log system
	if(!gDiagnostics.Open(szLogFile,(etDiagLevel)iScreenLogLevel,(etDiagLevel)iFileLogLevel,true))
		{
		printf("\nError: Unable to start diagnostics subsystem\n");
		if(szLogFile[0] != '\0')
			printf(" Most likely cause is that logfile '%s' can't be opened/created\n",szLogFile);
		exit(1);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Version: %s",kit4bversion);


	PMode = (etPMode)(pmode->count ? pmode->ival[0] : ePMfastaconf);
	if(PMode < 0 || PMode >= ePMplaceholder)
		{
		printf("\nError: Processing mode '-m%d' specified outside of range %d..%d",PMode,ePMfastaconf,(int)ePMplaceholder-1);
		exit(1);
		}

	if(PMode == ePMgenome)
		{
		RMode = (etRMode)(rmode->count ? rmode->ival[0] : 0);
		if(RMode < 0 || RMode >= eRMplaceholder)
			{
			printf("\nError: Permutation mode '-m%d' specified outside of range %d..%d",RMode,0,(int)eRMplaceholder-1);
			exit(1);
			}

		if(RMode > eRMdi)
			{
			printf("\nSorry: currently can't process selected permutation mode '-m%d'",RMode);
			exit(1);
			}

		bPermConf = pconf->count ? true : false;

		if(IncludeRegions->count)
			{
			strncpy(szIncludeRegionsFile,IncludeRegions->filename[0],_MAX_PATH);
			szIncludeRegionsFile[_MAX_PATH-1] = '\0';
			}
		else
			szIncludeRegionsFile[0] = '\0';
		}
	else
		{
		if(rmode->count)
			printf("ignoring permution mode '-r' as only applies if genome processing mode '-m%d'\n",ePMgenome);
		if(pconf->count)
			printf("ignoring conformation permution '-P' as only applies if genome processing mode '-m%d'\n",ePMgenome);
		if(IncludeRegions->count)
			printf("ignoring include regions file '-I' as only applies if genome processing mode '-m%d'\n",ePMgenome);
		bPermConf = 0;
		bPermConf = false;
		szIncludeRegionsFile[0] = '\0';
		}

	FMode = eFMdefault;

	if(PMode != ePMHamm && (PMode != ePMfastaconfstats && PMode != 	ePMextdfastaconfstats))
		{
		ConfParam = (teOctStructStats)(confparam->count ? confparam->ival[0] : eSSminorgroove); 
		if(ConfParam < eSSenergy || ConfParam >= eSSNumStatParams)
			{
			printf("\nError: conformation parameter '-c%d' specified outside of range %d..%d",ConfParam,eSSenergy,(int)eSSNumStatParams-1);
			exit(1);
			}
		if(PMode != ePMHamm && (PMode >= ePMgenome && !(ConfParam == eSSrise || ConfParam == eSStwist)))
			{
			printf("\nSorry: currently can't process selected conformation characteristic parameter '-m%d'",(int)ConfParam);
			exit(1);
			}
		}
	else
		ConfParam = eSSNumStatParams; // summary stats generates for all conformational characteristics


	if(PMode == ePMfastaconfstats || PMode == ePMextdfastaconfstats)
		{
		TrimPercentile = trim->count ? trim->ival[0] : 0;
		if(TrimPercentile < 0 || TrimPercentile > 25)
			{
			printf("\nError: trim percentile '-t%d' must be in range 0..25",(int)ConfParam);
			exit(1);
			}
		}
	else
		TrimPercentile = 0;

	ConfWinLen = 0;
	if(PMode == ePMHamm)
		{
		if(confwinlen->count)
			{
			ConfWinLen = confwinlen->ival[0];
			if(ConfWinLen < 8)
				{
				printf("\nError: Conformation window length '-C%d' must be >= 8",ConfWinLen);
				exit(1);
				}
			}
		}

	if(NumNucs->count)
		iNumNucs = NumNucs->ival[0];
	else
		iNumNucs = 100;

	if(iNumNucs > cMaxProcSeqLen)
		{
		printf("\nError: number of nucleotides '-n%d' must be less than %d",iNumNucs,cMaxProcSeqLen+1);
		exit(1);
		}
	else
		if(PMode < ePMgenome && iNumNucs < 8)
			{
			printf("\nError: number of nucleotides '-n%d' must be at least 8",iNumNucs);
			exit(1);
			}
		else
			if(PMode == ePMgenome && iNumNucs < 2)
				{
				printf("\nError: number of nucleotides '-n%d' must be at least 2",iNumNucs);
				exit(1);
				}
    
	if(StructParams->count)
		strcpy(szStructParamsFile,StructParams->filename[0]);
	else
		szStructParamsFile[0] = '\0';


	if(ResultsFile->count)
		strcpy(szResultsFile,ResultsFile->filename[0]);
	else
		szResultsFile[0] = '\0';

	if(InFile->count)
		strcpy(szInFile,InFile->filename[0]);
	else
		szInFile[0] = '\0';

	if(PMode == ePMHamm)
		{
		if(InHamFile->count)
			strcpy(szHamFile,InHamFile->filename[0]);
		else
			{
			printf("\nError: No sequence Hamming Distance Differential file specified");
			}
		}
	else
		szHamFile[0] = '\0';

	if(szResultsFile[0]=='\0')
		{
		strcpy(szResultsFile,szInFile);
		strcat(szResultsFile,".mut.csv");
		}
	if(PMode == ePMgenome)
		{
		NumIncludeChroms = IncludeChroms->count;
		for(Idx=0;Idx < IncludeChroms->count; Idx++)
			{
			LenReq = (int)strlen(IncludeChroms->sval[Idx]);
			pszIncludeChroms[Idx] = new char [LenReq+1];
			strcpy(pszIncludeChroms[Idx],IncludeChroms->sval[Idx]);
			TrimQuotes(pszIncludeChroms[Idx]);
			}

		NumExcludeChroms = ExcludeChroms->count;
		for(Idx=0;Idx < ExcludeChroms->count; Idx++)
			{
			LenReq = (int)strlen(ExcludeChroms->sval[Idx]);
			pszExcludeChroms[Idx] = new char [LenReq+1];
			strcpy(pszExcludeChroms[Idx],ExcludeChroms->sval[Idx]);
			TrimQuotes(pszExcludeChroms[Idx]);
			}
		}
	else
		NumIncludeChroms = NumExcludeChroms = 0;

// show user current resource limits
#ifndef _WIN32
	gDiagnostics.DiagOut(eDLInfo, gszProcName, "Resources: %s",CUtility::ReportResourceLimits());
#endif

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Processing parameters:");

	const char *pszDescr;
	switch(PMode) {
		case ePMfastaconf:
			pszDescr = "full fasta sequence processing";
			break;
		case ePMfastaconfstats:
			pszDescr = "fasta sequence summary statistics processing";
			break;
		case ePMextdfastaconfstats:
			pszDescr = "fasta sequence extended summary statistics processing";
			break;

		case ePMgenome:			
			pszDescr = "genome wide conformation processing";
			break;

		case ePMHamm:			
			pszDescr = "experimental HDD conformation processing";
			break;
		}
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"processing mode is : '%s'",pszDescr);

	if(PMode == ePMgenome)
		{
		switch(RMode) {
			case eRMdefault:
				pszDescr = "no permutation of input sequences";
				break;
			case eRMmono:					
				pszDescr = "permutation of sequence monomers";
				break;
			case eRMdi:						
				pszDescr = "permutation of sequence dimers";
				break;
			}
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"sequence permutation mode is : '%s'",pszDescr);
		}

	if(ConfParam != eSSNumStatParams)
		{
		switch(ConfParam) {
			case eSSenergy:
				pszDescr = "minimal energy";
				break;
			case eSSminorgroove:				
				pszDescr = " minor groove";
				break;
			case eSSmajorgroove:				
				pszDescr = "major groove inferenced from octamer twist + rise";
				break;
			case eSStwist:					
				pszDescr = "twist";
				break;
			case eSSroll:					
				pszDescr = "roll";
				break;
			case eSStilt:					
				pszDescr = "tilt";
				break;
			case eSSrise:					
				pszDescr = "rise";
				break;
			case eSSslide:						
				pszDescr = "slide";
				break;
			case eSSshift:					
				pszDescr = "shift";
				break;
			case eSSrmsd:					
				pszDescr = "rmsd";
				break;
			case eSSORChidVal:				
				pszDescr = "hydroxyl radical cleavage value from ORChid dataset";
				break;
			}
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"conformational characteristic is : '%s'",pszDescr);
		}
	else
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"summary contains all conformational characteristics");

	switch(FMode) {
		case eFMdefault:					// default is for csv
			pszDescr = "CSV";
			break;
		}
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"output format is : '%s'",pszDescr);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"input file: '%s'",szInFile);

	if(szHamFile[0] != '\0')
		{
		if(ConfWinLen > 0)
			gDiagnostics.DiagOutMsgOnly(eDLInfo," Conformation window length: %d",ConfWinLen);
		else
			gDiagnostics.DiagOutMsgOnly(eDLInfo," Conformation window length: Using sequence length'");

		gDiagnostics.DiagOutMsgOnly(eDLInfo,"Hamming Distance Differential file: '%s'",szHamFile);
		}

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"conformation struct param file: '%s'",szStructParamsFile);
	if(PMode == ePMgenome)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"permute conformation characteristic values: '%s'",bPermConf ? "yes" : "no");
	if(iNumNucs)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"num nucleotides: %d",iNumNucs);
	else
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"num nucleotides: all");

	if(PMode == ePMfastaconfstats || PMode == ePMextdfastaconfstats)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"trim percentile: %d%%",TrimPercentile);


	gDiagnostics.DiagOutMsgOnly(eDLInfo,"results file: '%s'",szResultsFile);

	for(Idx = 0; Idx < NumIncludeChroms; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"reg expressions defining chroms to include: '%s'",pszIncludeChroms[Idx]);
	for(Idx = 0; Idx < NumExcludeChroms; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"reg expressions defining chroms to exclude: '%s'",pszExcludeChroms[Idx]);

	if(szIncludeRegionsFile[0] != '\0')
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"only process regions specified in this biobed file: '%s'",szIncludeRegionsFile);


	gStopWatch.Start();
	Rslt = Process(PMode,					// processing mode
					RMode,					// sequence permutation mode
					FMode,					// output format
					bPermConf,				// if true then permutate the conformational characteristic values
					ConfParam,				// which conformational parameter is of interest
					szStructParamsFile,		// structural parameters file to use
					iNumNucs,				// number of nucleotides to process or truncate to 
					TrimPercentile,			// trim percentile when calculating summary stats
					ConfWinLen,				// conformational processing window length
					szInFile,				// fasta file
					szHamFile,				// hamming distance differentials file for fasta sequences
					szResultsFile,			// write conformational structure values to this file as CSV
					NumIncludeChroms,		// number of chromosomes explicitly defined to be included
					pszIncludeChroms,		// ptr to array of reg expressions defining chroms to include - overides exclude
					NumExcludeChroms,		// number of chromosomes explicitly defined to be excluded
					pszExcludeChroms,		// ptr to array of reg expressions defining chroms to be excluded
					szIncludeRegionsFile);  // only process those regions specified in this biobed file

	gStopWatch.Stop();
	Rslt = Rslt >=0 ? 0 : 1;
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Exit code: %d Total processing time: %s",Rslt,gStopWatch.Read());
	exit(Rslt);
	}
else
	{
	printf("\n%s fasta2struct, Version %s\n", gszProcName,kit4bversion);
	arg_print_errors(stdout,end,gszProcName);
	arg_print_syntax(stdout,argtable,"\nUse '-h' to view option and parameter usage\n");
	exit(1);
	}
}

// TrimQuotes
// Removes any leading and trailing quotes from pszTxt
int
TrimQuotes(char *pszTxt)
{
char *pDst = pszTxt;
char Chr;
int Len = 0;
while((Chr = *pszTxt++))	
	{
	if((!Len || *pszTxt == '\0') && (Chr == '"' || Chr == '\''))
		continue;
	*pDst++ = Chr;
	Len++;
	}
*pDst = Chr;
return(Len);
}


int
Process(etPMode PMode,					// processing mode
		etRMode RMode,					// sequence permutation mode
		etFMode FMode,					// output format mode
		bool bPermConf,					// if true then permutate the conformational characteristic values
		teOctStructStats ConfParam,		// which conformational parameter is of interest
		char *pszStructParamsFile,		// structural parameters file to use
		int	 NumNucs,					// number of nucleotides, starting at StartOfs, to process 
		int TrimPercentile,				// trim percentile when calculating summary stats
		int ConfWinLen,					// conformational processing window length
		char *pszFastaFile,				// fasta file
		char *pszHamFile,				// hamming distance differentials file for fasta sequences
		char *pszResultsFile,			// write conformational structure values to this file
		int NumIncludeChroms,			// number of chromosomes explicitly defined to be included
		char **ppszIncludeChroms,		// ptr to array of reg expressions defining chroms to include - overides exclude
		int NumExcludeChroms,			// number of chromosomes explicitly defined to be excluded
		char **ppszExcludeChroms,		// ptr to array of reg expressions defining chroms to exclude
		char *pszIncludeRegionsFile)  // only process those regions specified in this biobed file
{
int Rslt;
CProcessConformation *pConf = new CProcessConformation();

switch(PMode) {
	case ePMfastaconf:					 // processing mode is for full fasta sequence conformation
	case ePMfastaconfstats:				// fasta sequence conformation mean+stddev only
	case ePMextdfastaconfstats:				// fasta sequence conformation mean+stddev plus distribution histogram only
	case ePMHamm:
		Rslt = pConf->ProcessFastaStruct(PMode, // processing mode
					RMode,				// sequence permutation mode
					bPermConf,			// if true then permutate the conformational characteristic values
					ConfParam,			 // which conformational parameter is of interest
					pszStructParamsFile, // structural parameters file to use
					NumNucs,			 // number of nucleotides to process
					TrimPercentile,		 // trim percentile when calculating summary stats
					ConfWinLen,					// conformational processing window length
					pszFastaFile,		 // fasta file
					pszHamFile,			 // Hamming distance differentials file
					pszResultsFile);	 // write processed conformational  values to this file
		break;

	case ePMgenome:						// genome wide conformation processing
		Rslt = pConf->ProcessBioseqStruct(PMode, // processing mode
					RMode,				// sequence permutation mode
					bPermConf,			// if true then permutate the conformational characteristic values
					ConfParam,			// which conformational parameter is of interest
					pszStructParamsFile,// structural parameters file to use
					NumNucs,			// sliding window of this size 
					pszFastaFile,		// reference bioseq file
					pszResultsFile,  	// write conformation structure values to this file
					NumIncludeChroms,	// number of chromosomes explicitly defined to be included
					ppszIncludeChroms,	// ptr to array of reg expressions defining chroms to include - overides exclude
					NumExcludeChroms,	// number of chromosomes explicitly defined to be excluded
					ppszExcludeChroms,	// ptr to array of reg expressions defining chroms to exclude
					pszIncludeRegionsFile);  // only process those regions specified in this biobed file


		break;
	}

if(pConf != NULL)
	delete pConf;
return(Rslt);
}


CProcessConformation::CProcessConformation()
{
m_pFasta = NULL;
m_pCsvHDD = NULL;
m_pTwister = NULL;
m_pBioSeqFile = NULL;
m_pBedFile = NULL;
m_pSeq = NULL;
m_pConfValues = NULL;
m_pMeanRises = NULL;
m_pMeanTwists = NULL;
m_pHistBins = NULL;
m_pRiseSums = NULL;
m_pConfRiseValues = NULL;
m_pConfTwistValues = NULL;
memset(m_ConfRange,0,sizeof(m_ConfRange));
m_hRslts = -1;
}

CProcessConformation::~CProcessConformation()
{
Reset();
}

void
CProcessConformation::Reset(void)
{

if(m_hRslts != -1)
	{
	close(m_hRslts);
	m_hRslts = -1;
	}
if(m_pFasta != NULL)
	{
	delete m_pFasta;
	m_pFasta = NULL;
	}
if(m_pCsvHDD != NULL)
	{
	delete m_pCsvHDD;
	m_pCsvHDD = NULL;
	}
if(m_pTwister != NULL)
	{
	delete m_pTwister;
	m_pTwister = NULL;
	}
if(m_pBioSeqFile != NULL)
	{
	delete m_pBioSeqFile;
	m_pBioSeqFile = NULL;
	}
if(m_pBedFile != NULL)
	{
	delete m_pBedFile;
	m_pBedFile = NULL;
	}
if(m_pSeq != NULL)
	{
	delete m_pSeq;
	m_pSeq = NULL;
	}
if(m_pConfValues != NULL)
	{
	delete m_pConfValues;
	m_pConfValues = NULL;
	}
if(m_pMeanRises != NULL)
	{
	delete m_pMeanRises;
	m_pMeanRises = NULL;
	}
if(m_pMeanTwists != NULL)
	{
	delete m_pMeanTwists;
	m_pMeanTwists = NULL;
	}
if(m_pHistBins != NULL)
	{
	delete m_pHistBins;
	m_pHistBins = NULL;
	}
if(m_pRiseSums != NULL)
	{
	delete m_pRiseSums;
	m_pRiseSums = NULL;
	}
if(m_pConfRiseValues != NULL)
	{
	delete m_pConfRiseValues;
	m_pConfRiseValues = NULL;
	}
if(m_pConfTwistValues != NULL)
	{
	delete m_pConfTwistValues;
	m_pConfTwistValues = NULL;
	}

for(int Conf = eSSenergy; Conf < eSSNumStatParams; Conf++)
	{
	if(m_ConfRange[Conf].pStepFreqs != NULL)
		{
		delete m_ConfRange[Conf].pStepFreqs;
		m_ConfRange[Conf].pStepFreqs = NULL;
		}
	if(m_ConfRange[Conf].pStats != NULL)
		{
		delete m_ConfRange[Conf].pStats;
		m_ConfRange[Conf].pStats = NULL;
		}
	}
memset(m_ConfRange,0,sizeof(m_ConfRange));

}


typedef struct TAG_sDescrStats {
	double Min;
	double Max;
	double Mean;
	double Variance;
	double StdDev;
} tsDescrStats;

double										// returns the mean
DescriptiveStatsDbl(int NumValues,
		double *pValues,
		tsDescrStats *pRetStats)			// used to optionally (if non-null) return Max,Min,Mean,StdDev,Variance
{
int Idx;
double StdDev;
double Max = DBL_MIN;
double Min = DBL_MAX;
double Variance = 0.0;
double Mean = 0;
double *pValue = pValues;
for(Idx = 0; Idx < NumValues; Idx++)
	Mean += *pValue++;
Mean /= NumValues;
pValue = pValues;
for(Idx = 0; Idx < NumValues; NumValues++,pValue++)
	{
	if(Max > *pValue)
		Max = *pValue;
	if(Min < *pValue)
		Min = *pValue;
	Variance += pow(((*pValue - Mean) / 100.0),2);
	}
StdDev = (100.0 * sqrt(Variance / NumValues));
if(pRetStats != NULL)
	{
	pRetStats->Max = Max;
	pRetStats->Min = Min;
	pRetStats->Mean = Mean;
	pRetStats->StdDev = StdDev;
	pRetStats->Variance = Variance;
	}
return(Mean);
}


double										// returns the mean
DescriptiveStatsInt(int NumValues,
		int *pValues,
		tsDescrStats *pRetStats)			// used to optionally (if non-null) return Max,Min,Mean,StdDev,Variance
{
int Idx;
double StdDev;
int Max = INT_MIN;
int Min = INT_MAX;
double Variance = 0.0;
double Mean = 0;
int *pValue = pValues;
for(Idx = 0; Idx < NumValues; Idx++)
	Mean += (double)*pValue++;
Mean /= NumValues;
pValue = pValues;
for(Idx = 0; Idx < NumValues; Idx++,pValue++)
	{
	if(Max < *pValue)
		Max = *pValue;
	if(Min > *pValue)
		Min = *pValue;
	Variance += (double)pow((((double)*pValue - Mean) / 100.0),2);
	}
StdDev = (100.0 * sqrt(Variance / NumValues));
if(pRetStats != NULL)
	{
	pRetStats->Max = (double)Max;
	pRetStats->Min = (double)Min;
	pRetStats->Mean = Mean;
	pRetStats->StdDev = StdDev;
	pRetStats->Variance = Variance;
	}
return(Mean);
}



// ProcessFastaStruct
// Process multifasta file containing sequences for conformational analysis
// 
typedef struct TAG_sHamDists {
	UINT32 Hamming;				// reads in this distribution are at least this Hamming away from any other sampled read
	UINT32 NumInsts;			// number of read instances with this Hamming to any other sampled read
	double GCprop;				// GC content
	double ConfMeans[eSSNumStatParams];	// conformational means
} tsHamDists;

int
CProcessConformation::ProcessFastaStruct(etPMode PMode,		// processing mode
		etRMode RMode,					// sequence permutation mode
		bool bPermConf,					// if true then permutate the conformational characteristic values
		teOctStructStats ConfP,			// which conformational parameter is of interest
		char *pszStructParamsFile,		// structural parameters file to use
		int TruncLength,				// truncate sequences longer than this
		int TrimPercentile,				// trim percentile when calculating summary stats
		int ConfWinLen,					// conformational processing window length
		char *pszFastaFile,				// reference fasta file
		char *pszHamFile,				// hamming distance differentials file for fasta sequences
		char *pszResultsFile)			// write conformation structure values to this file
{
int Rslt;
unsigned int EntryID;
int Conf;
int SeqLen;
int NumSteps;							// number of conformational steps  to report on - will always be NumNucs -1 steps
int FreqBin;
int SumFreqCnts;
int TrimmedCnts;
int Idx;

char szDescr[100];

bool bDescriptor;
bool bTrunc;
int NumSeqs;
int NumTruncSeqs;
int NumShortSeqs;
int ShortSteps;							// shortest number of steps encountered
int BuffOfs;
char szBuff[0x03fff];

int HDD_ID;
int SeqID;
int NumFields;
int HamDistDiff;
tsDescrStats DescrStats[eSSNumStatParams];			// allow for Hammings of at most 100

tsHamDists HamDists[101];				// unlikely but allow for Hammings of upto 100 inclusive
int MaxHamDistDiff;					// maximum observed Hamming
memset(HamDists,0,sizeof(HamDists));
MaxHamDistDiff = 0;
for(Idx = 0; Idx < 101; Idx++)
	HamDists[Idx].Hamming = Idx;

strncpy(m_szRsltsFile,pszResultsFile,_MAX_PATH);
m_szRsltsFile[_MAX_PATH-1] = '\0';

if((m_pSeq = new unsigned char [cMaxProcSeqLen+10])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to allocate memory to hold sequence of length %d",cMaxProcSeqLen+1);
	return(eBSFerrMem);
	}
if((m_pConfValues = new int [cMaxProcSeqLen])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to allocate memory to hold conformational values of length %d",cMaxProcSeqLen);
	Reset();
	return(eBSFerrMem);
	}

if((m_pFasta = new CFasta())==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to create CFasta object");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt = m_pFasta->Open(pszFastaFile,true)) != eBSFSuccess)
	{
	while(m_pFasta->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pFasta->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to open fasta file '%s'",pszFastaFile);
	Reset();
	return(Rslt);
	}

if(pszHamFile != NULL && pszHamFile[0] != '\0')
	{	
	if((m_pCsvHDD = new CCSVFile())==NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to create CCSVFile object");
		Reset();
		return(eBSFerrObj);
		}
	if((Rslt = m_pCsvHDD->Open(pszHamFile)) != eBSFSuccess)
		{
		while(m_pCsvHDD->NumErrMsgs())
			gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pCsvHDD->GetErrMsg());
		gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to open HDD CSV file '%s'",pszHamFile);
		Reset();
		return(Rslt);
		}
	}
else
	m_pCsvHDD = NULL;

if((m_pTwister = new CTwister)==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to create CTwister object");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt = m_pTwister->LoadStructParams(pszStructParamsFile))  < eBSFSuccess)
	{
	while(m_pTwister->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pTwister->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","LoadStructParams(%s) failed",pszStructParamsFile);
	Reset();
	return(Rslt);
	}

#ifdef _WIN32
if((m_hRslts = open(pszResultsFile, _O_RDWR | _O_BINARY | _O_SEQUENTIAL | _O_CREAT | _O_TRUNC, _S_IREAD | _S_IWRITE ))==-1)
#else
if((m_hRslts = open(pszResultsFile, O_RDWR | O_CREAT | O_TRUNC, S_IREAD | S_IWRITE ))==-1)
#endif
	{
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to create or truncate results file %s error: %s",pszResultsFile,strerror(errno));
	Reset();
	return(eBSFerrCreateFile);
	}

if(PMode != ePMfastaconf && PMode != ePMHamm)			// fasta sequence conformation summary
	{
	// to calc mean/stddev/median with mean trimming for the size of datasets expected we use frequency binning
	// bin range is set to be 1/cNumMedFreqBins of range for each conformational characteristic
	for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
		{
		m_ConfRange[Conf].Min = min(m_pTwister->m_StructParamStats[Conf].Max,m_pTwister->m_StructParamStats[Conf].Min);
		m_ConfRange[Conf].Max = max(m_pTwister->m_StructParamStats[Conf].Max,m_pTwister->m_StructParamStats[Conf].Min);
		m_ConfRange[Conf].Range = abs(m_pTwister->m_StructParamStats[Conf].Max - m_pTwister->m_StructParamStats[Conf].Min);
		if((m_ConfRange[Conf].pStepFreqs = new int [TruncLength * cNumMedFreqBins])==NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate memory (%d bytes) for holding median freq bins",TruncLength * cNumMedFreqBins * sizeof(int));
			Reset();
			return(eBSFerrMem);
			}
		memset(m_ConfRange[Conf].pStepFreqs,0,sizeof(int) * cNumMedFreqBins * TruncLength);

		if((m_ConfRange[Conf].pStats = new tsRunningStats [TruncLength])==NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate memory (%d bytes) for holding running statistics",TruncLength * sizeof(tsRunningStats));
			Reset();
			return(eBSFerrMem);
			}
		memset(m_ConfRange[Conf].pStats,0,sizeof(tsRunningStats) * TruncLength);
		}
	}

BuffOfs = 0;
EntryID = 0;
NumSeqs = 0;
NumShortSeqs = 0;
NumTruncSeqs = 0;
ShortSteps = 0;
bDescriptor = false;
bTrunc = true;
printf("Processing fasta sequence: %8.8d\b\b\b\b\b\b\b\b",EntryID);

if(PMode == ePMHamm)
	{
	const char *pszConfDescr;
	BuffOfs += sprintf(&szBuff[BuffOfs],"\"EntryID\",\"Descr\",\"MinHamming\",\"GCcontent\"");
	for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
		{
		switch(Conf) {
			case eSSenergy:				// minimal energy int(energy * 10000) e.g. -408.2632 ==> -4082632
				pszConfDescr = "Energy";
				break;
			case eSSminorgroove:		// minor groove int (dimensions * 10000) e.g 10.784 ==> 107840
				pszConfDescr = "Minor groove";
				break;
			case eSSmajorgroove:				
				pszConfDescr = "Major groove inferenced from octamer twist + rise";
				break;
			case eSStwist:				// twist int(angle * 10000) e.g 	37.6262 ==> 376262
				pszConfDescr = "Twist";
				break;
			case eSSroll:				// roll int(angle * 10000) e.g 	2.4139 ==> 24139
				pszConfDescr = "Roll";
				break;
			case eSStilt:				// tilt int(tilt * 10000) e.g 	-0.022 ==> -220
				pszConfDescr = "Tilt";
				break;
			case eSSrise:				// rise int(rise * 10000) e.g 	3.1409 ==> 31409
				pszConfDescr = "Rise";
				break;
			case eSSslide:				// slide int(slide * 10000) e.g 	-0.0968 ==> -968	
				pszConfDescr = "Slide";
				break;
			case eSSshift:				// shift int(shift * 10000) e.g 	0.0645 ==> 645
				pszConfDescr = "Shift";
				break;
			case eSSrmsd:				// rmsd int(rmsd * 10000) e.g 	0.3078 ==> 3078
				pszConfDescr = "Rmsd";
				break;
			case eSSORChidVal:			// hydroxyl radical cleavage value from ORChid dataset
				pszConfDescr = "ORChid";
				break;
			}
		BuffOfs += sprintf(&szBuff[BuffOfs],",\"Min_%s\",\"Max_%s\",\"Mean_%s\",\"Var_%s\",\"StdDev_%s\"",pszConfDescr,pszConfDescr,pszConfDescr,pszConfDescr,pszConfDescr);
		}
	BuffOfs += sprintf(&szBuff[BuffOfs],"\n");
	if(BuffOfs + 200 > sizeof(szBuff))
		{
		if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
			{
			Reset();
			return(eBSFerrWrite);
			}
		BuffOfs = 0;
		}
	}

while((Rslt = SeqLen = m_pFasta->ReadSequence(m_pSeq,cMaxProcSeqLen + 10)) > eBSFSuccess)
	{
	if(SeqLen == eBSFFastaDescr)		// just read a descriptor line
		{
		m_pFasta->ReadDescriptor(szDescr,sizeof(szDescr));
		NumSeqs += 1;
		bDescriptor = true;
		bTrunc = false;
		continue;
		}
	if(!bDescriptor)					// if never seen a descriptor then dummy up one...
		{
		sprintf(szDescr,"Probe1");
		bDescriptor = true;
		NumSeqs += 1;
		bTrunc = false;
		}
	if(bTrunc)
		continue;

	// sequence long enough to process?
	if(SeqLen < 8)
		{
		if(!NumShortSeqs++)
			gDiagnostics.DiagOut(eDLInfo,"ProcessFastaStruct","Skipping at least one short sequence, SeqLen = %d",SeqLen);
		continue;
		}

	if(SeqLen > TruncLength)
		{
		if(!NumTruncSeqs++)
			gDiagnostics.DiagOut(eDLInfo,"ProcessFastaStruct","Truncating at least one long sequence");
		NumSteps = TruncLength - 1;
		bTrunc = true;
		}
	else
		NumSteps = SeqLen - 1;
	if(ShortSteps == 0 || NumSteps < ShortSteps)
		ShortSteps = NumSteps;
		
	if(!(++EntryID % 10000))
		printf("%8.8d\b\b\b\b\b\b\b\b",EntryID);


	if(m_pCsvHDD != NULL)
		{
		// if HDDs need to be corelated then check for matching HDD sequence loci..
		sscanf(szDescr,"lcl|%d",&SeqID);

		Rslt=m_pCsvHDD->NextLine();	// onto next line containing fields
		NumFields = m_pCsvHDD->GetCurFields();
	
		m_pCsvHDD->GetInt(1,&HDD_ID);
		if(HDD_ID != SeqID)
			{
			gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","HDDs not matching: HDD file = %d, Fasta ID = %d",HDD_ID,SeqID);
			Reset();
			return(-1);
			}
		m_pCsvHDD->GetInt(9,&HamDistDiff); 
		}

	// remove any repeat masking and randomly substitute bases for eBaseN's - not expecting too many of these say's he hopefully!
	etSeqBase *pSeq = m_pSeq;
	for(int SeqIdx = 0; SeqIdx < SeqLen; SeqIdx++,pSeq++)
		if((*pSeq &= ~cRptMskFlg) > eBaseT)
			*pSeq = rand() % 4;
	
	if(PMode != ePMfastaconf && PMode != ePMHamm)
		{
		for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
			{
			if((Rslt = m_pTwister->GetSequenceConformation((teOctStructStats)Conf,	// process for this conformational parameter
							  0,								// initial starting offset (0..n) in pSeq
							  NumSteps,			                // number of steps (0 for all) to process starting at pSeq[iStartPsn]|pSeq[iStartPsn+1]
  							  SeqLen,							// number of nucleotides
							  m_pSeq,							// sequence to be processed
							  m_pConfValues))!=eBSFSuccess)		// where to return conformational values
					{
					gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","ProcessSequence failed");
					Reset();
					return(Rslt);
					}
			for(int Step = 0; Step < ShortSteps; Step++)
				{
				if(m_pConfValues[Step] <  -100000000)		     // treat extreme values as not a value...
					m_pConfValues[Step] = 0;
				FreqBin = (Step * cNumMedFreqBins);
				FreqBin +=  (int)(((INT64)(m_pConfValues[Step] - m_ConfRange[Conf].Min) * cNumMedFreqBins) / m_ConfRange[Conf].Range);
				m_ConfRange[Conf].pStepFreqs[FreqBin] += 1;
				}
			}
		continue;
		}



	if(PMode == ePMHamm)
		{
		etSeqBase Base;
		tsDescrStats *pDescrStat;
		tsDescrStats RptStats;
		int CurConfWinLen;
		int GCcnt;
		double GCprop;
		GCcnt = 0;
		// interesting to know what the GC content is..
		pSeq = m_pSeq;
		for(Idx = 0; Idx < SeqLen; Idx++)
			{
			Base = *pSeq++ & 0x07;
			if(Base == eBaseC || Base == eBaseG)
				GCcnt += 1;
			}

		// accumulate basic statistics for each Hamming
		if(HamDistDiff > MaxHamDistDiff)
			MaxHamDistDiff = HamDistDiff;
		GCprop = (double)GCcnt/SeqLen;
		HamDists[HamDistDiff].NumInsts += 1;
		HamDists[HamDistDiff].GCprop += GCprop;

		BuffOfs += sprintf(&szBuff[BuffOfs],"%d,\"%s\",%d,%f",EntryID,szDescr,HamDistDiff,GCprop);
		memset(DescrStats,0,sizeof(DescrStats));
		pDescrStat = DescrStats;
		for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
			{
			if((Rslt = m_pTwister->GetSequenceConformation((teOctStructStats)Conf,	// process for this conformational parameter
							  0,								// initial starting offset (0..n) in pSeq
							  NumSteps,			                // number of steps (0 for all) to process starting at pSeq[iStartPsn]|pSeq[iStartPsn+1]
  							  SeqLen,							// number of nucleotides
							  m_pSeq,							// sequence to be processed
							  m_pConfValues))!=eBSFSuccess)		// where to return conformational values
					{
					gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","ProcessSequence failed");
					Reset();
					return(Rslt);
					}

			DescriptiveStatsInt(NumSteps,m_pConfValues,pDescrStat);
			if(ConfWinLen > 0)
				{
				if(ConfWinLen > NumSteps)
					CurConfWinLen = NumSteps;
				else
					CurConfWinLen = ConfWinLen;

				// locate highest/lowest scoring window..
				for(Idx = 0; Idx <= NumSteps - ConfWinLen; Idx++)
					{
					DescriptiveStatsInt(CurConfWinLen,&m_pConfValues[Idx],&RptStats);
					if(Idx == 0)
						{
						pDescrStat->Min = pDescrStat->Mean;
						pDescrStat->Max = pDescrStat->Mean;
						}
					else
						{
						if(RptStats.Mean < pDescrStat->Min)
							pDescrStat->Min = RptStats.Mean;

						if(RptStats.Mean > pDescrStat->Max)
							pDescrStat->Max = RptStats.Mean;
						}
					}
				}

			HamDists[HamDistDiff].ConfMeans[Conf] += pDescrStat->Mean;

			BuffOfs += sprintf(&szBuff[BuffOfs],",%f,%f,%f,%f,%f",pDescrStat->Min,pDescrStat->Max,pDescrStat->Mean,pDescrStat->Variance,pDescrStat->StdDev);
			pDescrStat += 1;
			if(BuffOfs + 200 > sizeof(szBuff))
				{
				if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
					{
					Reset();
					return(eBSFerrWrite);
					}
				BuffOfs = 0;
				}
			}
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n");
		continue;
		}


	if(EntryID == 1)
		{
		BuffOfs += sprintf(&szBuff[BuffOfs],"\"%s:ID\",\"Entry\",\"Min\",\"Mean\",\"Max\",\"StdDev\",\"Steps\"",m_pTwister->MapStructParam2Txt(ConfP));
		for(int SeqIdx = 0; SeqIdx < TruncLength; SeqIdx += 1)
			BuffOfs += sprintf(&szBuff[BuffOfs],",\"Step_%d\"",SeqIdx+1);
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n");
		if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
			{
			Reset();
			return(eBSFerrWrite);
			}
		BuffOfs = 0;
		}

	tsStructStats ConfStats;
	if((Rslt = m_pTwister->CalcTwistStats(0,NumSteps,SeqLen,m_pSeq,ConfP,&ConfStats))!=eBSFSuccess)		// where to return conformational values
		{
		gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","ProcessSequence failed");
		Reset();
		return(Rslt);
		}

	if((Rslt = m_pTwister->GetSequenceConformation(ConfP,	// process for this conformational parameter
						  0,								// initial starting offset (0..n) in pSeq
						  NumSteps,			                // number of steps (0 for all) to process starting at pSeq[iStartPsn]|pSeq[iStartPsn+1]
  						  SeqLen,							// number of nucleotides
						  m_pSeq,							// sequence to be processed
						  m_pConfValues))!=eBSFSuccess)		// where to return conformational values
				{
				gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","ProcessSequence failed");
				Reset();
				return(Rslt);
				}

	BuffOfs += sprintf(&szBuff[BuffOfs],"%d,\"%s\",%1.6f,%1.6f,%1.6f,%1.6f,%d",
						EntryID,szDescr,(double)ConfStats.Min/10000.0f,(double)ConfStats.Mean/10000.0f,(double)ConfStats.Max/10000.0f,(double)ConfStats.StdDev/10000.0f,NumSteps);
	for(int Step = 0; Step < TruncLength; Step += 1)
		{
		if(Step < NumSteps)
			BuffOfs += sprintf(&szBuff[BuffOfs],",%1.6f",(double)m_pConfValues[Step]/10000.0f);
		else
			BuffOfs += sprintf(&szBuff[BuffOfs],",%1.6f",0.0);
		if(BuffOfs + 200 > sizeof(szBuff))
			{
			if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
				{
				Reset();
				return(eBSFerrWrite);
				}
			BuffOfs = 0;
			}
		}
	BuffOfs += sprintf(&szBuff[BuffOfs],"\n");
	}

if(PMode == ePMHamm)
	{
	tsHamDists *pHamDists;
	UINT32 NumInsts;

	const char *pszConfDescr;

	if(BuffOfs + 200 > sizeof(szBuff))
		{
		if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
			{
			Reset();
			return(eBSFerrWrite);
			}
		BuffOfs = 0;
		}

	BuffOfs += sprintf(&szBuff[BuffOfs],"\n\n\n\"NumReads\",\"MinHamming\",\"GCcontent\"");
	for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
		{
		switch(Conf) {
			case eSSenergy:				// minimal energy int(energy * 10000) e.g. -408.2632 ==> -4082632
				pszConfDescr = "Energy";
				break;
			case eSSminorgroove:		// minor groove int (dimensions * 10000) e.g 10.784 ==> 107840
				pszConfDescr = "Minor groove";
				break;
			case eSSmajorgroove:				
				pszConfDescr = "Major groove inferenced from octamer twist + rise";
				break;
			case eSStwist:				// twist int(angle * 10000) e.g 	37.6262 ==> 376262
				pszConfDescr = "Twist";
				break;
			case eSSroll:				// roll int(angle * 10000) e.g 	2.4139 ==> 24139
				pszConfDescr = "Roll";
				break;
			case eSStilt:				// tilt int(tilt * 10000) e.g 	-0.022 ==> -220
				pszConfDescr = "Tilt";
				break;
			case eSSrise:				// rise int(rise * 10000) e.g 	3.1409 ==> 31409
				pszConfDescr = "Rise";
				break;
			case eSSslide:				// slide int(slide * 10000) e.g 	-0.0968 ==> -968	
				pszConfDescr = "Slide";
				break;
			case eSSshift:				// shift int(shift * 10000) e.g 	0.0645 ==> 645
				pszConfDescr = "Shift";
				break;
			case eSSrmsd:				// rmsd int(rmsd * 10000) e.g 	0.3078 ==> 3078
				pszConfDescr = "Rmsd";
				break;
			case eSSORChidVal:			// hydroxyl radical cleavage value from ORChid dataset
				pszConfDescr = "ORChid";
				break;
			}
		BuffOfs += sprintf(&szBuff[BuffOfs],",\"%s\"",pszConfDescr);
		}
	BuffOfs += sprintf(&szBuff[BuffOfs],"\n");

	pHamDists = HamDists;
	for(Idx = 0; Idx <= MaxHamDistDiff; Idx++,pHamDists++)
		{
		if(BuffOfs > 0)
			{
			if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
				{
				Reset();
				return(eBSFerrWrite);
				}
			BuffOfs = 0;
			}
		NumInsts = pHamDists->NumInsts;
		BuffOfs += sprintf(&szBuff[BuffOfs],"%d,%d,%f",NumInsts,Idx,NumInsts > 0 ? pHamDists->GCprop/NumInsts : 0.0);
		for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
			BuffOfs += sprintf(&szBuff[BuffOfs],",%f",pHamDists->ConfMeans[Conf]/NumInsts);
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n");
		}
	}

if((PMode == ePMfastaconf ||  PMode == ePMHamm) && BuffOfs)
	{
	if(BuffOfs > 0)
		{
		if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
			{
			Reset();
			return(eBSFerrWrite);
			}
		BuffOfs = 0;
		}
	}

if(PMode != ePMfastaconf  && PMode != ePMHamm)
	{
	int *pConfCnts;
	double ConfValue;

	// a) apply any trimming if TrimPercentile > 0
	if(TrimPercentile > 0)
		{
		int ToTrim = (int)(((INT64)EntryID * TrimPercentile)/200);
		int AccumCnts;
		int AccumResidual;
		// first trim the bottom percentile
		for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
			{
			AccumCnts = 0;
			FreqBin = 0;
			for(int Step = 0; Step < ShortSteps; Step += 1,FreqBin += cNumMedFreqBins)
				{
				AccumCnts = 0;
				AccumResidual = ToTrim;
				for(Idx = 0; Idx < cNumMedFreqBins; Idx++)
					{
					AccumCnts += m_ConfRange[Conf].pStepFreqs[FreqBin + Idx];
					if(AccumCnts <= ToTrim)
						{
						m_ConfRange[Conf].pStepFreqs[FreqBin + Idx] = 0;
						AccumResidual = ToTrim - AccumCnts;
						}
					else
						{
						if(AccumResidual)
							m_ConfRange[Conf].pStepFreqs[FreqBin + Idx] -= AccumResidual;
						break;
						}
					}
				}
			}

		// now trim the top percentile
		for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
			{
			AccumCnts = 0;
			FreqBin = 0;
			for(int Step = 0; Step < ShortSteps; Step += 1,FreqBin += cNumMedFreqBins)
				{
				AccumCnts = 0;
				AccumResidual = ToTrim;
				for(Idx = cNumMedFreqBins-1; Idx >= 0; Idx--)
					{
					AccumCnts += m_ConfRange[Conf].pStepFreqs[FreqBin + Idx];
					if(AccumCnts <= ToTrim)
						{
						m_ConfRange[Conf].pStepFreqs[FreqBin + Idx] = 0;
						AccumResidual = ToTrim - AccumCnts;
						}
					else
						{
						if(AccumResidual)
							m_ConfRange[Conf].pStepFreqs[FreqBin + Idx] -= AccumResidual;
						break;
						}
					}
				}
			}

		TrimmedCnts = EntryID - (ToTrim * 2);
		}
	else
		TrimmedCnts = EntryID;


	// any trimming completed
	// calculate the median for each step
	SumFreqCnts = 0;
	for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
		{
		FreqBin = 0;
		for(int Step = 0; Step < ShortSteps; Step += 1,FreqBin += cNumMedFreqBins)
			{
			SumFreqCnts = 0;
			for(Idx = 0; Idx < cNumMedFreqBins; Idx++)
				{
				SumFreqCnts += m_ConfRange[Conf].pStepFreqs[FreqBin + Idx];
				if(SumFreqCnts >= (int)(TrimmedCnts / 2))
					break;
				}
			 m_ConfRange[Conf].pStats[Step].Median = (m_ConfRange[Conf].Min + ((Idx * (double)m_ConfRange[Conf].Range) / cNumMedFreqBins))/10000.0f;
			}
		}

	// calculate the mean for each step
	SumFreqCnts = 0;
	for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
		{
		FreqBin = 0;
		for(int Step = 0; Step < ShortSteps; Step += 1,FreqBin += cNumMedFreqBins)
			{
			SumFreqCnts = 0;
			ConfValue = 0.0f;
			pConfCnts = &m_ConfRange[Conf].pStepFreqs[FreqBin];
			for(Idx = 0; Idx < cNumMedFreqBins; Idx++,pConfCnts++)
				{
				if(*pConfCnts)
					{
					SumFreqCnts += *pConfCnts;
					ConfValue += (*pConfCnts * (m_ConfRange[Conf].Min + ((Idx * (double)m_ConfRange[Conf].Range) / cNumMedFreqBins)))/10000.0f;
					}
				}
			 m_ConfRange[Conf].pStats[Step].Mean = ConfValue / SumFreqCnts;
			}
		}

	// calculate the variance--->stdev for each step
	SumFreqCnts = 0;
	for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
		{
		FreqBin = 0;
		ConfValue = 0.0f;
		for(int Step = 0; Step < ShortSteps; Step += 1,FreqBin += cNumMedFreqBins)
			{
			SumFreqCnts = 0;
			pConfCnts = &m_ConfRange[Conf].pStepFreqs[FreqBin];
			for(Idx = 0; Idx < cNumMedFreqBins; Idx++, pConfCnts++)
				{
				if(*pConfCnts)
					{
					SumFreqCnts += *pConfCnts;
					ConfValue = (m_ConfRange[Conf].Min + ((Idx * (double)m_ConfRange[Conf].Range) / cNumMedFreqBins))/10000.0f;
					ConfValue -= m_ConfRange[Conf].pStats[Step].Mean;
					m_ConfRange[Conf].pStats[Step].Variance += pow(ConfValue,2.0);
					}
				}
			m_ConfRange[Conf].pStats[Step].Variance /= TrimmedCnts;
			m_ConfRange[Conf].pStats[Step].StdDev = sqrt(m_ConfRange[Conf].pStats[Step].Variance);
			}
		}


	BuffOfs = 0;
	for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
		{
		BuffOfs += sprintf(&szBuff[BuffOfs],",");
		for(int Step = 1; Step <= ShortSteps; Step += 1)
			{
			BuffOfs += sprintf(&szBuff[BuffOfs],",%d",Step);
			if((BuffOfs + 200) > sizeof(szBuff))
				{
				if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
					{
					Reset();
					return(eBSFerrWrite);
					}
				BuffOfs = 0;
				}
			}

		BuffOfs += sprintf(&szBuff[BuffOfs],"\n\"%s\",\"Mean\"",m_pTwister->MapStructParam2Txt((teOctStructStats)Conf));
		for(int Step = 0; Step < ShortSteps; Step++)
			{
			BuffOfs += sprintf(&szBuff[BuffOfs],",%1.6f",m_ConfRange[Conf].pStats[Step].Mean);
			if((BuffOfs + 200) > sizeof(szBuff))
				{
				if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
					{
					Reset();
					return(eBSFerrWrite);
					}
				BuffOfs = 0;
				}
			}
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n\"%s\",\"StdDev\"",m_pTwister->MapStructParam2Txt((teOctStructStats)Conf));
		for(int Step = 0; Step < ShortSteps; Step++)
			{
			BuffOfs += sprintf(&szBuff[BuffOfs],",%1.6f",m_ConfRange[Conf].pStats[Step].StdDev);
			if((BuffOfs + 200) > sizeof(szBuff))
				{
				if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
					{
					Reset();
					return(eBSFerrWrite);
					}
				BuffOfs = 0;
				}
			}
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n\"%s\",\"Median\"",m_pTwister->MapStructParam2Txt((teOctStructStats)Conf));
		for(int Step = 0; Step < ShortSteps; Step++)
			{
			BuffOfs += sprintf(&szBuff[BuffOfs],",%1.6f",m_ConfRange[Conf].pStats[Step].Median);
			if((BuffOfs + 200) > sizeof(szBuff))
				{
				if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
					{
					Reset();
					return(eBSFerrWrite);
					}
				BuffOfs = 0;
				}
			}
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n\n");
		if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
			{
			Reset();
			return(eBSFerrWrite);
			}
		BuffOfs = 0;
		}

	if(PMode == ePMextdfastaconfstats)			// user want histogram of distributions at each step?
		{
		for(Conf = eSSenergy; Conf < eSSNumStatParams; Conf += 1)
			{
			int NumHistBins = 50;
			int StartHistBin = 0;
			int DeltaHistBin;
			double BinValue;
			int AccumCnts;
			BuffOfs += sprintf(&szBuff[BuffOfs],",");
			for(int Step = 1; Step <= ShortSteps; Step += 1)
				{
				BuffOfs += sprintf(&szBuff[BuffOfs],",%d",Step);
				if((BuffOfs + 200) > sizeof(szBuff))
					{
					if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
						{
						Reset();
						return(eBSFerrWrite);
						}
					BuffOfs = 0;
					}
				}


			while(NumHistBins--)
				{
				DeltaHistBin = (cNumMedFreqBins - StartHistBin)/ (1 + NumHistBins);
				BinValue = (m_ConfRange[Conf].Min + (StartHistBin * (double)m_ConfRange[Conf].Range / cNumMedFreqBins))/10000.0f; 
				BuffOfs += sprintf(&szBuff[BuffOfs],"\n\"%s\",%1.6f",m_pTwister->MapStructParam2Txt((teOctStructStats)Conf),BinValue);
				FreqBin = 0;
				for(int Step = 0; Step < ShortSteps; Step += 1,FreqBin += cNumMedFreqBins)
					{
					AccumCnts = 0;
					for(Idx = StartHistBin; Idx < (StartHistBin + DeltaHistBin); Idx++)
						AccumCnts += m_ConfRange[Conf].pStepFreqs[FreqBin + Idx];
					BuffOfs += sprintf(&szBuff[BuffOfs],",%1.6f",(double)AccumCnts/TrimmedCnts);
					if((BuffOfs + 200) > sizeof(szBuff))
						{
						if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
							{
							Reset();
							return(eBSFerrWrite);
							}
						BuffOfs = 0;
						}
					}
				StartHistBin += DeltaHistBin;
				}
			BuffOfs += sprintf(&szBuff[BuffOfs],"\n\n");
			if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
				{
				Reset();
				return(eBSFerrWrite);
				}
			BuffOfs = 0;
			}
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n\n");
		if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
			{
			Reset();
			return(eBSFerrWrite);
			}
		BuffOfs = 0;
		}
	BuffOfs += sprintf(&szBuff[BuffOfs],"\n\n");
	if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
		{
		Reset();
		return(eBSFerrWrite);
		}
	BuffOfs = 0;
	}

gDiagnostics.DiagOut(eDLInfo,"ProcessFastaStruct","Loaded %d, processed %d sequences. %d were too short and %d were truncated",NumSeqs,EntryID,NumShortSeqs,NumTruncSeqs);


#ifdef _DEBUG
#ifdef _WIN32
_ASSERTE( _CrtCheckMemory());
#endif
#endif
Reset();
return(Rslt);
}



int
CProcessConformation::ProcessBioseqStruct(etPMode PMode,	// processing mode
		etRMode RMode,				// sequence permutation mode
		bool bPermConf,				// if true then permutate the conformational characteristic values
		teOctStructStats ConfParam,	// conformational parameter of interest
		char *pszStructParamsFile,  // structural parameters file to use
		int WindowSize,				// conformation within this sized overlapping windows
		char *pszBioseqFile,		// reference bioseq file
		char *pszResultsFile,		// write conformation structure values to this file
		int NumIncludeChroms,		// number of chromosomes explicitly defined to be included
		char **ppszIncludeChroms,	// ptr to array of reg expressions defining chroms to include - overides exclude
		int NumExcludeChroms,		// number of chromosomes explicitly defined to be excluded
		char **ppszExcludeChroms,	// ptr to array of reg expressions defining chroms to exclude
		char *pszIncludeRegionsFile)  // only process those regions specified in this biobed file
{
int Rslt;

char szBuff[cMaxReadLen+1];
int *pCurChromBins;
int BinIdx;
int BinIdxMin;					// will be set to the minimum encountered histogram bin index
int BinIdxMax;					// will be set to the maximum encountered histogram bin index

int BuffOfs;
int WindIdx;

int NumChroms;							// number of chromosomes for processing
int ProcChroms;							// number of chromosomes actually processed
int CurEntryID;							// current chromosome identifier
char szChromName[cMaxDatasetSpeciesChrom+10];  // alow to also hold suffix denoting permutation mode
int AllocdSeqBuffLen;
int SeqLen;

int WindowNs = 0;		// number of indeterminant conformational values in current window
int StepsPerWin = WindowSize - 1;
int SumRise;
int *pWinLeft;
int *pWinRight;

int MinConfValue;
int MaxConfValue;
int HistBins;
int TotHistBins;

int CurPermuteMode;
const char *pszPermMode;

CShuffle Shuffle;

Reset();

strncpy(m_szRsltsFile,pszResultsFile,_MAX_PATH);
m_szRsltsFile[_MAX_PATH-1] = '\0';

if((m_pTwister = new CTwister)==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,"ProcessBioseqStruct","Unable to create CTwister object");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt = m_pTwister->LoadStructParams(pszStructParamsFile))  < eBSFSuccess)
	{
	while(m_pTwister->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pTwister->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,"ProcessBioseqStruct","LoadStructParams(%s) failed",pszStructParamsFile);
	Reset();
	return(Rslt);
	}

MaxConfValue = m_pTwister->m_StructParamStats[ConfParam].Max;
MinConfValue =  m_pTwister->m_StructParamStats[ConfParam].Min;
HistBins = cNumHistBins;
TotHistBins = cMaxConfChroms * cNumHistBins; 

switch(RMode) {
	case eRMdefault:
		break;
	case eRMmono:
		TotHistBins *= 2;
		break;
	case eRMdi:
		TotHistBins *= 3;
		break;
	}

int Idx;
bool bProcChrom;
#ifdef _WIN32
RegexpMatch mc;
Regexp *IncludeChromsRE[cMaxIncludeChroms];	// compiled regular expressions
Regexp *ExcludeChromsRE[cMaxExcludeChroms];

try {
	for(Idx=0;Idx < NumIncludeChroms;Idx++)
		{
		IncludeChromsRE[Idx] = new Regexp();
		IncludeChromsRE[Idx]->Parse(ppszIncludeChroms[Idx],false);	// note case insensitive
		}
	}
catch(...)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process include regexpr chrom '%s'",ppszIncludeChroms[Idx]);
	return(eBSFerrMem);
	}
try {
	for(Idx=0;Idx < NumExcludeChroms;Idx++)
		{
		ExcludeChromsRE[Idx] = new Regexp();
		ExcludeChromsRE[Idx]->Parse(ppszExcludeChroms[Idx],false);	// note case insensitive
		}
	}
catch(...)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process exclude regexpr chrom '%s'",ppszExcludeChroms[Idx]);
	return(eBSFerrMem);
	}

#else
regmatch_t mc;
regex_t IncludeChromsRE[cMaxIncludeChroms];	// compiled regular expressions
regex_t ExcludeChromsRE[cMaxExcludeChroms];

int RegErr;				// regular expression parsing error
char szRegErr[128];			// to hold RegErr as textual representation ==> regerror();

for(Idx=0;Idx < NumIncludeChroms;Idx++)
	{

	RegErr=regcomp(&IncludeChromsRE[Idx],ppszIncludeChroms[Idx],REG_EXTENDED | REG_ICASE);	// note case insensitive
	if(RegErr)
		{
		regerror(RegErr,&IncludeChromsRE[Idx],szRegErr,sizeof(szRegErr));
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process include chrom '%s' error: %s",ppszIncludeChroms[Idx],szRegErr);
		return(eBSFerrMem);
		}
	}
for(Idx=0;Idx < NumExcludeChroms;Idx++)
	{
	RegErr = regcomp(&ExcludeChromsRE[Idx],ppszExcludeChroms[Idx],REG_EXTENDED | REG_ICASE);	// note case insensitive
	if(RegErr)
		{
		regerror(RegErr,&ExcludeChromsRE[Idx],szRegErr,sizeof(szRegErr));
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process exclude chrom '%s' error: %s",ppszExcludeChroms[Idx],szRegErr);
		return(eBSFerrMem);
		}
	}
#endif


if(pszIncludeRegionsFile != NULL && pszIncludeRegionsFile[0] != '\0')
	{
	if((m_pBedFile = new CBEDfile) == NULL)
		{
		Reset();
		return(eBSFerrObj);
		}
	if((Rslt=m_pBedFile->Open(pszIncludeRegionsFile,eBTAnyBed)) !=eBSFSuccess)
		{
		gDiagnostics.DiagOut(eDLFatal,"DmpBiobed","Unable to open '%s' for processing",pszIncludeRegionsFile);
		Reset();
		return(Rslt);
		}
	}

if((m_pBioSeqFile = new CBioSeqFile) == NULL)
	{
	Reset();
	return(eBSFerrObj);
	}

if((Rslt=m_pBioSeqFile->Open(pszBioseqFile,cBSFTypeSeq,false))!=eBSFSuccess)
	{
	while(m_pBioSeqFile->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pBioSeqFile->GetErrMsg());

	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open %s",pszBioseqFile);
	Reset();
	return(Rslt);
	}


if(bPermConf)					// if true then permutate the conformational characteristic values
	m_pTwister->PsudeoRandomise();

#ifdef _WIN32
if((m_hRslts = open(pszResultsFile, _O_RDWR | _O_BINARY | _O_SEQUENTIAL | _O_CREAT | _O_TRUNC, _S_IREAD | _S_IWRITE ))==-1)
#else
if((m_hRslts = open(pszResultsFile, O_RDWR | O_CREAT | O_TRUNC, S_IREAD | S_IWRITE ))==-1)
#endif
	{
	gDiagnostics.DiagOut(eDLFatal,"ProcessFastaStruct","Unable to create or truncate results file %s error: %s",pszResultsFile,strerror(errno));
	Reset();
	return(eBSFerrCreateFile);
	}

if((m_pHistBins = new int [TotHistBins]) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate memory (%d bytes) for holding histogram",TotHistBins * sizeof(int));
	Reset();
	return(eBSFerrMem);
	}

memset(m_pHistBins,0,TotHistBins * sizeof(int));

	// iterate over each entry (chromosome) in target sequence file
BuffOfs = 0;
SeqLen = 0;
AllocdSeqBuffLen = 0;
BinIdxMin = INT_MAX;	// will be set to the minimum encountered histogram bin index
BinIdxMax = 0;			// will be set to the maximum encountered histogram bin index
Rslt = eBSFSuccess;
ProcChroms = 0;
for(CurPermuteMode = 0; CurPermuteMode <= (int)RMode; CurPermuteMode++)
	{
	switch(CurPermuteMode) {
		case eRMdefault:	// no permutation
			pszPermMode = "";
			break;
		case eRMmono:		// permute monomers
			pszPermMode = "_1";
			break;

		case eRMdi:			// permute dimers
			pszPermMode = "_2";
			break;
		}
	CurEntryID = 0;
	NumChroms = 0;
	while((CurEntryID = m_pBioSeqFile->Next(CurEntryID)) > 0)
		{
			// get entry name - assume it will be a chromosome/contig name
		m_pBioSeqFile->GetName(CurEntryID,sizeof(szChromName),szChromName);

		// check if chrom to be excluded?
		bProcChrom = true;
		for(Idx = 0; Idx < NumExcludeChroms; Idx++)
#ifdef _WIN32	
			if(ExcludeChromsRE[Idx]->Match(szChromName,&mc))
#else
			if(!regexec(&ExcludeChromsRE[Idx],szChromName,1,&mc,0))
#endif
				{
				bProcChrom = false;
				break;
				}

		// if not explicitly excluded then check if to be explicitly included
		if(bProcChrom == true && NumIncludeChroms > 0)
			{
			bProcChrom = false;
			for(Idx = 0; Idx < NumIncludeChroms; Idx++)
				{
#ifdef _WIN32
				if(IncludeChromsRE[Idx]->Match(szChromName,&mc))
#else
				if(!regexec(&IncludeChromsRE[Idx],szChromName,1,&mc,0))
#endif
					{
					bProcChrom = true;
					break;
					}
				}
			}


		
		if(!bProcChrom)
			{
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"chromosome '%s' is excluded from processing",szChromName);
			continue;
			}

		if(NumChroms++ >= cMaxConfChroms)
			{
			gDiagnostics.DiagOut(eDLWarn,gszProcName,"Too many chromosomes, sloughing processing of remaining chromosomes");
			Rslt = eBSFSuccess;
			break;
			}
		ProcChroms += 1;

		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Processing: %s%s",szChromName,pszPermMode);

			// need to ensure buffer can hold the sequence
		SeqLen = m_pBioSeqFile->GetDataLen(CurEntryID);
		if(m_pSeq == NULL || SeqLen >= AllocdSeqBuffLen)
			{
			if(m_pSeq != NULL)
				delete m_pSeq;
			m_pSeq = NULL;
			if(m_pConfValues != NULL)
				{
				delete m_pConfValues;
				m_pConfValues = NULL;
				}
			AllocdSeqBuffLen = SeqLen + SeqLen/10; // alloc more than actually required, next sequence may not then need to be realloc'd
			m_pSeq = new unsigned char [AllocdSeqBuffLen];
			if(m_pSeq == NULL)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate memory (%d bytes) for holding chromosome sequence",AllocdSeqBuffLen);
				Rslt = eBSFerrMem;
				break;
				}

			m_pConfValues = new int [AllocdSeqBuffLen];
			if(m_pConfValues == NULL)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate memory (%d bytes) for holding conformation values",AllocdSeqBuffLen);
				Rslt = eBSFerrMem;
				break;
				}

			m_pRiseSums = new int [AllocdSeqBuffLen];
			if(m_pRiseSums == NULL)
				{
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate memory (%d bytes) for holding window conformation values",AllocdSeqBuffLen);
				Rslt = eBSFerrMem;
				break;
				}

			}
		if((Rslt=m_pBioSeqFile->GetData(CurEntryID,eSeqBaseType,0,m_pSeq,SeqLen)) != SeqLen)
			{
			while(m_pBioSeqFile->NumErrMsgs())
				gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pBioSeqFile->GetErrMsg());
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Load sequence failed...");
			break;
			}

		m_pSeq[SeqLen] = eBaseEOS;
		ShowComposition((char *)"original",SeqLen,m_pSeq);	// record initial overall composition stats

		// apply regional filtering here, concatenating regional sequences into a single sequence
		etSeqBase *pSeq = m_pSeq;
		etSeqBase Base;
		if(m_pBedFile != NULL)
			{
			int ChromID = m_pBedFile->LocateChromIDbyName(szChromName);
			if(ChromID <= 0 || !m_pBedFile->GetNumFeatures(ChromID))
				{
				gDiagnostics.DiagOut(eDLInfo,gszProcName,"No regions for chrom '%s' in file '%s'",szChromName,pszIncludeRegionsFile);
				continue;
				}
			pSeq = m_pSeq;
			while((Base = (*pSeq++ & ~cRptMskFlg)) != eBaseEOS)
				pSeq[-1] |= cRptMskFlg;

			int CurFeatID = m_pBedFile->GetFirstFeatureID(ChromID);		// first region on this chromosome
			int LastFeatID = m_pBedFile->GetLastFeatureID(ChromID);	// last region on this chromosome
			int FeatStart = 0;
			int FeatEnd = 0;
			do {
				m_pBedFile->GetFeature(CurFeatID,	// feature instance identifier
							NULL,		// where to return feature name
							NULL,		// where to return chromosome name
							&FeatStart,	// where to return feature start on chromosome (0..n) 
							&FeatEnd);	// where to return feature end on chromosome
				while(FeatStart++ <= FeatEnd)
					m_pSeq[FeatStart-1] &= ~cRptMskFlg;
				}
			while(((CurFeatID =m_pBedFile->GetNextFeatureID(CurFeatID)) <= LastFeatID) && CurFeatID > 0);
			
			for(FeatStart = FeatEnd = 0; FeatStart < SeqLen; FeatStart++)
				{
				if(!(m_pSeq[FeatStart] & cRptMskFlg))
					m_pSeq[FeatEnd++] = m_pSeq[FeatStart]; 
				}
			SeqLen = FeatEnd;  
			m_pSeq[SeqLen] = eBaseEOS;
			ShowComposition((char *)"regions",SeqLen,m_pSeq);	// record regional overall composition stats
			}

		// Substitute non-canonical bases with a random canonical base as originally clustered 'N's are more uniformally distributed after mono-nucleotide permutations
		pSeq = m_pSeq;
		while((Base = (*pSeq++ & ~cRptMskFlg)) != eBaseEOS)
			{
			if(Base > eBaseT)
				pSeq[-1] = rand() % 4;
			}
		ShowComposition((char *)"substituted 'N's",SeqLen,m_pSeq);	// record after substitution overall composition stats

		switch((etRMode)CurPermuteMode) {
			case eRMdefault:		// no random permutation of input sequences
				break;
			case eRMmono:			// permute monomers
				Shuffle.SeqShuffle(SeqLen,(char *)m_pSeq,(char *)m_pSeq);
				ShowComposition((char *)"mono-permuted",SeqLen,m_pSeq);	// record after purmutation overall composition stats
				break;
			case eRMdi:				// permute dimers
				Shuffle.SeqDPShuffle(SeqLen,(unsigned char *)m_pSeq,(unsigned char *)m_pSeq);
				ShowComposition((char *)"di-permuted",SeqLen,m_pSeq);	// record after purmutation overall composition stats
				break;
			}

		if((Rslt = m_pTwister->GetSequenceConformation((teOctStructStats)ConfParam,	// process for this conformational parameter
							  0,						// initial starting offset (0..n) in pSeq
							  0,						// number of steps (0 for all) to process starting at pSeq[iStartPsn]|pSeq[iStartPsn+1]
  							  SeqLen,					// total length of sequence
							  m_pSeq,					// sequence to be processed
							  m_pConfValues))!=eBSFSuccess) // where to return step conformational values
					{
					gDiagnostics.DiagOut(eDLFatal,"ProcessBioseqStruct","ProcessSequence failed");
					break;
					}

		int WindowOfs;

		// now have the sequence + values, let's slid the window!
		// note that if the window contains any indeterminate 'N' conformational values then
		// that window is sloughed
		// Note that as conformational values are between bases so there are SeqLen - 1 values, and this needs to be accounted for
		// so the intial window of WindowSize will accumulate WindowSize - 1 values...
		WindIdx = 0;
		WindowNs = 0;		// number of indeterminant conformational values in current window
		SumRise = 0;
		pWinLeft = m_pConfValues;
		pWinRight = m_pConfValues;

		pCurChromBins = &m_pHistBins[(ProcChroms -1) * HistBins];
		for(WindowOfs = 0; WindowOfs < (SeqLen - StepsPerWin); WindowOfs++,pWinRight++)
			{
			if(*pWinRight == INT_MIN)	// indicator that underlying base was not a,c,g or t
				WindowNs += 1;
			else
				SumRise += *pWinRight;

			if(WindowOfs < (StepsPerWin - 1)) // if still processing 1st window
				continue;

			if(WindowOfs >= StepsPerWin)
				{
				if(*pWinLeft == INT_MIN)	// indicator that underlying base was not a,c,g or t
					WindowNs -= 1;
				else
					SumRise -= *pWinLeft;
				pWinLeft += 1;
				}

			if(!WindowNs)			// if only canonical bases in current window
				{
				BinIdx = (int)(SumRise / StepsPerWin) - MinConfValue;
				if(BinIdx > BinIdxMax)
					BinIdxMax = BinIdx;
				if(BinIdx < BinIdxMin)
					BinIdxMin = BinIdx;

				pCurChromBins[BinIdx] += 1;
				m_pRiseSums[WindIdx++] = (int)SumRise; 
				}
			}

		// end of current chromosome, calc mean, variance and stddev for that current chromosome
		int IterX;
		float Mean = 0.0f;
		float Variance = 0.0f;
		float StdDev = 0.0f;
		for(IterX = 0; IterX < WindIdx; IterX++)
			Mean += m_pRiseSums[IterX] / StepsPerWin;
		Mean /= WindIdx * 10000.0f;
		for(IterX = 0; IterX < WindIdx; IterX++)
			Variance += pow(Mean - (m_pRiseSums[IterX]/(StepsPerWin * 10000.0f)),2);
		Variance /= WindIdx;
		StdDev = sqrt(Variance);
		gDiagnostics.DiagOut(eDLFatal,"Stats","%s - Rise Mean: %1.8f Variance: %1.8f StdDev: %1.8f\n",szChromName,Mean,Variance,StdDev);
		}
	}

// BinIdxMin/Max contain range of bins containing >= 1 counts
int BinIdxRange = BinIdxMax - BinIdxMin;
int DispRange = BinIdxRange;
int Bins2Accum;
int AggIdx;
int AggCnt;

if(BinIdxRange <= 1000)
	Bins2Accum = 1;
else
	if(BinIdxRange <= 2000)
		Bins2Accum = 2;
	else
		if(BinIdxRange <= 5000)
			Bins2Accum = 5;
		else
			if(BinIdxRange <= 10000)
				Bins2Accum = 10;
			else
				Bins2Accum = 25;

DispRange = BinIdxRange/Bins2Accum;
BinIdxMin = (BinIdxMin / Bins2Accum) * Bins2Accum;


BuffOfs = 0;
for(AggIdx = 0; AggIdx < DispRange; AggIdx++)
	{
	BuffOfs += sprintf(&szBuff[BuffOfs],",%1.4f",(double)((AggIdx * Bins2Accum) + BinIdxMin + MinConfValue)/10000.0f);
	if((BuffOfs + 100) > sizeof(szBuff))
		{
		if(write(m_hRslts,szBuff,BuffOfs)!=BuffOfs)
			{
			Reset();
			return(eBSFerrWrite);
			}
		CUtility::RetryWrites(m_hRslts,szBuff,BuffOfs);
		BuffOfs = 0;
		}
	}

ProcChroms = 0;
for(CurPermuteMode = 0; CurPermuteMode <= (int)RMode; CurPermuteMode++)
	{
	switch(CurPermuteMode) {
		case eRMdefault:	// no permutation
			pszPermMode = "";
			break;
		case eRMmono:		// permute monomers
			pszPermMode = "_1";
			break;

		case eRMdi:			// permute dimers
			pszPermMode = "_2";
			break;
		}
	CurEntryID = 0;
	NumChroms = 0;
	while((CurEntryID = m_pBioSeqFile->Next(CurEntryID)) > 0)
		{
		if(NumChroms++  >= cMaxConfChroms)
			break;
		ProcChroms += 1;
		// get entry name - assume it will be a chromosome/contig name
		m_pBioSeqFile->GetName(CurEntryID,sizeof(szChromName),szChromName);
		BuffOfs += sprintf(&szBuff[BuffOfs],"\n\"%s%s\"",szChromName,pszPermMode);
		if((BuffOfs + 100) > sizeof(szBuff))
			{
			CUtility::RetryWrites(m_hRslts,szBuff,BuffOfs);
			BuffOfs = 0;
			}
		pCurChromBins = &m_pHistBins[((ProcChroms -1) * HistBins) + BinIdxMin];
		
		for(int DispIdx = 0; DispIdx < DispRange; DispIdx++)
			{
			for(AggCnt = AggIdx = 0; AggIdx < Bins2Accum; AggIdx++)
				AggCnt += *pCurChromBins++;
			BuffOfs += sprintf(&szBuff[BuffOfs],",%d",AggCnt);
			if((BuffOfs + 100) > sizeof(szBuff))
				{
				CUtility::RetryWrites(m_hRslts,szBuff,BuffOfs);
				BuffOfs = 0;
				}
			}
		}
	}


if(BuffOfs)
    CUtility::RetryWrites(m_hRslts,szBuff,BuffOfs);

Reset();
return(Rslt);
}


// ShowComposition
// show basic compositional statistics to user - mono and dinucleotide frequencies
void 
CProcessConformation::ShowComposition(char *pszMsg,	// message to display
					 int Len,		// number of bases ptd to by pSeq
					 etSeqBase *pSeq) // bases over which to to show basic composition stats
{
char szStats[cMaxReadLen+1];
int Idx;
int MonoIdx;
int PrvIdx;
int MonoCnts[eBaseN+1];
int DiCnts[eBaseN+1][eBaseN+1];
memset(MonoCnts,0,sizeof(MonoCnts));
memset(DiCnts,0,sizeof(DiCnts));

for(Idx = 0; Idx < Len; Idx++, pSeq++)
	{
	MonoIdx = *pSeq & ~cRptMskFlg;
	if(MonoIdx > eBaseT)		// treat all non-canonical bases as eBaseN's
		MonoIdx = eBaseN;
	MonoCnts[MonoIdx] += 1;
	if(Idx > 0)
		DiCnts[PrvIdx][MonoIdx] += 1;
	PrvIdx = MonoIdx;
	}
Idx = sprintf(szStats,"1-mer - %s - a: %d c: %d g: %d t: %d n: %d",pszMsg,MonoCnts[0],MonoCnts[1],MonoCnts[2],MonoCnts[3],MonoCnts[4]);
gDiagnostics.DiagOut(eDLInfo,"ShowComposition",szStats);
Idx = sprintf(szStats,"2-mer - %s - ",pszMsg);
for(PrvIdx = 0; PrvIdx < 5; PrvIdx++)
	for(MonoIdx = 0; MonoIdx < 5; MonoIdx++)
		Idx += sprintf(&szStats[Idx]," %c%c: %d",CSeqTrans::MapBase2Ascii(PrvIdx),CSeqTrans::MapBase2Ascii(MonoIdx),DiCnts[PrvIdx][MonoIdx]);
gDiagnostics.DiagOut(eDLInfo,"ShowComposition",szStats);
}