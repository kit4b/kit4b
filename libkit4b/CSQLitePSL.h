/*
This toolkit is a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) and contains
significant source code changes enabling new functionality and resulting process parameterisation changes. These changes have resulted in
incompatibility with 'BioKanga'.

Because of the potential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019, 2020
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.

Original 'BioKanga' copyright notice has been retained and immediately follows this notice..
*/
/*
 * CSIRO Open Source Software License Agreement (GPLv3)
 * Copyright (c) 2017, Commonwealth Scientific and Industrial Research Organisation (CSIRO) ABN 41 687 119 230.
 * See LICENSE for the complete license information (https://github.com/csiro-crop-informatics/biokanga/LICENSE)
 * Contact: Alex Whan <alex.whan@csiro.au>
 */

#pragma once

const int cMaxPSLIdntNameLen = 80;		// experiment identifiers and other names can be of this maximal length
const int cMaxPSLSeqNameLen =  80;		// query and targeted sequence names can be of this maximal length
const int cMaxPSLIdntDescrLen = 1000;	// allow experiment conditions, and other descriptive fields, to be described by text of this maximal length

const int cMaxCacheExprIDs = 100;		// cache the last 100 experiment identifiers

const int cMaxInBuffSize  = 10000000;	// read in chunks of this size from source psl file
const int cMaxLenPSLline = 32000;		// max length PSL line expected - just a guess!
const int cMaxNumPSLblocks = 1000;		// max number of blocks in any PSL alignment - again just a guess!

const int cAllocAlignSummaryInsts=1000000; // allocate in increments of this number of alignment summary instances

typedef struct TAG_sStmsSQL {
	char *pTblName;					// table name
	char *pszCreateTbl;				// SQL statement used to create the table
	char *pszInsert;				// SQL statement used to insert row into table
	sqlite3_stmt *pPrepInsert;		// prepared insert row statement; NULL if not prepared
	char *pszOpenCreateSafeIndexes;	// SQL statement used to create indexes on this table immediately after opening this database, essentially these are used whilst populating
	char *pszOpenCreateIndexes;		// SQL statement used to create indexes on this table immediately after opening this database, when it is known the inputs are generated by 'genmarkers' essentially these are used whilst populating
	char *pszCreateIndexes;			// SQL statement used to create indexes on this table before closing the database
	char *pszDropIndexes;			// SQL statement used to drop indexes on this table
} tsStmSQL;

#pragma pack(1)

typedef struct TAG_sAlignSummary {
		UINT16 AlignSummarySize;	// size of this alignment summary instance
		INT32 ExprID;				// alignment summary was from this experiment
		INT32 HashSummaryInst;		// hash for this summary instance
		UINT64 NxtHashedSummaryInstOfs;   // offset+1 of next alignment summary instance with same hash, 0 if last instance with same HashSummaryInst
		UINT8 FlgIsQuery:1;			// 0 if summary for target, 1 if summary for query
		UINT32 SeqLen;				// query or target sequence is this length
		UINT32 NumAlignments;		// if target then total number of alignments to this target, if query then total number of alignments from this query
		UINT8 SeqNameLen;				// length of '/0' terminated sequence name
		UINT8 SeqName[1];			// lower cased query or target sequence name, extended out to actual length+1 of sequence name
	} tsAlignSummary;

#pragma pack()

class CSQLitePSL
{
	char m_szPSLinFile[_MAX_PATH];  // processing this input PSL file
	int m_hPSLinFile;				// opened file handle for psl files
	UINT8 *m_pInBuffer;				// mem allocd to buffer chars being read from psl
	size_t m_AllocdInBuffer;		// m_pInBuffer allocated to hold at most this many chars
	int m_NumInBuffer;				// num of chars currently in pInBuffer
	int m_InBuffIdx;				// index of next char to read from pInBuffer[]
	int m_PushedBack;				// last pushed back char (only 1 level of pushback supported!)

	UINT8 *m_pszPSLLineBuff;		// allocd PSL line buffer
	size_t m_AllocdPSLLineBuffer;	// m_pszPSLLineBuff allocated to hold at most this many chars
	int m_CurLineLen;				// current line length in pszLineBuff

	int m_PMode;					// processing mode, 0 to delete any existing then create new SQLite, 1 to append to existing SQLite
	int m_MinIdentity;				// minimum required identity
	int m_MinScore;					// minimum required score
	int m_MinMatches;				// minimum required base matches

	int m_NumBlatHitsParsed;		// number of blat hits parsed
	int m_NumBlatHitsAccepted;		// number of blat hits accepted

	UINT32 m_NumAlignSummaries;				// current number of alignment summaries in m_pAlignmentSummaries
	size_t m_UsedAlignmentSummariesSize;	// m_NumAlignSummaries is using this much of the current allocation m_pAlignmentSummaries size
	size_t m_allocAlignmentSummariesSize;	// current allocation m_pAlignmentSummaries size
	tsAlignSummary *m_pAlignmentSummaries;  // allocated to hold alignment summaries
	INT64 m_AlignSummaryInstancesOfs[0x100000]; // offsets into m_pAlignmentSummaries[] for first instance of an alignment summary instance having same 20bit hash, 0 if no instance exists with same hash  



	sqlite3 *m_pDB;						// pts to instance of SQLite
	static tsStmSQL m_StmSQL[4];		// SQLite table and index statements

	int m_NumAlignments;				// number of alignments added to TblBlatAlignments
	int m_NumBlocks;					// number of alignment blocks added to TblBlatAlignmentBlocks

	int		GetNxtPSLChr(void);			// returns buffered PSL file char,  0: EOF, -1: error, >0 chr 

	int ProcessPSLline(int ExprID);		// parse alignment PSL line which is in this experiment

	int ProcessPSLFile(char *pszInPSL,		// parse and load the alignments in this Blat generated PSL file into SQLite
						    int ExprID);	// the alignments are in this experiment

	int ProcessPSL(int ExprID);

	INT32			// 20bit instance hash over the combination of parameterisation values passed into this function; if < 0 then hashing error 
		GenSummaryInstanceHash(INT32 ExprID,// alignment summary is for alignment in this experiment
						bool bIsQuery,		// false if SeqName is for a target sequence, true if for a query sequence
						char *pszSeqName,	// NULL terminated sequence name
						UINT32  SeqLen);	// query or target sequence length

	tsAlignSummary *LocateAlignSummary(INT32 ExprID,		// alignment summary is for alignment in this experiment
						bool bIsQuery,	// false if SeqName is for a target sequence, true if for a query sequence
						char *pszSeqName,	// locate pre-existing, or allocate new if not pre-existing, alignment summary for bIsQuery type
						UINT32  SeqLen);	// query or target sequence length

	int AddSummaryInstances2SQLite(void);  // add all summary instances to SQLite


	static char *RemoveQuotes(char *pszRawText);
				
	static int ExecCallbackID(void *pCallP1, // callback function processing identifier (4th arg to sqlite3_exec())
					int NumCols,			// number of result columns 
					char **ppColValues,		// array of ptrs to column values 
					char **ppColName);		// array of ptrs to column names

public:
	CSQLitePSL(void);
	~CSQLitePSL(void);

	sqlite3 *
		CreateDatabase(char *pszDatabase,		// database to create (any existing database is deleted then clean created)
						bool bAppend = true);	// true to append onto any existing database

	int											// errors if < eBSFSuccess, if positive then the ExprID
		CreateExperiment(char *pszExprName,		// experiment name
				char *pszPSLFile,				// alignments were parsed from this BLAT generated PSL file
				char *pszQueryFile,				// Blat'd query sequences in this file
				char *pszTargetFile,			// against targeted sequences in this file
				char *pszExprDescr = NULL,		// describes experiment
				char *pszBlatParams = NULL,		// Blat parameters used
				int ExprType = 0);				// experiment type, currently just a place holder and defaults to 0

	int BeginPopulatingTables(void);

	int EndPopulatingTables(void);


	int
		CloseDatabase(bool bNoIndexes = false);

	int
		AddAlignSummary(INT32 ExprID,		// alignment summary is for alignment in this experiment
				char *pszQName,				// query sequence name, NULL or '\0' if unknown
				UINT32  QSize,				// query sequence size, 0 if unknown
				char *pszTName,				// target sequence name, NULL or '\0' if unknown
				UINT32  TSize);				// target sequence size

	int											// errors if < eBSFSuccess else alignment identifier
		AddAlignment(int ExprID,			// alignment was in this experiment
					int Score,				// Alignment score (using Blat pslScore() function)
					int Identity,           // Alignment identity (using Blat 100.0 - pslCalcMilliBad(psl, TRUE) * 0.1)
					int Matches,			// number of matches which aren't repeats
					int Mismatches,			// number of bases which do not match
					int RepMatches,			// number of bases which match but are also repeats
					int NCount,				// number of N bases
					int QNumInDels,			// number of InDel seqs in query
					int QBasesInDels,		// number of bases total in all InDels in query
					int TNumInDels,			// number of InDel seqs in target
					int TBasesInDels,		// number of bases total in all InDels in target
					char *pszStrand,		// '+' or '-' for query strand, optionally followed by '+' or '-' for target genomic strand when using translated alignments
					char *pszQName,			// query sequence name
					int  QSize,				// query sequence size
					int  QStart,			// alignment start psn in query
					int  QEnd,				// alignment end psn in query
					char *pszTName,			// target sequence name
					int  TSize,				// target sequence size
					int  TStart,			// alignment start psn in target
					int  TEnd,				// alignment end psn in target
					int  NumBlocks,			// number of blocks in the alignment
					int  *pBlockSizes,		// array of sizes of each block
					int  *pQStarts,			// starting psn of each block in query
					int  *pTStarts);		// starting psn of each block in target


		// following pslCalcMilliBad(), pslIsProtein() and pslScore() have been extracted from UCSC code at http://genome.ucsc.edu/FAQ/FAQblat.html#blat4
		int pslCalcMilliBad(int Matches,			// number of matches which aren't repeats
			int Mismatches,			// number of bases which do not match
			int RepMatches,			// number of bases which match but are also repeats
			int QNumInDels,			// number of InDel seqs in query
			int TNumInDels,			// number of InDel seqs in target
			int  QSize,				// query sequence size
			int  QStart,			// alignment start psn in query
			int  QEnd,				// alignment end psn in query
			char *pszStrand,		// '+' or '-' for query strand, optionally followed by '+' or '-' for target genomic strand when using translated alignments
			int  TSize,				// target sequence size
			int  TStart,			// alignment start psn in target
			int  TEnd,				// alignment end psn in target
			int  NumBlocks,			// number of blocks in the alignment
			int  *pBlockSizes,		// array of sizes of each block
			int  *pQStarts,			// starting psn of each block in query
			int  *pTStarts,			// starting psn of each block in target,
			bool isMrna = true); // isMrna should be set to TRUE, regardless of whether the input sequence is mRNA or protein

		// is psl a protein psl (are it's blockSizes and scores in protein space) 
		bool pslIsProtein(char *pszStrand,		// '+' or '-' for query strand, optionally followed by '+' or '-' for target genomic strand when using translated alignments
			int  TSize,				// target sequence size
			int  TStart,			// alignment start psn in target
			int  TEnd,				// alignment end psn in target
			int  NumBlocks,			// number of blocks in the alignment
			int  *pBlockSizes,		// array of sizes of each block
			int  *pQStarts,			// starting psn of each block in query
			int  *pTStarts);			// starting psn of each block in target

		int	pslScore(int Matches,			// number of matches which aren't repeats
			int Mismatches,			// number of bases which do not match
			int RepMatches,			// number of bases which match but are also repeats
			int QNumInDels,			// number of InDel seqs in query
			int TNumInDels,			// number of InDel seqs in target
			char *pszStrand,		// '+' or '-' for query strand, optionally followed by '+' or '-' for target genomic strand when using translated alignments
			int  TSize,				// target sequence size
			int  TStart,			// alignment start psn in target
			int  TEnd,				// alignment end psn in target
			int  NumBlocks,			// number of blocks in the alignment
			int  *pBlockSizes,		// array of sizes of each block
			int  *pQStarts,			// starting psn of each block in query
			int  *pTStarts);			// starting psn of each block in target
				
	int
		ProcessPSL2SQLite(int PMode,			// processing mode, 0 to delete any existing then create new SQLite, 1 to append to existing SQLite
					int MinIdentity,			// minimum required identity
					int MinScore,				// minimum required score
					int MinMatches,				// minimum required base matches
					char *pszDatabase,			// SQLite database file
					char *pszExprName,			// experiment name
					char *pszPSLFile,			// alignments were parsed from this BLAT generated PSL file
					char *pszQueryFile,			// Blat'd query sequences in this file
					char *pszTargetFile,		// against targeted sequences in this file
					char *pszExprDescr = NULL,	// describes experiment
					char *pszBlatParams = NULL,	// Blat parameters used
					int ExprType = 0);			// experiment type, currently just a place holder and defaults to 0

};



