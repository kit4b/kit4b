/*
This toolkit is a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) and contains
significant source code changes enabling new functionality and resulting process parameterisation changes. These changes have resulted in
incompatibilty with 'BioKanga'.

Because of the potentential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.

Orginal 'BioKanga' copyright notice has been retained and immediately follows this notice..
*/
/*
 * CSIRO Open Source Software License Agreement (GPLv3)
 * Copyright (c) 2017, Commonwealth Scientific and Industrial Research Organisation (CSIRO) ABN 41 687 119 230.
 * See LICENSE for the complete license information (https://github.com/csiro-crop-informatics/biokanga/LICENSE)
 * Contact: Alex Whan <alex.whan@csiro.au>
 */
#pragma once

const int cAlignNumSNPfields = 23;			// if generated by 'kit4b align' then there will be this many CSV fields
const int cSNPMarkerNumFields = 4 + 9;		// if generated by 'kit4b snpmarkers' then there will be a minimum of this number of CSVfields

typedef struct TAG_sCultivar {
	char szName[cMaxDatasetSpeciesChrom+1];		// name of this cultivar
} tsCultivar;

class CSNPLoci
{
	char m_TargAssemblyName[cMaxDatasetSpeciesChrom+1]; // alignments were against this targeted assembly
	int m_NumCultivars;							// number of cultivars being processed
	tsCultivar m_Cultivars[cMaxCultivars];		// cultivar specific metadata
	CCSVFile *m_pCSV;							// used to load SNP calls
	int LoadSNPs(char *pszSNPFile);				// load SNP calls from this CSV file
	int LoadSeqs(char *pszSeqFile);				// load sequences from this multifasta file, SNPs were called relatative to these sequences
	int Filter(int MinSep);						// filter out SNPs which are not separated by at least this many bases from any other SNP loci 
	int Dedupe(bool bSenseOnly=false);			// remove any SNP sequences which are duplicates of other SNP sequences
	int Report(char *pszOutFile);				// report SNP sequences to this file

public:
	CSNPLoci(void);
	~CSNPLoci(void);

	void Reset(void);							// re-initialise  
	int Process(char *pszSNPFile,				// load SNP calls from this CSV file
				char *pszSeqFile,				// load sequences from this multifasta file, SNPs were called relatative to these sequences
				char *pszOutFile,				// report SNP sequences to this file
				int  Extd5,						// extend SNP 5' this many bases
				int  Extd3,						// extend SNP 3' this many bases
				int MinSep,						// filter out SNPs which are not separated by at least this many bases from any other SNP loci
				bool bSenseOnly=false);			// remove any SNP sequences which are duplicates of other SNP sequences
};

