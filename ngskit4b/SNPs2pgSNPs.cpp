/*
This toolkit is a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) and contains
significant source code changes enabling new functionality and resulting process parameterisation changes. These changes have resulted in
incompatibility with 'BioKanga'.

Because of the potential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019, 2020
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.

Original 'BioKanga' copyright notice has been retained and immediately follows this notice..
*/
/*
 * CSIRO Open Source Software License Agreement (GPLv3)
 * Copyright (c) 2017, Commonwealth Scientific and Industrial Research Organisation (CSIRO) ABN 41 687 119 230.
 * See LICENSE for the complete license information (https://github.com/csiro-crop-informatics/biokanga/LICENSE)
 * Contact: Alex Whan <alex.whan@csiro.au>
 */

#include "stdafx.h"

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if _WIN32
#include <process.h>
#include "../libkit4b/commhdrs.h"
#else
#include <sys/mman.h>
#include <pthread.h>
#include "../libkit4b/commhdrs.h"
#endif

#include "./ngskit4b.h"
#include "SNPs2pgSNPs.h"




int Process(eModepgSNP Mode,				// processing mode
			int MinCoverage,				// must be at least this coverage at SNP site
			double MinAlleleProp,			// putative allele must be at least this proportion of total site read coverage
			double PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
			char* pszTrackName,				// track name
			char* pszAssemblyName,			// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
			char* pszExperimentDescr,		// describes experiment
			etSetOp SetOp,					// set operation on SetA and/or SetB				
			int NumInSetA,					// number of species/cultivars/isolates in SetA
			char** ppszSetA,				// names of those cspecies/cultivars/isolates which are in SetA
			int NumInSetB,					// number of species/cultivars/isolates in SetB
			char **ppszSetB,				// names of those cspecies/cultivars/isolates in SetB
			char* pszSNPFile,				// load SNP calls from this CSV file, can be either SNPs generated by kalign or snpmarkers
			char* pszOutFile);				// output SNPs to this UCSC Personal Genome SNP format file



#ifdef _WIN32
int SNPs2pgSNPs(int argc, char* argv[])
{
	// determine my process name
_splitpath(argv[0], NULL, NULL, gszProcName, NULL);
#else
int
SNPs2pgSNPs(int argc, char** argv)
{
	// determine my process name
	CUtility::splitpath((char*)argv[0], NULL, gszProcName);
#endif
	int Len;
	int iFileLogLevel;			// level of file diagnostics
	int iScreenLogLevel;		// level of file diagnostics
	char szLogFile[_MAX_PATH];	// write diagnostics to this file
	int Rslt = 0;   			// function result code >= 0 represents success, < 0 on failure
	
	int NumberOfProcessors;		// number of installed CPUs

	eModepgSNP PMode;			// processing mode
	int MinCoverage;				// must be at least this coverage at SNP site
	double MinAlleleProp;			// putative allele must be at least this proportion of total site read coverage
	double PValueThres;				// only accept SNP alleles which have a PValue <= this threshold
	char szInSNPsFile[_MAX_PATH];		// processing this kalign SNP calls or snpmarker CSV file
	char szOutpgSNPsFile[_MAX_PATH];		// output in UCSC Personal Genome SNP format to this file

	int ChkAIdx;					// used when checking for duplicate names in sets
	int ChkBIdx;					// used when checking for duplicate names in sets
	etSetOp SetOp;			// set operation on SetA and/or SetB				
	int NumInSetA;					// number of species/cultivars/isolates in SetA
	char* pszSetA[cMaxSetMembers];	// names of those cspecies/cultivars/isolates which are in SetA
	int NumInSetB;					// number of species/cultivars/isolates in SetB
	char* pszSetB[cMaxSetMembers];	// names of those cspecies/cultivars/isolates in SetB

	char szTrackName[cMaxDatasetSpeciesChrom + 1];	// UCSC track name
	char szAssemblyName[cMaxDatasetSpeciesChrom + 1];	// UCSC assembly name
	char szExperimentDescr[cMaxDatasetSpeciesChrom + 1];	// describes experiment


	struct arg_lit* help = arg_lit0("h", "help", "print this help and exit");
	struct arg_lit* version = arg_lit0("v", "version,ver", "print version information and exit");
	struct arg_int* FileLogLevel = arg_int0("f", "FileLogLevel", "<int>", "Level of diagnostics written to screen and logfile 0=fatal,1=errors,2=info,3=diagnostics,4=debug");
	struct arg_file* LogFile = arg_file0("F", "log", "<file>", "diagnostics log file");

	struct arg_int* pmode = arg_int0("m", "mode", "<int>", "processing mode: 0 kalign SNP calls, 1: snpmarkers calls");
	struct arg_file* insnps = arg_file1("i", "insnps", "<file>", "input called SNPs or snpmarkers from this CSV file");

	struct arg_int* setop = arg_int0("V", "setop", "<int>", "SetA/B operator 0: none, 1: (A union B), 2: (A intersect B), 3: complement of (A union B), 4: complement of (A intersect B) 5: (A subtract B)");
	struct arg_str* seta = arg_strn("s", "seta", "<seta>", 0, cMaxSetMembers, "name of snpmarkers species/cultivar/strain in SetA");
	struct arg_str* setb = arg_strn("S", "setb", "<setb>", 0, cMaxSetMembers, "name of snpmarkers species/cultivar/strain in SetB");

	struct arg_file* outpgsnps = arg_file1("o", "outpgsnps", "<file>", "output in UCSC pgSNP format to this file (if extn '.cvf' then format will be VCF 4.1)");
	struct arg_str* experimentdescr = arg_str1("e", "experiment", "<str>", "UCSC pgSNP experiment description");
	struct arg_str* assemblyname = arg_str1("a", "assembly", "<str>", "UCSC assembly name");
	struct arg_str* trackname = arg_str1("t", "track", "<str>", "UCSC track name");
	struct arg_dbl* pvaluethres = arg_dbl0("p", "pvalue", "<dbl>", "SNP maximum allele PValue threshold (default 0.05, range 0.01..0.25)");
	struct arg_dbl* minalleleprop = arg_dbl0("P", "minalleleprop", "<dbl>", "SNP minimum allele proportion of loci site coverage (default 0.1, range 0.01..0.95)");
	struct arg_int* mincoverage = arg_int0("c", "mincoverage", "<int>", "SNP minimum loci site coverage (default 20, range 5..10000)");

	struct arg_end* end = arg_end(200);

	void* argtable[] = { help,version,FileLogLevel,LogFile,
						pmode,pvaluethres,minalleleprop,mincoverage,insnps,setop,seta,setb,outpgsnps,experimentdescr,assemblyname,trackname,end };

	char** pAllArgs;
	int argerrors;
	argerrors = CUtility::arg_parsefromfile(argc, (char**)argv, &pAllArgs);
	if (argerrors >= 0)
		argerrors = arg_parse(argerrors, pAllArgs, argtable);

	/* special case: '--help' takes precedence over error reporting */
	if (help->count > 0)
	{
		printf("\n%s %s %s, Version %s\nOptions ---\n", gszProcName, gpszSubProcess->pszName, gpszSubProcess->pszFullDescr, kit4bversion);
		arg_print_syntax(stdout, argtable, "\n");
		arg_print_glossary(stdout, argtable, "  %-25s %s\n");
		printf("\nNote: Parameters can be entered into a parameter file, one parameter per line.");
		printf("\n      To invoke this parameter file then precede its name with '@'");
		printf("\n      e.g. %s %s @myparams.txt\n", gszProcName, gpszSubProcess->pszName);
		printf("\nPlease report any issues regarding usage of %s at https://github.com/kit4b/issues\n\n", gszProcName);
		return(1);
	}

	/* special case: '--version' takes precedence error reporting */
	if (version->count > 0)
	{
 		printf("\n%s %s Version %s\n", gszProcName, gpszSubProcess->pszName, kit4bversion);
		return(1);
	}

	if (!argerrors)
	{
		if (FileLogLevel->count && !LogFile->count)
		{
			printf("\nError: FileLogLevel '-f%d' specified but no logfile '-F<logfile>\n'", FileLogLevel->ival[0]);
			exit(1);
		}

		iScreenLogLevel = iFileLogLevel = FileLogLevel->count ? FileLogLevel->ival[0] : eDLInfo;
		if (iFileLogLevel < eDLNone || iFileLogLevel > eDLDebug)
		{
			printf("\nError: FileLogLevel '-l%d' specified outside of range %d..%d\n", iFileLogLevel, eDLNone, eDLDebug);
			exit(1);
		}

		if (LogFile->count)
		{
			strncpy(szLogFile, LogFile->filename[0], _MAX_PATH);
			szLogFile[_MAX_PATH - 1] = '\0';
		}
		else
		{
			iFileLogLevel = eDLNone;
			szLogFile[0] = '\0';
		}

		// now that log parameters have been parsed then initialise diagnostics log system
		if (!gDiagnostics.Open(szLogFile, (etDiagLevel)iScreenLogLevel, (etDiagLevel)iFileLogLevel, true))
		{
			printf("\nError: Unable to start diagnostics subsystem\n");
			if (szLogFile[0] != '\0')
				printf(" Most likely cause is that logfile '%s' can't be opened/created\n", szLogFile);
			exit(1);
		}

		gDiagnostics.DiagOut(eDLInfo, gszProcName, "Subprocess %s Version %s starting", gpszSubProcess->pszName, kit4bversion);
		gExperimentID = 0;
		gProcessID = 0;
		gProcessingID = 0;
		szExperimentDescr[0] = '\0';

		PMode = pmode->count ? (eModepgSNP)pmode->ival[0] : eMpgSNPKalign;
		if (PMode < eMpgSNPKalign || PMode > eMpgSNPmarkers)
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Error: Processing mode '-m%d' specified outside of range %d..%d\n", PMode, eMpgSNPKalign, (int)eMpgSNPmarkers);
			exit(1);
			}

		strncpy(szExperimentDescr, experimentdescr->sval[0], sizeof(szExperimentDescr) - 1);
		szExperimentDescr[sizeof(szExperimentDescr) - 1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(szExperimentDescr);
		CUtility::ReduceWhitespace(szExperimentDescr);
		if ((Len =(int)strlen(szExperimentDescr)) < 3 || Len > 80)
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Error: Expected UCSC experiment description length to be in range of 3..80\n");;
			exit(1);
			}

		strncpy(szAssemblyName, assemblyname->sval[0], sizeof(szAssemblyName) - 1);
		szAssemblyName[sizeof(szAssemblyName) - 1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(szAssemblyName);
		CUtility::ReduceWhitespace(szAssemblyName);
		if ((Len = (int)strlen(szAssemblyName)) < 3 || Len > 50)
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Error: Expected UCSC assembly name length to be in range of 3..50\n");
			exit(1);
			}

		strncpy(szTrackName, trackname->sval[0], sizeof(szTrackName) - 1);
		szTrackName[sizeof(szTrackName) - 1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(szTrackName);
		CUtility::ReduceWhitespace(szTrackName);
		if ((Len=(int)strlen(szTrackName)) < 3 || Len > 50)
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Error: Expected UCSC track name length to be in range of 3..50\n");
			exit(1);
			}

		PValueThres = pvaluethres->count ? pvaluethres->dval[0] : 0.05;
		if(PValueThres <= 0.0)
			PValueThres = 0.01;
		else
			if (PValueThres > 0.25)
				PValueThres = 0.25;

		MinAlleleProp = minalleleprop->count ? minalleleprop->dval[0] : 0.10;
		if (MinAlleleProp <= 0.0)
			MinAlleleProp = 0.01;
		else
			if (MinAlleleProp > 0.95)
				MinAlleleProp = 0.95;

		MinCoverage = mincoverage->count ? mincoverage->ival[0] : 20;
		if (MinCoverage <= 5)
			MinCoverage = 5;
		else
			if (MinCoverage > 10000)
				MinCoverage = 10000;

		// show user current resource limits
#ifndef _WIN32
		gDiagnostics.DiagOut(eDLInfo, gszProcName, "Resources: %s", CUtility::ReportResourceLimits());
#endif

#ifdef _WIN32
		SYSTEM_INFO SystemInfo;
		GetSystemInfo(&SystemInfo);
		NumberOfProcessors = SystemInfo.dwNumberOfProcessors;
#else
		NumberOfProcessors = sysconf(_SC_NPROCESSORS_CONF);
#endif

		strcpy(szInSNPsFile, insnps->filename[0]);
		CUtility::TrimQuotedWhitespcExtd(szInSNPsFile);
		if (szInSNPsFile[0] == '\0')
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "No input SNPs file specified");
			exit(1);
			}

		strcpy(szOutpgSNPsFile, outpgsnps->filename[0]);
		CUtility::TrimQuotedWhitespcExtd(szOutpgSNPsFile);
		if (szOutpgSNPsFile[0] == '\0')
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "No UCSC Personal Genome or VCF SNP format output file specified");
			exit(1);
			}

		SetOp = setop->count ? (etSetOp)setop->ival[0] : eSONone;
		if (SetOp < eSONone || SetOp >= eSOPlaceHolder)
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Set operation must be in range 0..%d", eSOPlaceHolder-1);
			exit(1);
			}

		memset(pszSetA,0,sizeof(pszSetA));
		NumInSetA = 0;
		if (SetOp != eSONone && PMode == eMpgSNPmarkers && seta->count)
			{ 
			for (int Idx = 0; NumInSetA < cMaxSetMembers && Idx < seta->count; Idx++)
				{
				pszSetA[Idx] = NULL;
				if (pszSetA[NumInSetA] == NULL)
					pszSetA[NumInSetA] = new char[_MAX_PATH];
				strncpy(pszSetA[NumInSetA], seta->sval[Idx], _MAX_PATH);
				pszSetA[NumInSetA][_MAX_PATH - 1] = '\0';
				CUtility::TrimQuotedWhitespcExtd(pszSetA[NumInSetA]);
				if (pszSetA[NumInSetA][0] != '\0')
					NumInSetA++;
				}
			}

		if(SetOp != eSONone && NumInSetA == 0)
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Set operation requested but SetA is empty");
			exit(1);
			}

		if(NumInSetA)
			{
			// check for duplicate names
			for (ChkAIdx = 0; ChkAIdx < NumInSetA - 1; ChkAIdx++)
				{
				for (ChkBIdx = ChkAIdx + 1; ChkBIdx < NumInSetA; ChkBIdx++)
					{
					if (!stricmp(pszSetA[ChkAIdx], pszSetA[ChkBIdx]))
						{
						// have a duplicate name in Set
						gDiagnostics.DiagOut(eDLFatal, gszProcName, "SetA set contains duplicate name '%s'", pszSetA[ChkAIdx]);
						exit(1);
						}
					}
				}
			}

		memset(pszSetB, 0, sizeof(pszSetB));
		NumInSetB = 0;
		if (SetOp != eSONone && PMode == eMpgSNPmarkers && setb->count)
			{
			for (int Idx = 0; NumInSetB < cMaxSetMembers && Idx < setb->count; Idx++)
				{
				pszSetB[Idx] = NULL;
				if (pszSetB[NumInSetB] == NULL)
					pszSetB[NumInSetB] = new char[_MAX_PATH];
				strncpy(pszSetB[NumInSetB], setb->sval[Idx], _MAX_PATH);
				pszSetB[NumInSetB][_MAX_PATH - 1] = '\0';
				CUtility::TrimQuotedWhitespcExtd(pszSetB[NumInSetB]);
				if (pszSetB[NumInSetB][0] != '\0')
					NumInSetB++;
				}
			}

		if (NumInSetB)
			{
			// check for duplicate names
			for (ChkAIdx = 0; ChkAIdx < NumInSetB - 1; ChkAIdx++)
				{
				for (ChkBIdx = ChkAIdx + 1; ChkBIdx < NumInSetB; ChkBIdx++)
					{
						if (!stricmp(pszSetB[ChkAIdx], pszSetB[ChkBIdx]))
						{
							// have a duplicate name in set
							gDiagnostics.DiagOut(eDLFatal, gszProcName, "SetB contains duplicate name '%s'", pszSetB[ChkAIdx]);
							exit(1);
						}
					}
				}

		// check for names common to both SetA and SetB
			for (ChkAIdx = 0; ChkAIdx < NumInSetA; ChkAIdx++)
				{
				for (ChkBIdx = 0; ChkBIdx < NumInSetB; ChkBIdx++)
					{
					if (!stricmp(pszSetA[ChkAIdx], pszSetB[ChkBIdx]))
						{
						gDiagnostics.DiagOut(eDLFatal, gszProcName, "SetA and SetB contain common name '%s'", pszSetA[ChkAIdx]);
						exit(1);
						}
					}
				}
			}

		switch (SetOp) {
			case eSONone:						// no set operation
				break;
			case eSOUnion:						// union of SetA and SetB
				if (!NumInSetB)
					{
					gDiagnostics.DiagOut(eDLWarn, gszProcName, "Set union operation requested but SetB is empty");
					gDiagnostics.DiagOut(eDLWarn, gszProcName, "Treating SetA as the union");
					}
				break;
			case eSOIntersect:					// intersect of SetA and SetB
				if(!NumInSetB)
					{
					gDiagnostics.DiagOut(eDLFatal, gszProcName, "Set intersect operation requested but SetB is empty");
					exit(1);
					}
				break;
			case eSOCplUnion:					// complement of union SetA or SetB
				if (!NumInSetB)
					{
					gDiagnostics.DiagOut(eDLWarn, gszProcName, "Set complement union operation requested but SetB is empty");
					gDiagnostics.DiagOut(eDLWarn, gszProcName, "Treating SetA as the union");
					}
				break;

			case eSOCplIntersect:				// complement of intersect SetA and SetB
				if (!NumInSetB)
					{
					gDiagnostics.DiagOut(eDLFatal, gszProcName, "Set complement intersect operation requested but SetB is empty");
					exit(1);
					}
				break;

			case eSOSubtract:					// A subtract B
				if (!NumInSetB)
					{
					gDiagnostics.DiagOut(eDLWarn, gszProcName, "Set subtract union operation requested but SetB is empty");
					gDiagnostics.DiagOut(eDLWarn, gszProcName, "Using all of SetA");
					}
				break;
			}



		gDiagnostics.DiagOut(eDLInfo, gszProcName, "Processing parameters:");
		const char* pszDescr;
		switch (PMode) {
			case eMpgSNPKalign:
				pszDescr = "input SNPs are those generated by kalign";
				break;

			case eMpgSNPmarkers:
				pszDescr = "input SNPs are those generated by snpmarkers";
				break;
			}



		gDiagnostics.DiagOutMsgOnly(eDLInfo, "SNP to UCSC Personal Genome SNP or VCF4.1 format conversion : '%s'", pszDescr);

		gDiagnostics.DiagOutMsgOnly(eDLInfo, "SNP minimum loci site coverage : '%d'", MinCoverage);
		gDiagnostics.DiagOutMsgOnly(eDLInfo, "SNP minimum allele proportion of loci site coverage : '%f'", MinAlleleProp);

		gDiagnostics.DiagOutMsgOnly(eDLInfo, "SNP allele PValue threshold : '%f'", PValueThres);
		gDiagnostics.DiagOutMsgOnly(eDLInfo, "UCSC assembly name : '%s'", szAssemblyName);
		gDiagnostics.DiagOutMsgOnly(eDLInfo, "UCSC track name : '%s'", szTrackName);
		gDiagnostics.DiagOutMsgOnly(eDLInfo, "UCSC pgSNP experiment description : '%s'", szExperimentDescr);

		gDiagnostics.DiagOutMsgOnly(eDLInfo, "Input SNPs file : '%s'", szInSNPsFile);
		// check file extension, if '.vcf' then generate output formated for vcf instead of the default pgSNP format
		int Len;
		if ((Len = (int)strlen(szOutpgSNPsFile)) >= 5 && !stricmp(&szOutpgSNPsFile[Len - 4], ".vcf"))
			gDiagnostics.DiagOutMsgOnly(eDLInfo, gszProcName, "Output to '%s' is in VCF 4.1 format", szOutpgSNPsFile);
		else
			gDiagnostics.DiagOutMsgOnly(eDLInfo, gszProcName, "Output to '%s' is in UCSC pgSNP format", szOutpgSNPsFile);

		switch (SetOp) {
			case eSONone:
				pszDescr = "no Set operation";
				break;
			case eSOUnion:
				pszDescr = "union of SetA and SetB";
				break;
			case eSOIntersect:
				pszDescr = "intersect of SetA and SetB";
				break;
			case eSOCplUnion:
				pszDescr = "complement of union SetA and SetB";
				break;
			case eSOCplIntersect:
				pszDescr = "complement of intersect SetA and SetB";
				break;
			case eSOSubtract:
				pszDescr = "SetA subtract SetB";
				break;
			}

		gDiagnostics.DiagOutMsgOnly(eDLInfo, "Set operation : '%s'", pszDescr);

		if(NumInSetA)
			gDiagnostics.DiagOutMsgOnly(eDLInfo, "Number of species/cultivars/isolates in SetA : '%d'", NumInSetA);

		if (NumInSetB)
			gDiagnostics.DiagOutMsgOnly(eDLInfo, "Number of species/cultivars/isolates in SetB : '%d'", NumInSetB);


		if (szExperimentDescr[0] != '\0')
			gDiagnostics.DiagOutMsgOnly(eDLInfo, "Experiment description: %s", szExperimentDescr);

#ifdef _WIN32
		SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);
#endif
		gStopWatch.Start();
		Rslt = 0;
		Rslt = Process(PMode,					// processing mode
					MinCoverage,				// must be at least this coverage at SNP site
					MinAlleleProp,				// putative allele must be at least this proportion of total site read coverage
					PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
					szTrackName,				// track name
					szAssemblyName,				// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
					szExperimentDescr,			// describes experiment
					SetOp,						// set operation on SetA and/or SetB				
					NumInSetA,					// number of species/cultivars/isolates in SetA
					pszSetA,					// names of those cspecies/cultivars/isolates which are in SetA
					NumInSetB,					// number of species/cultivars/isolates in SetB
					pszSetB,					// names of those cspecies/cultivars/isolates in SetB
					szInSNPsFile,				// load SNP calls from these CSV files (can be either SNPs generated by kalign or snpmarkers
					szOutpgSNPsFile);			// output SNPs to this UCSC Personal Genome SNP format file
		Rslt = Rslt >= 0 ? 0 : 1;
		gStopWatch.Stop();

		gDiagnostics.DiagOut(eDLInfo, gszProcName, "Exit code: %d Total processing time: %s", Rslt, gStopWatch.Read());
		exit(Rslt);
	}
	else
	{
		printf("\n%s %s %s, Version %s\n", gszProcName, gpszSubProcess->pszName, gpszSubProcess->pszFullDescr, kit4bversion);
		arg_print_errors(stdout, end, gszProcName);
		arg_print_syntax(stdout, argtable, "\nUse '-h' to view option and parameter usage\n");
		exit(1);
	}
return 0;
}

int Process(eModepgSNP Mode,				// processing mode
	int MinCoverage,				// must be at least this coverage at SNP site
	double MinAlleleProp,			// putative allele must be at least this proportion of total site read coverage
	double PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
	char* pszTrackName,				// track name
	char* pszAssemblyName,			// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
	char* pszExperimentDescr,		// describes experiment
	etSetOp SetOp,					// set operation on SetA and SetB	
	int NumInSetA,					// number of species/cultivars/isolates in SetA
	char** ppszSetA,				// names of those cspecies/cultivars/isolates which are in SetA
	int NumInSetB,					// number of species/cultivars/isolates in SetB
	char** ppszSetB,				// names of those cspecies/cultivars/isolates in SetB
	char* pszSNPFile,				// load SNP calls from this CSV file, can be either SNPs generated by kalign or snpmarkers
	char* pszOutFile)				// output SNPs to this UCSC Personal Genome SNP format file
{
int Rslt;
CSNPs2pgSNPs *pSNPs2pgSNPs;
if ((pSNPs2pgSNPs = new CSNPs2pgSNPs) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Unable to instantiate instance of CSNPs2pgSNPs");
	return(eBSFerrInternal);
	}
Rslt = eBSFSuccess;

Rslt = pSNPs2pgSNPs->Process(Mode, MinCoverage, MinAlleleProp,PValueThres, pszTrackName, pszAssemblyName,pszExperimentDescr, SetOp, NumInSetA, ppszSetA,NumInSetB, ppszSetB, pszSNPFile, pszOutFile);
if(pSNPs2pgSNPs != NULL)
	delete pSNPs2pgSNPs;
return(Rslt);
}


CSNPs2pgSNPs::CSNPs2pgSNPs(void)
{
m_pCSV = NULL;
m_pszLineBuff = NULL;
m_hOutpgSNPs = -1;
Reset();
}


CSNPs2pgSNPs::~CSNPs2pgSNPs(void)
{
if(m_pCSV != NULL)
	delete m_pCSV;
if(m_hOutpgSNPs!=-1)
	close(m_hOutpgSNPs);
if (m_pszLineBuff != NULL)
	delete[]m_pszLineBuff;
}

void
CSNPs2pgSNPs::Reset(void)
{
if(m_pCSV != NULL)
	{
	delete m_pCSV;
	m_pCSV = NULL;
	}
if (m_hOutpgSNPs != -1)
	{
	if (m_LineBuffOffs && m_pszLineBuff != NULL)
		CUtility::SafeWrite(m_hOutpgSNPs, m_pszLineBuff, m_LineBuffOffs);
#ifdef _WIN32
	_commit(m_hOutpgSNPs);
#else
	fsync(m_hOutpgSNPs);
#endif
	close(m_hOutpgSNPs);
	m_hOutpgSNPs = -1;
	}

if(m_pszLineBuff != NULL)
	{
	delete []m_pszLineBuff;
	m_pszLineBuff = NULL;
	}
m_AllocdLineBuff = 0;
m_LineBuffOffs = 0;
m_szInSNPsFile[0] = '\0';
m_szOutpgSNPsFile[0] = '\0';
m_TotNumSNPs = 0;
}



int 
CSNPs2pgSNPs::ProcessSnpmarkersSNPs(void)
{
int Rslt;
int NumFields;
int CultivarIdx;
tsCultivar *pCultivar;
UINT32 EstNumSNPs;
UINT32 NumSNPsParsed;
UINT32 RowNumber;
bool bMarkerFormat;
int ExpNumFields;
CStats Stats;
char szChrom[cMaxDatasetSpeciesChrom+1];
eSeqBase  RefBase;
int StartLoci;
int SNPLoci;
int NumSpeciesWithCnts;
EstNumSNPs = m_pCSV->EstNumRows();
NumSNPsParsed = 0;
RowNumber = 0;
ExpNumFields = 0;
m_NumCultivars = 0;
bMarkerFormat = false;
StartLoci = -1;
while((Rslt=m_pCSV->NextLine()) > 0)				// onto next line containing fields
	{
	RowNumber += 1; 
	NumFields = m_pCSV->GetCurFields();
	if (NumFields == cAlignNumSNPfields || NumFields < cSNPMarkerNumFields)
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "Number of fields (%d) at row %d does not match expected fields for a snpmarkers file '%s'", NumFields, RowNumber, m_szInSNPsFile, RowNumber);
		Reset();
		return(eBSFerrFieldCnt);
		}
	if(ExpNumFields && ExpNumFields != NumFields)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Inconsistency in number of fields, previously %d but %d fields parsed from '%s' near line %d",ExpNumFields,NumFields, m_szInSNPsFile,RowNumber);
		Reset();
		return(eBSFerrFieldCnt);
		}
	if(!ExpNumFields)
		{
		m_NumCultivars = (NumFields - 4)/9;
		if(((m_NumCultivars * 9) + 4) != NumFields)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Invalid number (%d) of fields parsed from '%s' near line %d, is this file generated by 'kit4b align/snpmarkers'?",NumFields, m_szInSNPsFile,RowNumber);
			Reset();
			return(eBSFerrFieldCnt);
			}
		if(m_NumCultivars > cMaxCultivars)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Too many cultivars (%d) in '%s', max allowed is %d",m_NumCultivars, m_szInSNPsFile,cMaxCultivars);
			Reset();
			return(eBSFerrFieldCnt);
			}
		bMarkerFormat = true;
		ExpNumFields = NumFields;
		}

	if(RowNumber == 1)
		{
		if(m_pCSV->IsLikelyHeaderLine()) 
			{
			if(!NumSNPsParsed && bMarkerFormat)
				{
				// parse out target assembly name against which alignments were made and the cultivar names
				char *pSrc;
				char *pDst;
				char Chr;
				int Len;

				m_pCSV->GetText(1,&pSrc);
				pDst = m_TargAssemblyName;
				Len = 0;
				while(Len < sizeof(m_TargAssemblyName)-1 && (Chr = *pSrc++) && Chr != ':')
					{
					*pDst++ = Chr;
					Len++;
					*pDst='\0';
					}
				memset(m_Cultivars,0,sizeof(m_Cultivars));
				for(CultivarIdx = 0; CultivarIdx < m_NumCultivars; CultivarIdx++)
					{
					m_pCSV->GetText(5+(CultivarIdx*9),&pSrc);
					pDst = m_Cultivars[CultivarIdx].szName;
					Len = 0;
					while(Len < sizeof(m_Cultivars[CultivarIdx].szName)-1 && (Chr = *pSrc++) && Chr != ':')
						{
						*pDst++ = Chr;
						Len++;
						*pDst='\0';
						}
					if(!m_NumInSetA)
						m_Cultivars[CultivarIdx].flgInSetA = false;
					else
						{
						int WIdx;
						for(WIdx = 0; WIdx < m_NumInSetA; WIdx++)
							{
							if(!stricmp(m_ppszSetA[WIdx], m_Cultivars[CultivarIdx].szName))
								break;
							}
						if(WIdx == m_NumInSetA)
							m_Cultivars[CultivarIdx].flgInSetA = false;
						else
							m_Cultivars[CultivarIdx].flgInSetA = true;
						}
					if (!m_NumInSetB)
						m_Cultivars[CultivarIdx].flgInSetB = false;
					else
					{
						int WIdx;
						for (WIdx = 0; WIdx < m_NumInSetB; WIdx++)
						{
							if (!stricmp(m_ppszSetB[WIdx], m_Cultivars[CultivarIdx].szName))
								break;
						}
						if (WIdx == m_NumInSetB)
							m_Cultivars[CultivarIdx].flgInSetB = false;
						else
							m_Cultivars[CultivarIdx].flgInSetB = true;
					}
					}
				}
			}
		else
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Expected CSV file '%s' first line to be a header line with  fully quoted field names", m_szInSNPsFile);
			Reset();
			return(eBSFerrFieldCnt);
			}
		continue;
		}

	char *pszTxt;
	m_pCSV->GetText(1,&pszTxt);			// get ":TargSeq"
	strncpy(szChrom,pszTxt,sizeof(szChrom));
	szChrom[sizeof(szChrom)-1] = '\0';
	m_pCSV->GetInt(2,&SNPLoci);			// get "Loci"
	m_pCSV->GetText(3,&pszTxt);			// get "TargBase"
	switch(*pszTxt) {
		case 'a': case 'A':
			RefBase = eBaseA;
			break;
		case 'c': case 'C':
			RefBase = eBaseC;
			break;
		case 'g': case 'G':
			RefBase = eBaseG;
			break;
		case 't': case 'T': case 'u': case 'U':	// U in case RNA alignments..
			RefBase = eBaseT;
			break;
		case 'n': case 'N':				// unlikely to have a SNP against an indeterminate base but you never know...
			RefBase = eBaseN;
			break;
		default:
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Expected SNP TargBase ('%s') to be one of 'ACGTN' in CSV file '%s' near line %d",pszTxt, m_szInSNPsFile,RowNumber);
			Reset();
			return(eBSFerrFieldCnt);
		}
	m_pCSV->GetInt(4,&NumSpeciesWithCnts);			// get "NumSpeciesWithCnts"
	if(NumSpeciesWithCnts < 1 || NumSpeciesWithCnts > m_NumCultivars)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Expected NumSpeciesWithCnts (%d) to be between 1 and %d in CSV file '%s' near line %d",NumSpeciesWithCnts,m_NumCultivars, m_szInSNPsFile,RowNumber);
		Reset();
		return(eBSFerrNumRange);
		}

	
	int FieldIdx = 5;
	pCultivar = m_Cultivars;
	for(CultivarIdx = 0; CultivarIdx < m_NumCultivars; CultivarIdx++,pCultivar++)
		{
		m_pCSV->GetText(FieldIdx++, &pszTxt);			// get SNP call source, either directly called 'S' or inferenced 'I'
		if(*pszTxt == 'I' || *pszTxt == 'i')
			pCultivar->flgSNPInferenced = true;
		else
			pCultivar->flgSNPInferenced = false;

		m_pCSV->GetText(FieldIdx++,&pszTxt);		// get cultivar ":Base"
		switch(*pszTxt) {
			case 'a': case 'A':
				pCultivar->CalledBase = eBaseA;
				break;
			case 'c': case 'C':
				pCultivar->CalledBase = eBaseC;
				break;
			case 'g': case 'G':
				pCultivar->CalledBase = eBaseG;
				break;
			case 't': case 'T': case 'u': case 'U':	// U in case RNA alignments..
				pCultivar->CalledBase = eBaseT;
				break;
			case 'n': case 'N':				// unlikely to have a SNP against an indeterminate base but you never know...
				pCultivar->CalledBase = eBaseN;
				break;
			default:
				gDiagnostics.DiagOut(eDLFatal,gszProcName,"Expected SNP TargBase ('%s') to be one of 'ACGTN' in CSV file '%s' near line %d",pszTxt, m_szInSNPsFile,RowNumber);
				Reset();
				return(eBSFerrFieldCnt);
			}
		m_pCSV->GetInt(FieldIdx++,&pCultivar->Score);			// get ":Score"
		m_pCSV->GetInt(FieldIdx++,&pCultivar->TotalBaseCnts);	// get ":BaseCntTot"
		m_pCSV->GetInt(FieldIdx++,&pCultivar->BaseCnts[0]);		// get ":BaseCntA"
		m_pCSV->GetInt(FieldIdx++,&pCultivar->BaseCnts[1]);		// get ":BaseCntC"
		m_pCSV->GetInt(FieldIdx++,&pCultivar->BaseCnts[2]);		// get ":BaseCntG"
		m_pCSV->GetInt(FieldIdx++,&pCultivar->BaseCnts[3]);		// get ":BaseCntT"
		m_pCSV->GetInt(FieldIdx++,&pCultivar->BaseCnts[4]);		// get ":BaseCntN"
		}

	gDiagnostics.DiagOut(eDLInfo, gszProcName, "Evaluating SNP alleles at %s:%d", szChrom, SNPLoci);

	// have all cultivars and their counts at the SNP loci
	// iterate the cultivars and for every cultivar determine which bases are allelic and count occurrences over all cultivars
	bool bHaveSNP;
	double PValue;
	int NumInSetASnps;
	int NumInSetBSnps;


	m_LocalSeqErrRate = 0.02; // big assumption is that the background error rate is constant at 0.02 over all cultivars
	bHaveSNP = false;
	NumInSetASnps = 0;
	NumInSetBSnps = 0;
	memset(m_BaseCnts, 0, sizeof(m_BaseCnts));
	pCultivar = m_Cultivars;
	for (CultivarIdx = 0; CultivarIdx < m_NumCultivars; CultivarIdx++, pCultivar++)
		{
		switch(m_SetOp) {
			case eSOSubtract:				// SetA subtract SetB
			case eSOIntersect:				// intersect of SetA and SetB
			case eSOUnion:					// union of SetA and SetB
				if(!(pCultivar->flgInSetA || pCultivar->flgInSetB)) // no interest in the universe of all SNPs, just SetA and SetB
					continue;
				break;

			default:
				break;
			}

		if(pCultivar->TotalBaseCnts < m_MinCoverage)		// have to have at least this many bases covering the loci
			continue;

		for (int Idx = 0; Idx < 4; Idx++)
			{
			if (pCultivar->BaseCnts[Idx] == 0 ||
				(pCultivar->BaseCnts[Idx] / (double)pCultivar->TotalBaseCnts) < m_MinAlleleProp)
				continue;

			PValue = 1.0 - Stats.Binomial(pCultivar->TotalBaseCnts, pCultivar->BaseCnts[Idx], m_LocalSeqErrRate);
			if (PValue > m_PValueThres)
				continue;
			else
				{
				m_BaseCnts[Idx].Cnts += 1;
				if(m_BaseCnts[Idx].QScore < pCultivar->Score)
					m_BaseCnts[Idx].QScore = pCultivar->Score;
				if(Idx != RefBase)
					{
					if(pCultivar->flgInSetA)
						NumInSetASnps++;
					if (pCultivar->flgInSetB)
						NumInSetBSnps++;
					bHaveSNP = true;
					}
				}
			}
		}

	if (!bHaveSNP)
		continue;

	// Note: some of these set operations have been prefiltered such that
	// only isolates relevant to the operation have been processed
	switch (m_SetOp) {
		case eSONone:					// no Set operation, all (universe) isolates were SNP called
			break;						// just accept!

		case eSOUnion:					// union of SetA and SetB, only isolates marked as in SetA or SetB were SNP called
			if (!(NumInSetASnps || NumInSetBSnps))	// require at least one SNP in either Set
				continue;				
			break;						// have at least one so accept!

		case eSOIntersect:					// intersect of SetA and SetB, only isolates marked as in SetA or SetB were SNP called
			if (!(NumInSetASnps && NumInSetBSnps)) // require at least one SNP in both Sets
				continue;
			break;						// SNPs in both so accept!

		case eSOCplUnion:				// complement of union SetA and SetB, all (universe) isolates were SNP called
			if(NumInSetASnps || NumInSetBSnps) // looking for universe SNPs which are not in either Set
				continue;
			break;						// have a SNP which is not in either Set


		case eSOCplIntersect:			// complement of intersect SetA and SetB, all (universe) isolates were processed for SNPs
			if (NumInSetASnps && NumInSetBSnps) // looking for universe SNPs which are not in both Sets
				continue;
			break;						// have a universe SNP which is not in both Sets

		case eSOSubtract:				// SNPs in A but which are not in B, only isolates marked as in SetA or SetB were processed for SNPs
			if(!NumInSetASnps || NumInSetBSnps)
				continue;
			break;						// have SNPs in SetA but none in SetB
		}


	// a special case: UCSC references the reference SARS-CoV-2 as being NC_O45512v2,not NC_O45512.2
	// so change NC_O45512.2 to be NC_O45512v2
	if (!stricmp(szChrom, "NC_045512.2"))
		strcpy(szChrom, "NC_045512v2");
	if (StartLoci < 0)
		{
		StartLoci = SNPLoci - 50;
		if (StartLoci < 0)
			StartLoci = 0;
		Report(true,szChrom,StartLoci,SNPLoci+50);
		}
	m_RefBase = RefBase;
	Report(false, szChrom, SNPLoci,0);
	}
if (m_LineBuffOffs)
	{
	CUtility::SafeWrite(m_hOutpgSNPs, m_pszLineBuff, m_LineBuffOffs);
	m_LineBuffOffs = 0;
	}

#ifdef _WIN32
	_commit(m_hOutpgSNPs);
#else
	fsync(m_hOutpgSNPs);
#endif
	close(m_hOutpgSNPs);
	m_hOutpgSNPs = -1;
return(0);
}



int
CSNPs2pgSNPs::ProcessKalignSNPs(void)
{
	int Rslt;
	int NumFields;
	UINT32 EstNumSNPs;
	UINT32 NumSNPsParsed;
	UINT32 RowNumber;
	bool bMarkerFormat;
	int ExpNumFields;
	int BaseCntsIdx;
	tsBaseCnts* pBaseCnts1;
	char szChrom[cMaxDatasetSpeciesChrom + 1];
	eSeqBase  RefBase;
	int StartLoci;
	int SNPLoci;
	int CntBases;
	int CntRef;
	int CntMM;
	double PValue;
	bool bHaveSNP;
	CStats Stats;

	StartLoci = -1;	// used as a flag (StartLoci < 0) to request that browser start position is to be written to pgSNP file
	
	EstNumSNPs = m_pCSV->EstNumRows();
	NumSNPsParsed = 0;
	RowNumber = 0;
	ExpNumFields = 0;
	m_NumCultivars = 0;
	bMarkerFormat = false;
	while ((Rslt = m_pCSV->NextLine()) > 0)				// onto next line containing fields
	{
		RowNumber += 1;
		NumFields = m_pCSV->GetCurFields();
		if (ExpNumFields && ExpNumFields != NumFields)
		{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Inconsistency in number of fields, previously %d but %d fields parsed from '%s' near line %d", ExpNumFields, NumFields, m_szInSNPsFile, RowNumber);
			Reset();
			return(eBSFerrFieldCnt);
		}
		if (!ExpNumFields)
			{
			if (NumFields != cAlignNumSNPfields)								// must be exactly this many if 'ngskit4b kalign' format
				{
				gDiagnostics.DiagOut(eDLFatal, gszProcName, "%d fields parsed from '%s' near line %d, expected %d, was file generated by 'kit4b kalign'?", NumFields, m_szInSNPsFile, RowNumber, cAlignNumSNPfields);
				Reset();
				return(eBSFerrFieldCnt);
				}
			m_NumCultivars = 1;
			bMarkerFormat = false;
			ExpNumFields = NumFields;
			}

		if (RowNumber == 1)
			{
			if (m_pCSV->IsLikelyHeaderLine())
				continue;
			else
				{
				gDiagnostics.DiagOut(eDLFatal, gszProcName, "Expected CSV file '%s' first line to be a header line with  fully quoted field names", m_szInSNPsFile);
				Reset();
				return(eBSFerrFieldCnt);
				}
			}

		if (!NumSNPsParsed)
			{
			// parse out target assembly name against which alignments were made and the cultivar names
			char* pSrc;
			char* pDst;
			char Chr;
			int Len;

			m_pCSV->GetText(3, &pSrc);
			pDst = m_TargAssemblyName;
			Len = 0;
			while (Len < sizeof(m_TargAssemblyName) - 1 && (Chr = *pSrc++))
			{
				*pDst++ = Chr;
				Len++;
				*pDst = '\0';
			}
			memset(&m_Cultivars[0], 0, sizeof(m_Cultivars[0]));
			strcpy(m_Cultivars[0].szName, (char*)"Unknown");
			}

		char* pszTxt;


		memset(m_BaseCnts, 0, sizeof(m_BaseCnts));
		pBaseCnts1 = &m_BaseCnts[0];
		for (BaseCntsIdx = 0; BaseCntsIdx < 5; BaseCntsIdx++, pBaseCnts1++)
			pBaseCnts1->Base = (etSeqBase)BaseCntsIdx;


		int SNPlen;
		m_pCSV->GetInt(7, &SNPlen);			// check that we are processing SNPs!
		if (SNPlen != 1)
			{
			gDiagnostics.DiagOut(eDLFatal, gszProcName, "Expected SNP CSV file '%s' to only contain 1 base SNPs, 'Len' = %d near line %d", m_szInSNPsFile, SNPlen, RowNumber);
			Reset();
			return(eBSFerrFieldCnt);
			}
		m_pCSV->GetText(4, &pszTxt);			// get "Chrom"
		strncpy(szChrom, pszTxt, sizeof(szChrom));
		szChrom[sizeof(szChrom) - 1] = '\0';
		m_pCSV->GetInt(5, &SNPLoci);			// get "StartLoci"
		m_pCSV->GetInt(11, &CntBases);		// get "Bases"
		if(CntBases < m_MinCoverage)
			continue;
		m_pCSV->GetInt(12, &CntMM);			// get "Mismatches"
		CntRef = CntBases - CntMM;
		m_pCSV->GetText(13, &pszTxt);		// get "RefBase"
		m_pCSV->GetInt(14, &m_BaseCnts[0].Cnts);	// get "MMBaseA"
		m_pCSV->GetInt(15, &m_BaseCnts[1].Cnts);	// get "MMBaseC"
		m_pCSV->GetInt(16, &m_BaseCnts[2].Cnts);	// get "MMBaseG"
		m_pCSV->GetInt(17, &m_BaseCnts[3].Cnts);	// get "MMBaseT"
		m_pCSV->GetInt(18, &m_BaseCnts[4].Cnts);	// get "MMBaseN"
		switch (*pszTxt) {
			case 'a': case 'A':
				RefBase = eBaseA;
				m_BaseCnts[0].Cnts = CntRef;
				break;
			case 'c': case 'C':
				RefBase = eBaseC;
				m_BaseCnts[1].Cnts = CntRef;
				break;
			case 'g': case 'G':
				RefBase = eBaseG;
				m_BaseCnts[2].Cnts = CntRef;
				break;
			case 't': case 'T': case 'u': case 'U':	// U in case RNA alignments..
				RefBase = eBaseT;
				m_BaseCnts[3].Cnts = CntRef;
				break;
			case 'n': case 'N':				// unlikely to have a SNP against an indeterminate base but you never know...
				RefBase = eBaseN;
				m_BaseCnts[4].Cnts = CntRef;
				break;
			default:
				gDiagnostics.DiagOut(eDLFatal, gszProcName, "Expected SNP RefBase ('%s') to be one of 'ACGTN' in CSV file '%s' near line %d", pszTxt, m_szInSNPsFile, RowNumber);
				Reset();
				return(eBSFerrFieldCnt);
			}
		m_pCSV->GetDouble(19, &m_LocalSeqErrRate);	// get "BackgroundSubRate"

		bHaveSNP = false;
		for (int Idx = 0; Idx < 4; Idx++)
			{
			if(m_BaseCnts[Idx].Cnts == 0 ||
				(m_BaseCnts[Idx].Cnts / (double)CntBases) < m_MinAlleleProp)
				{
				m_BaseCnts[Idx].Cnts = 0;
				m_BaseCnts[Idx].QScore = 0;
				continue;
				}

			PValue = 1.0 - Stats.Binomial(CntBases, m_BaseCnts[Idx].Cnts, m_LocalSeqErrRate);
			if(PValue > m_PValueThres)
				{
				m_BaseCnts[Idx].Cnts = 0;
				m_BaseCnts[Idx].QScore = 0;
				}
			else
				{
				m_BaseCnts[Idx].QScore = 101 - (int)((PValue * 100.0) / m_PValueThres);
				if(Idx != RefBase)
					bHaveSNP = true;
				}

			}
	if(!bHaveSNP)
		continue;

	// a special case: UCSC references the reference SARS-CoV-2 as being NC_O45512v2,not NC_O45512.2
	// so change NC_O45512.2 to be NC_O45512v2
	if (!stricmp(szChrom, "NC_045512.2"))
		strcpy(szChrom, "NC_045512v2");
	if(StartLoci < 0)
		{
		StartLoci = SNPLoci-50;
		if(StartLoci < 0)
			StartLoci = 0;
		Report(true,szChrom,StartLoci, SNPLoci+50);
		}
	m_RefBase = RefBase;
	Report(false, szChrom, SNPLoci,0);
	}
if (m_LineBuffOffs)
	{
	CUtility::SafeWrite(m_hOutpgSNPs, m_pszLineBuff, m_LineBuffOffs);
	m_LineBuffOffs = 0;
	}
#ifdef _WIN32
_commit(m_hOutpgSNPs);
#else
fsync(m_hOutpgSNPs);
#endif
close(m_hOutpgSNPs);
m_hOutpgSNPs = -1;
return(0);
}

// following function is experimental, enabling reporting in two different file formats
int
CSNPs2pgSNPs::Report(bool bHeader,		// if true then header line(s) to be generated, otherwise SNPs or alleles
					char *pszChrom,		// SNP is on this chrom
					int StartLoci,		// SNP is at this loci
					int EndLoci)		// if header for eRMFpgSNP then browser end loci

{
char Base;
int SumQScores;
int NumAlleles;
int Depth;

if(bHeader)
	{
	switch (m_ReportFormat) {
		case eRMFpgSNP:						// report in pgSNP format
			if(pszChrom == NULL || pszChrom[0] == '\0' || (StartLoci <= 0 && EndLoci <= 0) || EndLoci <= StartLoci)
				return(eBSFerrInternal);

			m_LineBuffOffs = sprintf(m_pszLineBuff, "track type=pgSnp visibility=3 db=%s name=\"%s\" description=\"%s\"\n", m_SpecAssemblyName, m_szTrackName, m_szDescription);
			m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "browser position %s:%d-%d", pszChrom, StartLoci, EndLoci);
			break;

		case eRMFvcf:						// report in VCF 4.1 format
			m_LineBuffOffs = sprintf(m_pszLineBuff, "##fileformat=VCFv4.1\n##source=ngskit4b%s\n##reference=%s\n##INFO=<ID=AF,Number=A,Type=Float,Description=\"Allele Frequency\">\n##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Read Depth\">\n",
										kit4bversion, m_szInSNPsFile);
			m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n");
			break;

		}
	CUtility::SafeWrite(m_hOutpgSNPs, m_pszLineBuff, m_LineBuffOffs);
	m_LineBuffOffs = 0;
	}
else
	{
	if ((m_LineBuffOffs + 500) >= m_AllocdLineBuff)
		{
		CUtility::SafeWrite(m_hOutpgSNPs, m_pszLineBuff, m_LineBuffOffs);
		m_LineBuffOffs = 0;
		}
	m_TotNumSNPs += 1;
	switch (m_ReportFormat) {
		case eRMFpgSNP:						// report in pgSNP format
			m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "\n%s\t%d\t%d\t", pszChrom, StartLoci, StartLoci + 1);
			NumAlleles = 0;
			for (int Idx = 0; Idx < 4; Idx++)
				{
				if (m_BaseCnts[Idx].Cnts > 0)
					{
					if (m_pszLineBuff[m_LineBuffOffs - 1] != '\t')
						m_pszLineBuff[m_LineBuffOffs++] = '/';
					switch (Idx) {
						case 0: Base = 'A'; break;
						case 1: Base = 'C'; break;
						case 2: Base = 'G'; break;
						case 3: Base = 'T'; break;
						}
					NumAlleles++;
					m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "%c", Base);
					}
				}
			m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "\t%d\t", NumAlleles);
			for (int Idx = 0; Idx < 4; Idx++)
				{
				if (m_BaseCnts[Idx].Cnts > 0)
					{
					if (m_pszLineBuff[m_LineBuffOffs - 1] != '\t')
						m_pszLineBuff[m_LineBuffOffs++] = ',';
					m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "%d", m_BaseCnts[Idx].Cnts);
					}
				}
			m_pszLineBuff[m_LineBuffOffs++] = '\t';
			for (int Idx = 0; Idx < 4; Idx++)
				{
				if (m_BaseCnts[Idx].Cnts > 0)
					{
					if (m_pszLineBuff[m_LineBuffOffs - 1] != '\t')
						m_pszLineBuff[m_LineBuffOffs++] = ',';
					m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "%d", m_BaseCnts[Idx].QScore);
					}
				}
			break;
		case eRMFvcf:						// report in VCF 4.1 format
			NumAlleles = 0;
			SumQScores = 0;
			Depth = 0;
			m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "%s\t%u\tSNP%d\t%c\t",pszChrom, StartLoci + 1, m_TotNumSNPs, CSeqTrans::MapBase2Ascii(m_RefBase));
			for (int Idx = 0; Idx < 4; Idx++)
				{
				Depth += m_BaseCnts[Idx].Cnts;
				if(Idx == m_RefBase)
					continue;
				if (m_BaseCnts[Idx].Cnts > 0)
					{
					if (m_pszLineBuff[m_LineBuffOffs - 1] != '\t')
						m_pszLineBuff[m_LineBuffOffs++] = ',';
					switch (Idx) {
						case 0: Base = 'A'; break;
						case 1: Base = 'C'; break;
						case 2: Base = 'G'; break;
						case 3: Base = 'T'; break;
						}
					NumAlleles++;
					m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "%c", Base);
					SumQScores += m_BaseCnts[Idx].QScore;
					}
				}
			SumQScores /= NumAlleles;
			m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "\t%d\tPASS\tAF=", SumQScores);
			for (int Idx = 0; Idx < 4; Idx++)
				{
				if (Idx == m_RefBase)
					continue;
				if (m_BaseCnts[Idx].Cnts > 0)
					{
					if (m_pszLineBuff[m_LineBuffOffs - 1] != '=')
						m_pszLineBuff[m_LineBuffOffs++] = ',';
					m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs], "%.4f", m_BaseCnts[Idx].Cnts/(double)Depth);
					}
				}
			m_LineBuffOffs += sprintf(&m_pszLineBuff[m_LineBuffOffs],";DP=%d\n", Depth);
			break;
		}
	}
return(eBSFSuccess);
}

int 
CSNPs2pgSNPs::Process(eModepgSNP Mode,				// processing mode
					int MinCoverage,				// must be at least this coverage at SNP site
					double MinAlleleProp,			// putative allele must be at least this proportion of total site read coverage
					double PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
					char *pszTrackName,				// track name
					char *pszAssemblyName,			// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
					char* pszExperimentDescr,		// describes experiment
					etSetOp SetOp,					// set operation on SetA and/or SetB				
					int NumInSetA,					// number of species/cultivars/isolates in SetA
					char** ppszSetA,				// names of those cspecies/cultivars/isolates which are in SetA
					int NumInSetB,					// number of species/cultivars/isolates in SetB
					char** ppszSetB,				// names of those cspecies/cultivars/isolates in SetB
					char* pszSNPFile,				// load SNP calls from this CSV file, can be either SNPs generated by kalign or snpmarkers
					char* pszOutFile)				// output SNPs to this UCSC Personal Genome SNP format file
{
int Rslt;
int Len;
Reset();
strcpy(m_szInSNPsFile, pszSNPFile);
strcpy(m_szOutpgSNPsFile, pszOutFile);
strcpy(m_SpecAssemblyName, pszAssemblyName);
strcpy(m_szDescription,pszExperimentDescr);
strcpy(m_szTrackName, pszTrackName);
m_PValueThres = PValueThres;
m_MinCoverage = MinCoverage;
m_MinAlleleProp = MinAlleleProp;
m_SetOp = SetOp;
m_NumInSetA = NumInSetA;
m_ppszSetA = ppszSetA;
m_NumInSetB = NumInSetB;
m_ppszSetB = ppszSetB;


if ((m_pszLineBuff = new char[cAllocLineBuffSize]) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Process: Unable to allocate memory for output line buffering -- %s", strerror(errno));
	return(eBSFerrMem);
	}
m_AllocdLineBuff = cAllocLineBuffSize;

// check file extension, if '.vcf' then generate output formated for vcf instead of the default pgSNP format
if((Len=(int)strlen(pszOutFile)) >= 5 && !stricmp(&pszOutFile[Len-4],".vcf"))
	m_ReportFormat = eRMFvcf;
else
	m_ReportFormat = eRMFpgSNP;

#ifdef _WIN32
if ((m_hOutpgSNPs = open(pszOutFile, (_O_RDWR | _O_BINARY | _O_SEQUENTIAL | _O_CREAT | _O_TRUNC), (_S_IREAD | _S_IWRITE))) == -1)
#else
if ((m_hOutpgSNPs = open(pszOutFile, O_RDWR | O_CREAT | O_TRUNC, S_IREAD | S_IWRITE)) == -1)
#endif
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Process: Unable to create/truncate output file - '%s' - %s", pszOutFile, strerror(errno));
	Reset();
	return(eBSFerrOpnFile);
	}

if ((m_pCSV = new CCSVFile) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Unable to instantiate CCSVfile");
	Reset();
	return(eBSFerrObj);
	}
if(Mode == eMpgSNPmarkers)
	m_pCSV->SetMaxFields(cCSVMaxFields);	// number of fields is unknown so need to allow for a worst case
if ((Rslt = m_pCSV->Open(pszSNPFile)) != eBSFSuccess)
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Unable to open file: %s", pszSNPFile);
	Reset();
	return(Rslt);
	}

switch(Mode) {
	case eMpgSNPKalign:
		Rslt = ProcessKalignSNPs();
		break;
	case eMpgSNPmarkers:
		Rslt = ProcessSnpmarkersSNPs();
		break;
	}
Reset();
return(Rslt);
}