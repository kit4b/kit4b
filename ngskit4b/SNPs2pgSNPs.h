/*
Portions of this toolkit are a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) which contain
significant source code changes enabling new functionality with consequent process parameterisation changes. These changes have resulted in
incompatibilty with 'BioKanga'.

Because of the potentential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019, 2020
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.
*/

#pragma once

const int cAllocLineBuffSize = 0x0ffffff;	// allocate line buffer for output which can hold this many chars

typedef enum TAG_eModepgSNP {
	eMpgSNPKalign = 0,						// input SNPs are those generated by kalign
	eMpgSNPmarkers							// input SNPs are those generated by snpmarkers
} eModepgSNP;

typedef enum TAG_eRMFsnp {			// report format
	eRMFpgSNP = 0,						// report in pgSNP format
	eRMFvcf								// report in VCF 4.1 format
} eRMFsnp;

typedef enum TAG_etSetOp {
	eSONone = 0,					// no Set operation
	eSOUnion,						// union of SetA and SetB
	eSOIntersect,					// intersect of SetA and SetB
	eSOCplUnion,					// complement of union SetA and SetB
	eSOCplIntersect,				// complement of intersect SetA and SetB
	eSOSubtract,					// SetA subtract SetB
	eSOPlaceHolder					// just a place holder to mark end of enumeration
} etSetOp;

const int cMaxSetMembers = cMaxCultivars - 1;			// up to a maximum of this many species/cultivars/isolates can be named in Set
											// if no cultivars marked for retention then all cultivars will be processed
const int cAlignNumSNPfields = 23;			// if generated by 'kit4b align' then there will be this many CSV fields
const int cSNPMarkerNumFields = 4 + 9;		// if generated by 'kit4b snpmarkers' then there will be a minimum of this number of CSVfields

#pragma pack(1)
typedef struct TAG_sCultivar {
	char szName[cMaxDatasetSpeciesChrom+1];		// name of this cultivar
	etSeqBase CalledBase;						// base called as being the major allele for this cultivar
	int Score;									// score
	int TotalBaseCnts;							// total number of base counts
	int BaseCnts[5];							// counts for each base
	uint8_t flgSNPInferenced:1;					// 1 if allele was inferenced 
	uint8_t flgInSetA:1;						// 1 if this cultivar is a member of SetA
	uint8_t flgInSetB:1;						// 1 if this cultivar is a member of SetB
} tsCultivar;

typedef struct TAG_sBaseCnts {
	etSeqBase Base;     // counts are for this base
	int Cnts;			// number of counts for this base
	int QScore;			// this bases pgSNP quality score
} tsBaseCnts;
#pragma pack()

class CSNPs2pgSNPs
{
	eRMFsnp m_ReportFormat;						// processing results are to be reported in this file format
	int m_MinCoverage;							// must be at least this read coverage at SNP site
	double m_MinAlleleProp;						// putative allele must be at least this proportion of total site read coverage
	double m_PValueThres;						// acceptance PValue
	char m_szInSNPsFile[_MAX_PATH];				// processing this input kalign SNP calls or snpmarker CSV file
	char m_szOutpgSNPsFile[_MAX_PATH];			// output in UCSC Personal Genome SNP format to this file
	char m_TargAssemblyName[cMaxDatasetSpeciesChrom+1]; // alignments were against this targeted assembly
	char m_SpecAssemblyName[cMaxDatasetSpeciesChrom + 1]; // in generated pgSNP file use this as the assembly name
	char m_szDescription[_MAX_PATH];
	char m_szTrackName[100];
	int m_NumCultivars;							// number of cultivars being processed
	tsCultivar m_Cultivars[cMaxCultivars];		// cultivar specific metadata
	CCSVFile *m_pCSV;							// used to load SNP calls
	int m_hOutpgSNPs;							// output SNP format file handle
	
	int m_TotNumSNPs;							// number of polymorphic or allelic sites called as SNPs
	double m_LocalSeqErrRate;					// estimated localised error rate around the putative SNP site
	etSeqBase m_RefBase;						// reference base
	tsBaseCnts m_BaseCnts[5];					// base counts which are to be reported

	etSetOp m_SetOp;							// set operation on SetA and/or SetB				
	int m_NumInSetA;							// number of species/cultivars/isolates in SetA
	char** m_ppszSetA;							// names of those cspecies/cultivars/isolates which are in SetA
	int m_NumInSetB;							// number of species/cultivars/isolates in SetB
	char** m_ppszSetB;							// names of those cspecies/cultivars/isolates in SetB


	int m_LineBuffOffs;							// offset in m_pszLineBuff at which to next write buffered lines
	int m_AllocdLineBuff;						// 	m_pszLineBuff allocated to a max of this many chars			
	char *m_pszLineBuff;						// line buffer memory to hold buffered output

	int ProcessKalignSNPs(void);				// output kalign SNPs to a UCSC Personal Genome SNP format file

	int ProcessSnpmarkersSNPs(void);			// output snpmarkers generated SNP calls to a UCSC Personal Genome SNP format file

public:
	CSNPs2pgSNPs(void);
	~CSNPs2pgSNPs(void);

	void Reset(void);							// re-initialise  

	int Report(bool bHeader,		// if true then header line(s) to be generated, otherwise SNPs or alleles
				char* pszChrom,					// chrom, and initial browser positioning if format is eRMFpgSNP
				int StartLoci,					// if header for eRMFpgSNP then browser start loci, otherwise the SNP loci
				int EndLoci);				// if header for eRMFpgSNP then browser end loci

	int Process(eModepgSNP Mode,			// processing mode
			int MinCoverage,				// must be at least this coverage at SNP site
			double MinAlleleProp,			// putative allele must be at least this proportion of total site read coverage
			double PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
			char* pszTrackName,				// track name
			char* pszAssemblyName,			// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
			char* pszExperimentDescr,		// describes experiment
			etSetOp SetOp,					// set operation on SetA and/or SetB				
			int NumInSetA,					// number of species/cultivars/isolates in SetA
			char** ppszSetA,				// names of those cspecies/cultivars/isolates which are in SetA
			int NumInSetB,					// number of species/cultivars/isolates in SetB
			char** ppszSetB,				// names of those cspecies/cultivars/isolates in SetB
			char* pszSNPFile,				// load SNP calls from this CSV file, can be either SNPs generated by kalign or snpmarkers
			char* pszOutFile);				// output SNPs to this UCSC Personal Genome SNP format file
};

