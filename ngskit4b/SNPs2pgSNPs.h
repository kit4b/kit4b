/*
Portions of this toolkit are a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) which contain
significant source code changes enabling new functionality with consequent process parameterisation changes. These changes have resulted in
incompatibility with 'BioKanga'.

Because of the potential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019, 2020
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.
*/

#pragma once


const int cAllocLineBuffSize = 0x0ffffff;	// allocate line buffer for output which can hold this many chars
const int cMaxSSetMembers = cMaxCultivars;	// up to a maximum of this many species/cultivars/isolates can be named in Set
											// if no cultivars marked for retention then all cultivars will be processed
const int cAlignNumSSNPfields = 23;			// if generated by 'kit4b kalign' then there will be this many CSV fields if simple SNP
const int cAlignNumDiSNPfields = 37;			// if generated by 'kit4b kalign' then there will be this many CSV fields if DiSNP localised haplotype
const int cAlignNumTriSNPfields = 92;			// if generated by 'kit4b kalign' then there will be this many CSV fields if TriSNP localised haplotype

const int cAlignNumSSNPXfields = 23 + (3 * 65);	// if generated by 'kit4b kalign' for all 3 read counts frame shifts (3*4^3) + fixed reference frame shifts (3*3) then there will be this many CSV fields
const int cSSNPMarkerNumFields = 4 + 9;		// if generated by 'kit4b snpmarkers' then there will be this number of CSVfields

const int cMaxGapBetweenSNPS = 0x0ffffff;		// largest expected gap between successive SNPs
const int cMaxIndividualSNPS = 0x0ffffff;		// allow any individual cultivar to have this many SNPs
const int cMaxSharedSNPS = cMaxIndividualSNPS;	// individual cultivars could be sharing their SNPs with at least one other cultivar

const double cDfltDiracThres = 0.80;			// characterise SNP loci as being dirac if non-ref allele counts are at least this proportion of total

const int cAllocGeneFeatures = 100;			// allocating to hold at most this many gene features containing single exons (currently analysis is targeting SARS-CoV-2)

const int cAllocNumIsolateFeatSNPs = 25000;	// initially allocate for this number of isolate feature SNPs

const int cMaxChromNames = 20000;			// can only handle a max of this many chromosome names - memory is statically allocated
const int cMaxReadsetNames = 20000;			// can only handle a max of this many readset names - memory is statically allocated

typedef enum TAG_eModepgSSNP {
	eMpgSSNPKalign = 0,						// input SNPs are those generated by kalign
	eMpgSSNPmarkers							// input SNPs are those generated by snpmarkers
} eModepgSSNP;

typedef enum TAG_eRMFsnp {			// report format
	eRMFpgSNP = 0,					// report in pgSNP format
	eRMFvcf,						// report in VCF 4.1 format
	eRMFcsv							// reporting in CSV format
} eRMFsnp;

typedef enum TAG_etSSetOp {
	eSSONone = 0,					// no Set operation
	eSSOUnion,						// union of SetA and SetB
	eSSOIntersect,					// intersect of SetA and SetB
	eSSOCplUnion,					// complement of union SetA and SetB
	eSSOCplIntersect,				// complement of intersect SetA and SetB
	eSSOSubtract,					// SetA subtract SetB
	eSSOPlaceHolder					// just a place holder to mark end of enumeration
} etSSetOp;


#pragma pack(1)
typedef struct TAG_sSCultivar {
	char szName[cMaxDatasetSpeciesChrom + 1];		// name of this cultivar
	uint32_t NumSitesInferenced;					// number of SNP sites originally inferenced
	uint32_t NumSitesCalled;					// number of SNP sites originally called as SNP loci
	uint32_t NumSitesAccepted;					// number of SNP sites accepted as being SNPs after set/coverage/PValue filtering

	etSeqBase CalledBase;						// base called as being the major allele for this cultivar
	double Score;								// score
	uint32_t TotBaseCnts;						// total number of base counts
	uint32_t TotMismatches;						// total number of non-reference bases
	uint32_t BaseCnts[5];						// counts for each base
	uint8_t flgSNPInferenced : 1;				// 1 if allele was inferenced 
	uint8_t flgInSetA : 1;						// 1 if this cultivar is a member of SetA
	uint8_t flgInSetB : 1;						// 1 if this cultivar is a member of SetB
} tsSCultivar;

typedef struct TAG_sSBaseCnts {
	etSeqBase Base;     // counts are for this base
	uint32_t Cnts;			// number of counts for this base
	double QScore;			// this bases pgSNP quality score
} tsSBaseCnts;

typedef struct TAG_sSNPSSite {
	bool bSNPPlaceholder;			// true if this site is a place holder only and not to be output as a pgSNP or VCF SNP site
	uint8_t ClassifySite;			// site classified as - 0: unclassified, 1: SNP is minor allele, 1: SNP is major allele, 2: SNP is divac 
	bool bInFeature;				// set true if this SNP site is within a CDS feature
	uint32_t FeatureIdx;			// feature index
	uint32_t SNPId;					// globally unique identifier, includes SNP loci placeholders as well as reported SNPs
	char szSeqReadSet[cMaxDatasetSpeciesChrom + 1];	// identifies sequenced readset name
	uint32_t ReadsetID;				// identifies sequenced readset 
	char szChrom[cMaxDatasetSpeciesChrom + 1]; // SNP is on this chromosome
	int32_t ChromID;				// identifies chromosome
	uint32_t ReadsetSiteId;			// site identifier readset unique
	uint32_t SNPLoci;				// SNP loci
	etSeqBase RefBase;				// reference base
	uint32_t TotBaseCnts;			// covering bases
	uint32_t TotMismatches;			// number of bases not matching the reference base
	double LocalSeqErrRate;			// estimated localised error rate around the putative SNP site
	tsSBaseCnts BaseCnts[5];		// base counts which are to be reported
	uint32_t OrigBaseCnts[5];		// original base counts without any filtering
	uint32_t DiracCnts[5];			// instance counts of dirac alleles at this loci
} tsSNPSSite;

typedef struct TAG_sSiteFeatCnts	// these feature counts are specific to a current readset site loci
	{
	uint32_t IsDirac;			// true if major allele is dirac 
	uint32_t TotSynonymous;		// inframe synonymous codons
	uint32_t TotNonSynonymous;	// inframe non-synonymous codons
	uint32_t TotWobble;			// inframe wobble or slow codons
	uint32_t NumPosBiasedCodons;	// all synonymous codons which were biased towards human highest frequency codons
	uint32_t NumNegBiasedCodons;	// all synonymous codons which were biased towards human lowest frequency codons
	uint32_t RefSynGroup;			// reference sequence amino acid inframe at site loci
	uint32_t ToAminoAcidChanges[21]; // counts of amino acid changes from reference (21 allows for changes into stop codons which have been observed)
	} tsSiteFeatCnts;

typedef struct TAG_sSummaryFeatCnts
	{
	char szChrom[cMaxDatasetSpeciesChrom + 1];  // feature is on this chromosome
	char szFeatName[cMaxDatasetSpeciesChrom+1];	// feature identifier		
	uint32_t FeatStart;			// feature starts at this genomic loci inclusive
	uint32_t FeatEnd;			// feature ends at this genomic loci inclusive

	uint32_t TotSNPs;			// total number of SNPs located in this feature
	uint32_t DiracCnts[5];		// instance counts of dirac alleles located in this feature
	uint32_t TotSynonymous;		// total synonymous codons
	uint32_t TotNonSynonymous;	// total non-synonymous codons
	uint32_t TotWobble;			// total wobble or slow codons

	uint32_t TotExclSynonymous;		// total exclusively only synonymous codons
	uint32_t TotExclNonSynonymous;	// total exclusively only non-synonymous codons
	uint32_t TotExclWobble;			// total exclusively only wobble or slow codons

	uint32_t NumSiteSynonCodons;	// sum total of all synonymous codons (combinations of alleles may result multiple different codons at a site)
	uint32_t NumPosBiasedCodons;	// sum total of all synonymous codons which were biased towards human highest frequency codons
	uint32_t NumNegBiasedCodons;	// sum total of all synonymous codons which were biased towards human lowest frequency codons
	uint32_t FromAminoAcidChanges[21]; // number of times the ref amino acid was changed
	uint32_t ToAminoAcidChanges[21][21]; // recording counts of amino acid changes from reference (21 allows for changes in stop codons which have been observed)

	tsSiteFeatCnts SiteFeatCnts;	// feature counts at each readset SNP loci
	} tsSummaryFeatCnts;

typedef struct TAG_sIsolateFeatSNPs // one isolate contains many instances, one per SNP called in that isolate
	{
	uint32_t Shared;			// number of isolates sharing this SNP loci
	tsSNPSSite SNPSSite;		// Isolate SNP loci
	tsSiteFeatCnts SiteFeatCnts; // feature specific counts at that site
	} tsIsolateFeatSNPs;


#pragma pack()

class CSNPs2pgSNPs
{
	bool m_bAllowInferenced;					// true if both original kalign SNP calls and snpmarker inferenced SNP calls to be used, default is for kalign SNPs only
	uint32_t m_MinCoverage;						// must be at least this read coverage at SNP site
	double m_MinAlleleProp;						// putative allele must be at least this proportion of total site read coverage
	double m_PValueThres;						// acceptance PValue
	eRMFsnp m_ReportFormat;						// reporting in this file format

	char m_szGFFFile[_MAX_PATH];				// general feature format file - identifies start/end loci of features in assembly, i.e. transcripts etc.
	char m_szInSNPsFile[_MAX_PATH];				// processing this input kalign SNP calls or snpmarker CSV file
	uint32_t m_ReadsetID;						// readset identifier
	char m_ReadsetIdentifier[_MAX_PATH];		// readset identifier - currently just input SNP filename sans directory and only used when processing kalign generated SNP CSV formated files
	char m_szOutSiteDistFile[_MAX_PATH];		// SNP site distributions written to this file	
	char m_TargAssemblyName[cMaxDatasetSpeciesChrom + 1]; // alignments were against this targeted assembly
	char m_SpecAssemblyName[cMaxDatasetSpeciesChrom + 1]; // in generated pgSNP file use this as the assembly name
	char m_szDescription[_MAX_PATH];
	char m_szTrackName[100];
	uint32_t m_NumCultivars;							// number of cultivars being processed
	uint32_t m_NumUniqueSiteLoci;				// number of unique site loci
	tsSCultivar m_Cultivars[cMaxCultivars];		// cultivar specific metadata
	CCSVFile* m_pCSV;							// used to load SNP calls

	CGFFFile* m_pGFFFile;						// class for processing optional general feature format file
	int m_NumFeatures;							// number of features in m_pFeatures
	int m_AllocFeatures;						// m_pFeatures allocated to hold at most this number of features
	tsSummaryFeatCnts *m_pFeatures;				// currently just holding gene features


	bool m_bRptHdr;								// set true when header is required for pgSNP or VCF output, reset to false when header has been generated
	int m_OutBuffOffs;							// offset in m_pszLineBuff at which to next write buffered lines
	int m_AllocdOutBuff;						// 	m_pszLineBuff allocated to a max of this many chars			
	char* m_pszOutBuff;							// line buffer memory to hold buffered output ready to write to m_hOutFile
	char m_szOutFilePrefix[_MAX_PATH];			// prefix filename to which extension (supplied with CreateOutFile()) is to be applied
	char m_szOutFile[_MAX_PATH];				// currently named output file with extension applied
	int m_hOutFile;								// file handle for reuse - used when output is atomic for a given output format. File is opened, written, and the closed ready for reuse
	int m_hOutSiteDist;							// output SNP site distributions file handle

	double m_LocalSeqErrRate;					// estimated localised error rate around the putative SNP site

	double m_DiracThres;						// characterise SNP site as being Dirac if at least one non-ref allele is more than this proportion of total counts at that loci

	etSSetOp m_SetOp;							// set operation on SetA and/or SetB				
	int m_NumInSetA;							// number of species/cultivars/isolates in SetA
	char** m_ppszSetA;							// names of those cspecies/cultivars/isolates which are in SetA
	int m_NumInSetB;							// number of species/cultivars/isolates in SetB
	char** m_ppszSetB;							// names of those cspecies/cultivars/isolates in SetB


	int m_NumChromNames;						// number of chromosome names currently in m_szChromNames
	int m_NxtszChromIdx;						// current concatenated (names separated by '\0') of all chromosome names in m_szChromNames 
	char m_szChromNames[cMaxChromNames * (cMaxDatasetSpeciesChrom/2)];	// used to hold concatenated chromosome names, each separated by '\0'
	uint32_t m_szChromIdx[cMaxChromNames];		// array of indexes into m_szChromNames giving the starts of each chromosome name

	int m_NumReadsetNames;						// number of readset names currently in m_szReadsetNames
	int m_NxtszReadsetIdx;						// current concatenated (names separated by '\0') of all readset names in m_szReadsetNames 
	char m_szReadsetNames[cMaxReadsetNames * (cMaxDatasetSpeciesChrom / 2)];	// used to hold concatenated readset names, each separated by '\0'
	uint32_t m_szReadsetIdx[cMaxReadsetNames];		// array of indexes into m_szReadsetNames giving the starts of each readset name


	uint32_t m_SNPID;							// identifies each accepted SNP or place holder SNP loci 
	uint32_t m_NumSNPs;							// number of SNP sites accepted 
	uint32_t m_AllocdSNPSites;					// m_pSNPSites allocated to hold at most this many SNP sites
	tsSNPSSite* m_pSNPSites;					// allocated to hold accepted SNP sites


	uint32_t m_IsolateFeatSNPs;					// number of IsolateFeatSNPs accepted 
	uint32_t m_AllocdIsolateFeatSNPs;			// m_pIsolateFeatSNPs allocated to hold at most this many SNP sites reallocated as may be required
	size_t m_AllocdIsolateFeatSNPsMem;			// memory allocated
	tsIsolateFeatSNPs *m_pIsolateFeatSNPs;		// allocated to hold all isolate feature SNPs

	uint32_t m_MatrixCols;						// number of cols (loci) in matrix
	uint32_t m_MatrixRows;						// number of rows (isolates) in matrix
	uint32_t *m_pMatrix;							// matrix containing [isolate][loci] absence/presence indicators


	uint32_t m_SimilaritiesMatrixCols;			// number of cols (readsets) in matrix
	uint32_t m_SimilaritiesMatrixRows;			// number of rows (readsets) in matrix
	double* m_pSimilaritiesMatrix;				// matrix containing simularities score inter-readsets


	int m_SiteDistOffs;							// offset in m_pszSNPLineBuff at which to next write SNP distribution lines
	int m_AllocdSiteDistBuff;					// m_pszSNPLineBuff allocated to a max of this many chars			
	char* m_pszSiteDistBuff;					// line buffer memory to hold SNP sites distribution buffered output

	uint32_t m_MaxSNPgap;						// maximal sized number of bases between successive SNPs encountered
												// Note: bases between 5' to 1st SNP and last SNP to 3' end not counted
	uint32_t* m_pGapCntDist;					// gaps between SNPs distribution

	uint32_t m_MaxSharedSNPs;					// maximal number of cultivars/isolates/whatever having same common shared snip 
	uint32_t* m_pSharedSNPsDist;				// distribution of SNPs shared between cultivars/isolates/whatever

	uint32_t m_MaxIndividualSNPs;				// maximal number of SNPs within individual cultivars/isolates/whatever
	uint32_t* m_pIndividualSNPsDist;			// distribution of numbers of SNPs within individual cultivars/isolates/whatever

	void	CloseOutFile(void);					// closes output file if currently opened

	int WriteOutFile(bool bForce = false);		// true if write is forced, otherwise will only write m_pszOutBuff to m_hOutFile if <= 32000 buffering capacity remaining

	int	CreateOutFile(char* pszExtn);			// closes any already opened m_hOutFile, then creates/truncates an m_hOutFile file having specified extension

	int ProcessKalignSNPs(void);				// output kalign SNPs to a UCSC Personal Genome SNP format file

	int ProcessSnpmarkersSNPs(void);			// output snpmarkers generated SNP calls to a UCSC Personal Genome SNP format file


	uint32_t	GenNumUniqueSiteLoci(void);		// returns number of unique sites

	int	IdentifySharedSiteLociDist(char* pszFileExtn);		// Experimental: for each isolate determine the SNP site loci sharing distributions with other isolates
												// Currently just using brute force!

	int	LoadLociIsolateMatrix(void);			// generate a matrix (rows - isolates, columns - loci) with cells absence/presence of sites at that loci in that isolate

	int ReportLociIsolateMatrix(char* pszFileExtn);  // report loci vs isolate matrix using this file extension, will generate loci isolate matrix if not already generated
	
	int LoadSimilaritiesMatrix(void);			// generate a matrix (readsets x readsets) with cells containing scores
	
	int ReportSimilaritiesMatrix(char* pszFileExtn); // report readset vs readset  similarities matrix using this file extension, will generate readset vs readset matrix if not already generated

	int		// returned chrom identifier, < 1 if unable to accept this chromosome name
		 AddChrom(char* pszChrom); // associate unique identifier with this chromosome name

	char*	// returned ptr to chromosome name 
		LocateChrom(int ChromID);	// chromosome name identifier

	int		// returned readset identifier, < 1 if unable to accept this readset name
		AddReadset(char* pszReadset); // associate unique identifier with this readset name

	char* // returned ptr to readset name 
		LocateReadset(int ReadsetID); // readset name identifier

	CStats m_Stats;								// basic statistics

	int32_t m_SortOrder;						// last sort was 0: unsorted, 1: SortSNPChromLociReadset, 2: SortSNPReadsetChromLoci
// Sort SNP loci by ascending chrom.loci.readset
	static int SortSNPChromLociReadset(const void* arg1, const void* arg2);
// Sort SNP loci by ascending readset.chrom.loci
	static int SortSNPReadsetChromLoci(const void* arg1, const void* arg2);


public:
	CSNPs2pgSNPs(void);
	~CSNPs2pgSNPs(void);

	void Reset(void);							// re-initialise  

	int Report(bool bHeader,					// if true then header line(s) to be generated, otherwise SNPs or alleles
			   tsSNPSSite* pSNPSite);			// SNP or allele details

	int
		ReportFeatSNPcnts(bool bHeader,			// header required
										int NumFeatures,		// number of features
										tsSummaryFeatCnts* m_pFeatures); // array of feature SNP counts and codons

	int Process(eModepgSSNP Mode,			// processing mode
				bool bAllowInferenced,			// true if both original kalign SNP calls and snpmarker inferenced SNP calls to be used, default is for kalign SNPs only
				double LocalSeqErrRate,			// local sequencing error rate in a 100bp window centered around the putative SNP site
				int MinCoverage,				// must be at least this coverage at SNP site
				double MinAlleleProp,			// putative allele must be at least this proportion of total site read coverage
				double PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
				char* pszTrackName,				// track name
				char* pszAssemblyName,			// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
				char* pszExperimentDescr,		// describes experiment
				etSSetOp SetOp,					// set operation on SetA and/or SetB				
				int NumInSetA,					// number of species/cultivars/isolates in SetA
				char** ppszSetA,				// names of those cspecies/cultivars/isolates which are in SetA
				int NumInSetB,					// number of species/cultivars/isolates in SetB
				char** ppszSetB,				// names of those cspecies/cultivars/isolates in SetB
				char* pszGFFFile,				// general feature format file - identifies start/end loci of features in assembly, i.e. transcripts etc.
				char* pszSNPFile,				// load SNP calls from this CSV file, can be either SNPs generated by kalign or snpmarkers
				char* pszOutDir);				// output SNP distribution statistics to this directory
};
