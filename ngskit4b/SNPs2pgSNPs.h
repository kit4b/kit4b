/*
Portions of this toolkit are a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) which contain
significant source code changes enabling new functionality with consequent process parameterisation changes. These changes have resulted in
incompatibility with 'BioKanga'.

Because of the potential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019, 2020
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.
*/

#pragma once


const int cAllocLineBuffSize = 0x0ffffff;	// allocate line buffer for output which can hold this many chars
const int cMaxSSetMembers = cMaxCultivars;	// up to a maximum of this many species/cultivars/isolates can be named in Set
											// if no cultivars marked for retention then all cultivars will be processed
const int cAlignNumSSNPfields = 23;			// if generated by 'kit4b kalign' then there will be this many CSV fields
const int cAlignNumSSNPXfields = 23 + 3 + (3 * (4 * 4 * 4));	// if generated by 'kit4b kalign' for all 3 read counts frame shifts (3*4^3) + fixed reference frame shifts (3*3) then there will be this many CSV fields
const int cSSNPMarkerNumFields = 4 + 9;		// if generated by 'kit4b snpmarkers' then there will be a minimum of this number of CSVfields

const int cMaxGapBetweenSNPS = 0x0ffffff;		// largest expected gap between successive SNPs
const int cMaxIndividualSNPS = 0x0ffffff;		// allow any individual cultivar to have this many SNPs
const int cMaxSharedSNPS = cMaxIndividualSNPS;	// individual cultivars could be sharing their SNPs with at least one other cultivar

const double cDfltDiracThres = 0.80;			// characterise SNP loci as being dirac if non-ref allele counts are at least this proportion of total

const int cAllocGeneFeatures = 100;			// allocating to hold at most this many gene features containing single exons (currently analysis is targeting SARS-CoV-2)

typedef enum TAG_eModepgSSNP {
	eMpgSSNPKalign = 0,						// input SNPs are those generated by kalign
	eMpgSSNPmarkers							// input SNPs are those generated by snpmarkers
} eModepgSSNP;

typedef enum TAG_eRMFsnp {			// report format
	eRMFpgSNP = 0,					// report in pgSNP format
	eRMFvcf							// report in VCF 4.1 format
} eRMFsnp;

typedef enum TAG_etSSetOp {
	eSSONone = 0,					// no Set operation
	eSSOUnion,						// union of SetA and SetB
	eSSOIntersect,					// intersect of SetA and SetB
	eSSOCplUnion,					// complement of union SetA and SetB
	eSSOCplIntersect,				// complement of intersect SetA and SetB
	eSSOSubtract,					// SetA subtract SetB
	eSSOPlaceHolder					// just a place holder to mark end of enumeration
} etSSetOp;


#pragma pack(1)
typedef struct TAG_sSCultivar {
	char szName[cMaxDatasetSpeciesChrom + 1];		// name of this cultivar
	uint32_t NumSitesInferenced;					// number of SNP sites originally inferenced
	uint32_t NumSitesCalled;						// number of SNP sites originally called as SNP loci
	uint32_t NumSitesAccepted;						// number of SNP sites accepted as being SNPs after set/coverage/PValue filtering

	etSeqBase CalledBase;						// base called as being the major allele for this cultivar
	double Score;								// score
	uint32_t TotBaseCnts;						// total number of base counts
	uint32_t TotMismatches;					// total number of non-reference bases
	uint32_t BaseCnts[5];						// counts for each base
	uint8_t flgSNPInferenced : 1;					// 1 if allele was inferenced 
	uint8_t flgInSetA : 1;						// 1 if this cultivar is a member of SetA
	uint8_t flgInSetB : 1;						// 1 if this cultivar is a member of SetB
} tsSCultivar;

typedef struct TAG_sSBaseCnts {
	etSeqBase Base;     // counts are for this base
	uint32_t Cnts;			// number of counts for this base
	double QScore;			// this bases pgSNP quality score
} tsSBaseCnts;

typedef struct TAG_sSNPSSite {
	bool bSNPPlaceholder;			// true if this site is a place holder only and not to be output as a pgSNP or VCF SNP site
	uint32_t SNPId;					// globally unique identifier, includes SNP loci placeholders as well as reported SNPs
	char szChrom[cMaxDatasetSpeciesChrom + 1]; // SNP is on this chromosome
	uint32_t SNPLoci;				// SNP loci
	etSeqBase RefBase;				// reference base
	uint32_t TotBaseCnts;			// covering bases
	uint32_t TotMismatches;			// number of bases not matching the reference base
	double LocalSeqErrRate;			// estimated localised error rate around the putative SNP site
	tsSBaseCnts BaseCnts[5];		// base counts which are to be reported
	uint32_t DiracCnts[5];			// instance counts of dirac alleles at this loci
} tsSNPSSite;

typedef struct TAG_sSummaryFeatCnts
	{
	char szChrom[cMaxDatasetSpeciesChrom + 1];  // feature is on this chromosome
	char szFeatName[cMaxDatasetSpeciesChrom+1];	// feature identifier		
	uint32_t FeatStart;			// feature starts at this genomic loci inclusive
	uint32_t FeatEnd;			// feature ends at this genomic loci inclusive
	uint32_t TotSNPs;			// total number of SNPs located in this feature
	uint32_t DiracCnts[5];		// instance counts of dirac alleles located in this feature
	uint32_t TotSynonymous;		// total synonymous codons
	uint32_t TotNonSynonymous;	// total non-synonymous codons
	uint32_t TotWobble;			// total wobble or slow codons

	uint32_t TotExclSynonymous;		// total exclusively only synonymous codons
	uint32_t TotExclNonSynonymous;	// total exclusively only non-synonymous codons
	uint32_t TotExclWobble;			// total exclusively only wobble or slow codons 

	} tsSummaryFeatCnts;
#pragma pack()

class CSNPs2pgSNPs
{
	bool m_bAllowInferenced;					// true if both original kalign SNP calls and snpmarker inferenced SNP calls to be used, default is for kalign SNPs only
	uint32_t m_MinCoverage;						// must be at least this read coverage at SNP site
	double m_MinAlleleProp;						// putative allele must be at least this proportion of total site read coverage
	double m_PValueThres;						// acceptance PValue
	eRMFsnp m_ReportFormat;						// reporting in this file format

	char m_szGFFFile[_MAX_PATH];				// general feature format file - identifies start/end loci of features in assembly, i.e. transcripts etc.
	char m_szInSNPsFile[_MAX_PATH];				// processing this input kalign SNP calls or snpmarker CSV file
	char m_szOutpgSNPsFile[_MAX_PATH];			// write SNPs to this file
	char m_szOutSiteDistFile[_MAX_PATH];		// SNP site distributions written to this file	
	char m_szOutFeatures[_MAX_PATH];			// SNP feature distributions written to this file
	char m_TargAssemblyName[cMaxDatasetSpeciesChrom + 1]; // alignments were against this targeted assembly
	char m_SpecAssemblyName[cMaxDatasetSpeciesChrom + 1]; // in generated pgSNP file use this as the assembly name
	char m_szDescription[_MAX_PATH];
	char m_szTrackName[100];
	int m_NumCultivars;							// number of cultivars being processed
	tsSCultivar m_Cultivars[cMaxCultivars];		// cultivar specific metadata
	CCSVFile* m_pCSV;							// used to load SNP calls

	CGFFFile* m_pGFFFile;						// class for processing optional general feature format file
	int m_NumFeatures;							// number of features in m_pFeatures
	int m_AllocFeatures;						// m_pFeatures allocated to hold at most this number of features
	tsSummaryFeatCnts *m_pFeatures;				// currently just holding gene features

	int m_hOutpgSNPs;							// output SNP format file handle
	int m_hOutSiteDist;							// output SNP site distributions file handle
	int m_hOutFeatures;							// output SNP feature distributions file handle

	double m_LocalSeqErrRate;					// estimated localised error rate around the putative SNP site

	double m_DiracThres;						// characterise SNP site as being Dirac if at least one non-ref allele is more than this proportion of total counts at that loci

	etSSetOp m_SetOp;							// set operation on SetA and/or SetB				
	int m_NumInSetA;							// number of species/cultivars/isolates in SetA
	char** m_ppszSetA;							// names of those cspecies/cultivars/isolates which are in SetA
	int m_NumInSetB;							// number of species/cultivars/isolates in SetB
	char** m_ppszSetB;							// names of those cspecies/cultivars/isolates in SetB

	uint32_t m_SNPID;							// identifies each accepted SNP or place holder SNP loci 
	uint32_t m_NumSNPs;							// number of SNP sites accepted 
	uint32_t m_AllocdSNPSites;					// m_pSNPSites allocated to hold at most this many SNP sites
	tsSNPSSite* m_pSNPSites;					// allocated to hold accepted SNP sites

	bool m_bRptHdr;								// set true when header is required for pgSNP or VCF output, reset to false when header has been generated
	int m_LineBuffOffs;							// offset in m_pszLineBuff at which to next write buffered lines
	int m_AllocdLineBuff;						// 	m_pszLineBuff allocated to a max of this many chars			
	char* m_pszLineBuff;						// line buffer memory to hold buffered output

	int m_SiteDistOffs;							// offset in m_pszSNPLineBuff at which to next write SNP distribution lines
	int m_AllocdSiteDistBuff;					// m_pszSNPLineBuff allocated to a max of this many chars			
	char* m_pszSiteDistBuff;					// line buffer memory to hold SNP sites distribution buffered output

	uint32_t m_MaxSNPgap;						// maximal sized number of bases between successive SNPs encountered
												// Note: bases between 5' to 1st SNP and last SNP to 3' end not counted
	uint32_t* m_pGapCntDist;					// gaps between SNPs distribution

	uint32_t m_MaxSharedSNPs;					// maximal number of cultivars/isolates/whatever having same common shared snip 
	uint32_t* m_pSharedSNPsDist;				// distribution of SNPs shared between cultivars/isolates/whatever

	uint32_t m_MaxIndividualSNPs;				// maximal number of SNPs within individual cultivars/isolates/whatever
	uint32_t* m_pIndividualSNPsDist;			// distribution of numbers of SNPs within individual cultivars/isolates/whatever

	int ProcessKalignSNPs(void);				// output kalign SNPs to a UCSC Personal Genome SNP format file

	int ProcessSnpmarkersSNPs(void);			// output snpmarkers generated SNP calls to a UCSC Personal Genome SNP format file

public:
	CSNPs2pgSNPs(void);
	~CSNPs2pgSNPs(void);

	void Reset(void);							// re-initialise  

	int Report(bool bHeader,					// if true then header line(s) to be generated, otherwise SNPs or alleles
			   tsSNPSSite* pSNPSite);			// SNP or allele details

	int
		ReportFeatSNPcnts(bool bHeader,			// header required
										int NumFeatures,		// number of features
										tsSummaryFeatCnts* m_pFeatures); // array of feature SNP counts and codons

	int Process(eModepgSSNP Mode,			// processing mode
				bool bAllowInferenced,			// true if both original kalign SNP calls and snpmarker inferenced SNP calls to be used, default is for kalign SNPs only
				double LocalSeqErrRate,			// local sequencing error rate in a 100bp window centered around the putative SNP site
				int MinCoverage,				// must be at least this coverage at SNP site
				double MinAlleleProp,			// putative allele must be at least this proportion of total site read coverage
				double PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
				char* pszTrackName,				// track name
				char* pszAssemblyName,			// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
				char* pszExperimentDescr,		// describes experiment
				etSSetOp SetOp,					// set operation on SetA and/or SetB				
				int NumInSetA,					// number of species/cultivars/isolates in SetA
				char** ppszSetA,				// names of those cspecies/cultivars/isolates which are in SetA
				int NumInSetB,					// number of species/cultivars/isolates in SetB
				char** ppszSetB,				// names of those cspecies/cultivars/isolates in SetB
				char* pszGFFFile,				// general feature format file - identifies start/end loci of features in assembly, i.e. transcripts etc.
				char* pszSNPFile,				// load SNP calls from this CSV file, can be either SNPs generated by kalign or snpmarkers
				char* pszOutDir);				// output SNP distribution statistics to this directory
};
