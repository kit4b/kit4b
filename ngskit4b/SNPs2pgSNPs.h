/*
Portions of this toolkit are a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) which contain
significant source code changes enabling new functionality with consequent process parameterisation changes. These changes have resulted in
incompatibility with 'BioKanga'.

Because of the potential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019, 2020
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.
*/

#pragma once

const int cAllocLineBuffSize = 0x0ffffff;	// allocate line buffer for output which can hold this many chars

typedef enum TAG_eModepgSNP {
	eMpgSNPKalign = 0,						// input SNPs are those generated by kalign
	eMpgSNPmarkers							// input SNPs are those generated by snpmarkers
} eModepgSNP;

typedef enum TAG_eRMFsnp {			// report format
	eRMFpgSNP = 0,					// report in pgSNP format
	eRMFvcf							// report in VCF 4.1 format
} eRMFsnp;

typedef enum TAG_etSetOp {
	eSONone = 0,					// no Set operation
	eSOUnion,						// union of SetA and SetB
	eSOIntersect,					// intersect of SetA and SetB
	eSOCplUnion,					// complement of union SetA and SetB
	eSOCplIntersect,				// complement of intersect SetA and SetB
	eSOSubtract,					// SetA subtract SetB
	eSOPlaceHolder					// just a place holder to mark end of enumeration
} etSetOp;

const int cMaxSetMembers = cMaxCultivars;	// up to a maximum of this many species/cultivars/isolates can be named in Set
											// if no cultivars marked for retention then all cultivars will be processed
const int cAlignNumSNPfields = 23;			// if generated by 'kit4b align' then there will be this many CSV fields
const int cSNPMarkerNumFields = 4 + 9;		// if generated by 'kit4b snpmarkers' then there will be a minimum of this number of CSVfields

#pragma pack(1)
typedef struct TAG_sCultivar {
	char szName[cMaxDatasetSpeciesChrom+1];		// name of this cultivar
	etSeqBase CalledBase;						// base called as being the major allele for this cultivar
	double Score;								// score
	uint32_t TotBaseCnts;						// total number of base counts
	uint32_t TotMismatches;					// total number of non-reference bases
	uint32_t BaseCnts[5];						// counts for each base
	uint8_t flgSNPInferenced:1;					// 1 if allele was inferenced 
	uint8_t flgInSetA:1;						// 1 if this cultivar is a member of SetA
	uint8_t flgInSetB:1;						// 1 if this cultivar is a member of SetB
} tsCultivar;

typedef struct TAG_sBaseCnts {
	etSeqBase Base;     // counts are for this base
	uint32_t Cnts;			// number of counts for this base
	double QScore;			// this bases pgSNP quality score
} tsBaseCnts;

typedef struct TAG_sSNPSite {
	uint32_t SNPId;					// globally unique identifier
	char szChrom[cMaxDatasetSpeciesChrom + 1]; // SNP is on this chromosome
	uint32_t SNPLoci;				// SNP loci
	etSeqBase RefBase;				// reference base
	uint32_t TotBaseCnts;				// covering bases
	uint32_t TotMismatches;			// number of bases not matching the reference base
	double LocalSeqErrRate;			// estimated localised error rate around the putative SNP site
	tsBaseCnts BaseCnts[5];			// base counts which are to be reported
} tsSNPSite;

#pragma pack()

class CSNPs2pgSNPs
{
	eRMFsnp m_ReportFormat;						// processing results are to be reported in this file format
	uint32_t m_MinCoverage;							// must be at least this read coverage at SNP site
	double m_MinAlleleProp;						// putative allele must be at least this proportion of total site read coverage
	double m_PValueThres;						// acceptance PValue
	char m_szInSNPsFile[_MAX_PATH];				// processing this input kalign SNP calls or snpmarker CSV file
	char m_szOutpgSNPsFile[_MAX_PATH];			// output in UCSC Personal Genome SNP format to this file
	char m_TargAssemblyName[cMaxDatasetSpeciesChrom+1]; // alignments were against this targeted assembly
	char m_SpecAssemblyName[cMaxDatasetSpeciesChrom + 1]; // in generated pgSNP file use this as the assembly name
	char m_szDescription[_MAX_PATH];
	char m_szTrackName[100];
	int m_NumCultivars;							// number of cultivars being processed
	tsCultivar m_Cultivars[cMaxCultivars];		// cultivar specific metadata
	CCSVFile *m_pCSV;							// used to load SNP calls
	int m_hOutpgSNPs;							// output SNP format file handle
	
	   double m_LocalSeqErrRate;					// estimated localised error rate around the putative SNP site

	etSetOp m_SetOp;							// set operation on SetA and/or SetB				
	int m_NumInSetA;							// number of species/cultivars/isolates in SetA
	char** m_ppszSetA;							// names of those cspecies/cultivars/isolates which are in SetA
	int m_NumInSetB;							// number of species/cultivars/isolates in SetB
	char** m_ppszSetB;							// names of those cspecies/cultivars/isolates in SetB

	uint32_t m_NumSNPs;							// number of SNP sites accepted 
	uint32_t m_AllocdSNPSites;					// m_pSNPSites allocated to hold at most this many SNP sites
	tsSNPSite *m_pSNPSites;						// allocated to hold accepted SNP sites
	
	int m_LineBuffOffs;							// offset in m_pszLineBuff at which to next write buffered lines
	int m_AllocdLineBuff;						// 	m_pszLineBuff allocated to a max of this many chars			
	char *m_pszLineBuff;						// line buffer memory to hold buffered output

	int ProcessKalignSNPs(void);				// output kalign SNPs to a UCSC Personal Genome SNP format file

	int ProcessSnpmarkersSNPs(void);			// output snpmarkers generated SNP calls to a UCSC Personal Genome SNP format file

public:
	CSNPs2pgSNPs(void);
	~CSNPs2pgSNPs(void);

	void Reset(void);							// re-initialise  

	int Report(bool bHeader,					// if true then header line(s) to be generated, otherwise SNPs or alleles
			   tsSNPSite* pSNPSite);			// SNP or allele details

	int Process(eModepgSNP Mode,			// processing mode
			double LocalSeqErrRate,			// local sequencing error rate in a 100bp window centered around the putative SNP site
			int MinCoverage,				// must be at least this coverage at SNP site
			double MinAlleleProp,			// putative allele must be at least this proportion of total site read coverage
			double PValueThres,				// only accept SNP alleles which have a PValue <= this threshold
			char* pszTrackName,				// track name
			char* pszAssemblyName,			// UCSC assembly name - for SARS-CoV-2 it is "wuhCor1"
			char* pszExperimentDescr,		// describes experiment
			etSetOp SetOp,					// set operation on SetA and/or SetB				
			int NumInSetA,					// number of species/cultivars/isolates in SetA
			char** ppszSetA,				// names of those cspecies/cultivars/isolates which are in SetA
			int NumInSetB,					// number of species/cultivars/isolates in SetB
			char** ppszSetB,				// names of those cspecies/cultivars/isolates in SetB
			char* pszSNPFile,				// load SNP calls from this CSV file, can be either SNPs generated by kalign or snpmarkers
			char* pszOutFile);				// output SNPs to this UCSC Personal Genome SNP format file
};

