/*
This toolkit is a source base clone of 'BioKanga' release 4.4.2 (https://github.com/csiro-crop-informatics/biokanga) and contains
significant source code changes enabling new functionality and resulting process parameterisation changes. These changes have resulted in
incompatibility with 'BioKanga'.

Because of the potential for confusion by users unaware of functionality and process parameterisation changes then the modified source base
and resultant compiled executables have been renamed to 'kit4b' - K-mer Informed Toolkit for Bioinformatics.
The renaming will force users of the 'BioKanga' toolkit to examine scripting which is dependent on existing 'BioKanga'
parameterisations so as to make appropriate changes if wishing to utilise 'kit4b' parameterisations and functionality.

'kit4b' is being released under the Opensource Software License Agreement (GPLv3)
'kit4b' is Copyright (c) 2019, 2020
Please contact Dr Stuart Stephen < stuartjs@g3web.com > if you have any questions regarding 'kit4b'.

Original 'BioKanga' copyright notice has been retained and immediately follows this notice..
*/
/*
 * CSIRO Open Source Software License Agreement (GPLv3)
 * Copyright (c) 2017, Commonwealth Scientific and Industrial Research Organisation (CSIRO) ABN 41 687 119 230.
 * See LICENSE for the complete license information (https://github.com/csiro-crop-informatics/biokanga/LICENSE)
 * Contact: Alex Whan <alex.whan@csiro.au>
 */

#pragma once
const int cDESummFields    = 24;		// expecting DE summary (sans bins) transcript expression files to contain this many fields
const int cDESummMinBinFields = (cDESummFields + 5 + 5);		// expecting DE summary plus binstranscript expression files to contain at least this many fields assuming a minimum of 5 bins
const int cDESummMaxBinFields = (cDESummFields + 5 + 100);		// expecting DE summary plus binstranscript expression files to contain a maximum of this many fields assuming a maximum of 100 bins


const int cMaxTransIdntNameLen = 50;	// experiment identifiers and other names can be if this maximal length
const int cMaxTransNameLen = 80;		// targeted sequence names can be if this maximal length
const int cMaxTransIdntDescrLen = 200;	// allow experiment conditions, and other descriptive fields, to be described by text of this maximal length

const int cMaxMRATrans = 100;		// cache the last 100 transcript identifiers

typedef struct TAG_sDEStmsSQL {
	char *pTblName;					// table name
	char *pszCreateTbl;				// SQL statement used to create the table
	char *pszInsert;				// SQL statement used to insert row into table
	sqlite3_stmt *pPrepInsert;		// prepared insert row statement; NULL if not prepared
	char *pszOpenCreateSafeIndexes;	// SQL statement used to create indexes on this table immediately after opening this database, essentially these are used whilst populating
	char *pszOpenCreateIndexes;		// SQL statement used to create indexes on this table immediately after opening this database, when it is known the inputs are generated by 'genmarkers' essentially these are used whilst populating
	char *pszCreateIndexes;			// SQL statement used to create indexes on this table before closing the database
	char *pszDropIndexes;			// SQL statement used to drop indexes on this table
} tsDEStmSQL;

typedef struct TAG_sMRATrans {
	char szTransName[cMaxTransNameLen+1];	// transcript name
	int TransID;						// SQLite allocated transcript identifier
	int AccessCnt;						// number of times recently accessed
	} tsMRATrans;


class CSQLiteDE
{
	sqlite3 *m_pDB;						// pts to instance of SQLite
	int m_NumTransMRA;					// number of entries in MRA transcript table
	static tsDEStmSQL m_StmSQL[4];		// SQLite table and index statements
	tsMRATrans m_MRATrans[cMaxMRATrans];	// MRA transcripts

	bool m_bSafe;						// true if safe select required rather than simply getting last assigned ROWID
	int m_NumTrans;						// number of transcripts added to TblTrans
	int m_NumExpres;					// number of expressions added to TblExpres

	sqlite3 *
		CreateDatabase(bool bSafe,		// true if sourcing from input CSV of unknown origin which may contain duplicates etc..
				char *pszDatabase);		// database to create (any existing database is deleted then clean created)

	int
		CloseDatabase(bool bNoIndexes = false);

	int												// errors if < eBSFSuccess, if positive then the ExprID
		CreateExperiment(int CSVtype,				// 0 if short form, 1 if including individual bin counts
					char *pszInFile,				// CSV file containing expression analysis results
					char *pszExprName,				// experiment identifier
					char *pszExprDescr,				// describes experiment
					char *pszCtrlConditions,		// control conditions
					char *pszExprConditions,		// experiment conditions
					int NumBins);					// number of bins
	

	int										// returned identifier for transcript
		AddTrans(int ExprID,			// experiment identifier
			char *pszTransName,				// transcript name
			int NumExons,				    // number of exons in this transcript
			int TransLen,					// transcript length
			char *pszAnnotation);			// any associated annotations

	int										// returned identifier for transcript
		AddExpres(int ExprID,		// experiment identifier
			int TransID,					// transcript identifier
			int Class,
			int Score,
			int DECntsScore,
			int PearsonScore,
			int CtrlUniqueLoci,
			int ExprUniqueLoci,
			double CtrlExprLociRatio,
			double PValueMedian,
			double PValueLow95,
			double PValueHi95,
			int TotCtrlCnts,
			int TotExprCnts,
			int TotCtrlExprCnts,
			double ObsFoldChange,
			double FoldMedian,
			double FoldLow95,
			double FoldHi95,
			double ObsPearson,
			double PearsonMedian,
			double PearsonLow95,
			double PearsonHi95,
			int CtrlAndExprBins,
			int CtrlOnlyBins,
			int ExprOnlyBins);

	int
		AddBin(int ExprID,
				int TransID,
				int ExpresID,
				int NthBin,
				int CtrlCounts,
				int ExprCounts);

	static char *RemoveQuotes(char *pszRawText);
				
	static int ExecCallbackID(void *pCallP1, // callback function processing identifier (4th arg to sqlite3_exec())
					int NumCols,			// number of result columns 
					char **ppColValues,		// array of ptrs to column values 
					char **ppColName);		// array of ptrs to column names

public:
	CSQLiteDE(void);
	~CSQLiteDE(void);
	int
		ProcessCSV2SQLite(int PMode,	// currently just the one mode...default is to parse from CSV and create/populate SQLite database
				  bool bSafe,					// if true then use indexing on all tables whilst inserting... much slower but perhaps safer if multiple threads ...
			      char *pszExprName,			// name by which this experiment is identified
				  char *pszExprDescr,			// describes experiment
				  char *pszCtrlConditions,		// control conditions
				  char *pszExprConditions,		// experiment conditions
				  char *pszInFile,				// parse from this input CSV file
				  char *pszDatabase);			// SQLite database file
};




