#include "stdafx.h"
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if _WIN32
#include <process.h>
#include "../libkit4b/commhdrs.h"
#else
#include <sys/mman.h>
#include <pthread.h>
#include "../libkit4b/commhdrs.h"
#endif

#include "./ngskit4b.h"
#include "./haps2genotype.h"

int Process(eGTHMode PMode,	// processing mode 0: default processing mode which is to create a genotyping matrix for haplotypes generated by 'ngskit4b callhaplotypes'
				   char* pszRefAssemb,	// reference assembly
				   int NumBinnedHaplotypeFiles,	// number of input called haplotype file specs
				   char* pszBinnedHaplotypeFiles[],	// names of input called haplotype files (wildcards allowed)
				   char* pszOutFile);		// output genotype mattrix to this CSV file

#ifdef _WIN32
int haps2genotype(int argc, char* argv[])
{
	// determine my process name
_splitpath(argv[0], NULL, NULL, gszProcName, NULL);
#else
int
haps2genotype(int argc, char** argv)
{
	// determine my process name
CUtility::splitpath((char*)argv[0], NULL, gszProcName);
#endif
int iFileLogLevel;			// level of file diagnostics
int iScreenLogLevel;		// level of file diagnostics
char szLogFile[_MAX_PATH];	// write diagnostics to this file
int Rslt = 0;   			// function result code >= 0 represents success, < 0 on failure
int NumberOfProcessors;		// number of installed CPUs

eGTHMode PMode;					// processing mode

int Idx;
int NumBinnedHaplotypeFiles;		// number of input binned haplotype files
char* pszBinnedHaplotypeFiles[cMaxHaplotypeFiles];		// names of input binned haplotype files (wildcards allowed)
char szOutFile[_MAX_PATH];		// genotyping matrix output file name
char szRefAssemb[_MAX_PATH];	// reference assembly used as base for PBAs

struct arg_lit* help = arg_lit0("h", "help", "print this help and exit");
struct arg_lit* version = arg_lit0("v", "version,ver", "print version information and exit");
struct arg_int* FileLogLevel = arg_int0("f", "FileLogLevel", "<int>", "Level of diagnostics written to screen and logfile 0=fatal,1=errors,2=info,3=diagnostics,4=debug");
struct arg_file* LogFile = arg_file0("F", "log", "<file>", "diagnostics log file");

struct arg_int* pmode = arg_int0("m", "mode", "<int>", "processing mode: 0 default");
struct arg_str* refassemb = arg_str0("r", "refassemb", "<str>", "reference assembly (default is BRZ)");
struct arg_file* binnedhaplotypefiles = arg_filen("i", "binnedhaplotypes", "<file>", 1, cMaxHaplotypeFiles, "process these haplotype input CSV file(s), wildcards allowed, limit of 1000 files supported");
struct arg_file* outfile = arg_file1("o", "out", "<file>", "output genotype mattrix to this CSV file");
struct arg_end* end = arg_end(200);
void* argtable[] = {help,version,FileLogLevel,LogFile,
					pmode,refassemb,binnedhaplotypefiles,outfile,end};
char** pAllArgs;
int argerrors;
argerrors = CUtility::arg_parsefromfile(argc, (char**)argv, &pAllArgs);
if(argerrors >= 0)
argerrors = arg_parse(argerrors, pAllArgs, argtable);

/* special case: '--help' takes precedence over error reporting */
if(help->count > 0)
	{
	printf("\n%s %s %s, Version %s\nOptions ---\n", gszProcName, gpszSubProcess->pszName, gpszSubProcess->pszFullDescr, kit4bversion);
	arg_print_syntax(stdout, argtable, "\n");
	arg_print_glossary(stdout, argtable, "  %-25s %s\n");
	printf("\nNote: Parameters can be entered into a parameter file, one parameter per line.");
	printf("\n      To invoke this parameter file then precede its name with '@'");
	printf("\n      e.g. %s %s @myparams.txt\n", gszProcName, gpszSubProcess->pszName);
	printf("\nPlease report any issues regarding usage of %s at https://github.com/kit4b/issues\n\n", gszProcName);
	return(1);
	}

/* special case: '--version' takes precedence error reporting */
if(version->count > 0)
	{
	printf("\n%s %s Version %s\n", gszProcName, gpszSubProcess->pszName, kit4bversion);
	return(1);
	}

if(!argerrors)
	{
	if(FileLogLevel->count && !LogFile->count)
		{
		printf("\nError: FileLogLevel '-f%d' specified but no logfile '-F<logfile>\n'", FileLogLevel->ival[0]);
		exit(1);
		}

	iScreenLogLevel = iFileLogLevel = FileLogLevel->count ? FileLogLevel->ival[0] : eDLInfo;
	if(iFileLogLevel < eDLNone || iFileLogLevel > eDLDebug)
		{
		printf("\nError: FileLogLevel '-l%d' specified outside of range %d..%d\n", iFileLogLevel, eDLNone, eDLDebug);
		exit(1);
		}

	if(LogFile->count)
		{
		strncpy(szLogFile, LogFile->filename[0], _MAX_PATH);
		szLogFile[_MAX_PATH - 1] = '\0';
		}
	else
		{
		iFileLogLevel = eDLNone;
		szLogFile[0] = '\0';
		}

		// now that log parameters have been parsed then initialise diagnostics log system
	if(!gDiagnostics.Open(szLogFile, (etDiagLevel)iScreenLogLevel, (etDiagLevel)iFileLogLevel, true))
		{
		printf("\nError: Unable to start diagnostics subsystem\n");
		if(szLogFile[0] != '\0')
			printf(" Most likely cause is that logfile '%s' can't be opened/created\n", szLogFile);
		exit(1);
		}

	gDiagnostics.DiagOut(eDLInfo, gszProcName, "Subprocess %s Version %s starting", gpszSubProcess->pszName, kit4bversion);
	gExperimentID = 0;
	gProcessID = 0;
	gProcessingID = 0;

	PMode = pmode->count ? (eGTHMode)pmode->ival[0] : eGTHDefault;
	if(PMode < eGTHDefault || PMode >= eGTHPlaceholder)
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "Error: Unsupported processing mode '-m%d'\n", PMode);
		exit(1);
		}

// show user current resource limits
#ifndef _WIN32
	gDiagnostics.DiagOut(eDLInfo, gszProcName, "Resources: %s", CUtility::ReportResourceLimits());
#endif

#ifdef _WIN32
	SYSTEM_INFO SystemInfo;
	GetSystemInfo(&SystemInfo);
	NumberOfProcessors = SystemInfo.dwNumberOfProcessors;
#else
	NumberOfProcessors = sysconf(_SC_NPROCESSORS_CONF);
#endif

	if(refassemb->count)
		{
		strncpy(szRefAssemb, refassemb->sval[0], 40);
		szRefAssemb[80] = '\0';
		CUtility::TrimQuotedWhitespcExtd(szRefAssemb);
		CUtility::CleanText(szRefAssemb);
		}
	else
		szRefAssemb[0] = '\0';
	if(szRefAssemb[0] == '\0')
		strcpy(szRefAssemb, cDfltRefAssemb);
	szRefAssemb[40] = '\0';

	NumBinnedHaplotypeFiles = 0;
	if(PMode == eGTHDefault)
		{
		if(binnedhaplotypefiles->count)
			{
			for(Idx = 0; NumBinnedHaplotypeFiles < cMaxHaplotypeFiles && Idx < binnedhaplotypefiles->count; Idx++)
				{
				pszBinnedHaplotypeFiles[Idx] = NULL;
				if(pszBinnedHaplotypeFiles[NumBinnedHaplotypeFiles] == NULL)
					pszBinnedHaplotypeFiles[NumBinnedHaplotypeFiles] = new char[_MAX_PATH];
				strncpy(pszBinnedHaplotypeFiles[NumBinnedHaplotypeFiles], binnedhaplotypefiles->filename[Idx], _MAX_PATH);
				pszBinnedHaplotypeFiles[NumBinnedHaplotypeFiles][_MAX_PATH - 1] = '\0';
				CUtility::TrimQuotedWhitespcExtd(pszBinnedHaplotypeFiles[NumBinnedHaplotypeFiles]);
				if(pszBinnedHaplotypeFiles[NumBinnedHaplotypeFiles][0] != '\0')
					NumBinnedHaplotypeFiles++;
				}
			}
		}

	if(PMode == eGTHDefault && !NumBinnedHaplotypeFiles)
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "Error: After removal of whitespace, there are no input binned haplotype file(s) specified with '-i<filespec>' option)\n");
		exit(1);
		}

	strcpy(szOutFile, outfile->filename[0]);
	CUtility::TrimQuotedWhitespcExtd(szOutFile);
	if(szOutFile[0] == '\0')
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "No output file specified");
		exit(1);
		}

	gDiagnostics.DiagOut(eDLInfo, gszProcName, "Processing parameters:");
	const char* pszDescr;
	switch(PMode) {
		case eGTHDefault:
			pszDescr = "generating genotyping matrix for haplotypes generated by 'ngskit4b callhaplotypes'";
			break;
	}

	gDiagnostics.DiagOutMsgOnly(eDLInfo, "Reference assembly : '%s'", szRefAssemb);
	for(Idx = 0; Idx < NumBinnedHaplotypeFiles; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo, "Input binned haplotype file : '%s'", pszBinnedHaplotypeFiles[Idx]);
	gDiagnostics.DiagOutMsgOnly(eDLInfo, "Writing genotyped matrix to this output file : '%s'", szOutFile);

#ifdef _WIN32
	SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);
#endif
	gStopWatch.Start();
	Rslt = 0;
	Rslt = Process(PMode,	// processing mode 0: default processing mode which is to create a genotyping matrix for haplotypes generated by 'ngskit4b callhaplotypes'
					szRefAssemb,	// reference assembly
					NumBinnedHaplotypeFiles,	// number of input called haplotype file specs
					pszBinnedHaplotypeFiles,	// names of input called haplotype files (wildcards allowed)
					szOutFile);		// output genotype mattrix to this CSV file

	Rslt = Rslt >= 0 ? 0 : 1;
	gStopWatch.Stop();

	gDiagnostics.DiagOut(eDLInfo, gszProcName, "Exit code: %d Total processing time: %s", Rslt, gStopWatch.Read());
	exit(Rslt);
	}
else
	{
	printf("\n%s %s %s, Version %s\n", gszProcName, gpszSubProcess->pszName, gpszSubProcess->pszFullDescr, kit4bversion);
	arg_print_errors(stdout, end, gszProcName);
	arg_print_syntax(stdout, argtable, "\nUse '-h' to view option and parameter usage\n");
	exit(1);
	}
}

int Process(eGTHMode PMode,	// processing mode 0: default processing mode which is to create a genotyping matrix for haplotypes generated by 'ngskit4b callhaplotypes'
			char* pszRefAssemb,	// reference assembly
			int NumBinnedHaplotypeFiles,	// number of input called haplotype file specs
			char* pszBinnedHaplotypeFiles[],	// names of input called haplotype files (wildcards allowed)
			char* pszOutFile)		// output genotype mattrix to this CSV file
{
int Rslt;
CHaps2Genotype *pHaps2Genotype;
if((pHaps2Genotype = new CHaps2Genotype) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Unable to instantiate instance of CHaps2Genotype");
	return(eBSFerrObj);
	}
Rslt = pHaps2Genotype->Process(PMode, pszRefAssemb, NumBinnedHaplotypeFiles, pszBinnedHaplotypeFiles, pszOutFile);
delete pHaps2Genotype;
return(Rslt);
}

void
CHaps2Genotype::Reset(void)
{
return;
}

int 
CHaps2Genotype::Process(eGTHMode PMode,	// processing mode 0: default processing mode which is to create a genotyping matrix for haplotypes generated by 'ngskit4b callhaplotypes'
						char* pszRefAssemb,	// reference assembly
						int NumBinnedHaplotypeFiles,	// number of input called haplotype file specs
						char* pszBinnedHaplotypeFiles[],	// names of input called haplotype files (wildcards allowed)
						char* pszOutFile)		// output genotype mattrix to this CSV file
{
int Rslt;
Rslt = PopulateGenotypes(NumBinnedHaplotypeFiles, pszBinnedHaplotypeFiles);

return(eBSFSuccess);
}

// iterate over all specified haplotype files and populate a genotype matrix
int			// total number of files loaded used to populate genotype matrix
CHaps2Genotype::PopulateGenotypes(int NumBinnedHaplotypeFiles,	// number of input called haplotype file specs
								   char* pszBinnedHaplotypeFiles[])	// names of input called haplotype files (wildcards allowed)
{
int Rslt = eBSFSuccess;		// assume success!
int Idx;
int NumFiles;
char* pszInFile;
uint32_t ProgenyID = 0;
int TotNumFilesLoaded = 0;
CSimpleGlob glob(SG_GLOB_FULLSORT);
for(Idx = 0; Idx < NumBinnedHaplotypeFiles; Idx++)
	{
	glob.Init();
	if(glob.Add(pszBinnedHaplotypeFiles[Idx]) < SG_SUCCESS)
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "Process: Unable to glob '%s' binned haplotype input file specification", pszBinnedHaplotypeFiles[Idx]);
		Reset();
		return(eBSFerrOpnFile);	// treat as though unable to open file
		}
	if((NumFiles = glob.FileCount()) <= 0)
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "Process: Unable to locate any binned haplotype input file matching '%s", pszBinnedHaplotypeFiles[Idx]);
		Reset();
		return(eBSFerrFileName);
		}

	Rslt = eBSFSuccess;
	for(int FileID = 0; Rslt >= eBSFSuccess && FileID < NumFiles; ++FileID)
		{
		pszInFile = glob.File(FileID);
		if((ProgenyID = LoadHaplotypes(pszInFile, TotNumFilesLoaded == 0 ? true : false)) < 0)
			{
			gDiagnostics.DiagOut(eDLInfo, gszProcName, "Process: Errors loading binned haplotype file '%s'", pszInFile);
			Reset();
			return(ProgenyID);
			}
		TotNumFilesLoaded++;
		}
	}
return(TotNumFilesLoaded);
}

// load and parse an individual haplotype file
int								 // eBSFSuccess or error
CHaps2Genotype::LoadHaplotypes(char* pszInFile,  // load haplotypes from this file
			   bool bFirst)		 // if true then this is first to be process and will be used to initialise the reference assembly metadata
{
int Rslt;
int CurLineNumber;
int NumFields;
int NumFounders;
int FndrIdx;
int Haps[100];
char *pszTmpField;

if((m_pInHapFile = new CCSVFile) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Unable to instantiate CCSVfile");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt = m_pInHapFile->Open(pszInFile)) != eBSFSuccess)
	{
	gDiagnostics.DiagOut(eDLFatal, gszProcName, "Unable to open file: '%s'", pszInFile);
	Reset();
	return(Rslt);
	}

CurLineNumber = 0;
while((Rslt = m_pInHapFile->NextLine()) > 0)		// onto next line containing fields
	{
	CurLineNumber++;
	if((NumFields = m_pInHapFile->GetCurFields()) <= 4)	// must contain at least 8 fields - 1st 4 are invariant then 4 per founder
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "Haplotype file '%s' expected to contain a minimum of 8 fields, it contains %d at line %d", pszInFile, NumFields, CurLineNumber);
		Reset();
		return(eBSFerrParse);
		}
	if((NumFields - 4) % 4 != 0)	// 4 invariant plus 4 fields per founder
		{
		gDiagnostics.DiagOut(eDLFatal, gszProcName, "Haplotype file '%s' has discrepancy in total number of fields, it contains %d at line %d", pszInFile, NumFields, CurLineNumber);
		Reset();
		return(eBSFerrParse);
		}
	NumFounders = (NumFields - 4) / 4;

	// 1st row is expected to be a header row
	if(CurLineNumber == 1 && m_pInHapFile->IsLikelyHeaderLine())
		{
		// parse out progeny sample identifier plus identifier for each founder
		m_pInHapFile->GetText(3,&pszTmpField);		// expected to be of the form: Skim-NonUniques:S099678 with 'Skim-NonUniques:' as prefix followed by the progeny sample identifier

		for(FndrIdx = 1; FndrIdx <= NumFounders; FndrIdx++)
			{
			m_pInHapFile->GetText(4 + FndrIdx, &pszTmpField);		// expected to be of the form: FndrUniques-S099678:S0360092 with 'FndrUniques-' as prefix followed by the progeny sample identifier followed by the founder sample identifier
			}		
		continue;
		}
	// haplotypes row
	for(FndrIdx = 1; FndrIdx <= NumFounders; FndrIdx++)
		{
		m_pInHapFile->GetInt((4 + ((NumFounders-1) * 4)) + FndrIdx, &Haps[FndrIdx-1]);		// 0 if smoothed haplotype absent, 2 if smoothed haplotype present 
		}
	}

delete m_pInHapFile;
return(eBSFSuccess);
}
