#pragma once

const char cDfltRefAssemb[41] = "BRZ";		// reference assembly used against which PBAs were generated
const int cMaxHaplotypeFiles = 1000;		// can specifiy at most this many input binned haplotype files (wildcards allowed)
const int cMaxNumProgenies = 10000;			// can process for a max of this number of progenies - haplotype files may have been wildcarded hence multiple progenies per file spec
const int cMaxChromNames = 10000;			// allowing for this maximum number of chromosome names in the reference assembly

// currently only the default processing mode
typedef enum TAG_eGTHMode {
	eGTHDefault = 0,	// just the default processing mode which is to create a genotyping matrix for haplotypes generated by 'ngskit4b callhaplotypes'
	eGTHPlaceholder		// used as a placeholder to mark number of processing modes
} eGTHMode;

#pragma pack(1)

typedef struct TAG_sChromBin {
	int32_t ChromID;	// bin is on this reference chromosome
	int32_t StartLoci;	// bin starts at this chromosome loci
	int32_t BinSize;	// bin size in bp
} tsChromBins;

typedef struct Tag_sRefAssembMetadata {
	char szRefAssembName[41];	// reference assembly name
	uint32_t NumChroms;			// has this number of chromosomes referenced by at least one progeny
	uint32_t NumBins;			// number of bins used
	uint32_t AllocdBins;		// number of allocated bins
	tsChromBins *pBins;			// allocated bins
} sRefAssembMetadata;

typedef struct TAG_sProgenyMetadata {
	uint32_t SampleID;		// uniquely identifies progeny
	uint32_t FaID;			// uniquely identifies Fa
	uint32_t FbID;			// uniquely identifies Fb
	uint32_t FcID;			// uniquely identifies Fc
	uint32_t GenotypeOfs;	// genotypes for this progeny start at this offset
} tsProgenyMetadata;

#pragma pack()

class CHaps2Genotype
{

	CCSVFile* m_pInHapFile;				// contains current input haplotype file being loaded

	int32_t m_LAChromNameID;						// last accessed chromosome identifier from call to AddChrom()
	int32_t m_NumChromNames;						// number of chromosome names currently in m_szChromNames
	int32_t m_NxtszChromIdx;						// current concatenated (names separated by '\0') of all chromosome names in m_szChromNames
	char m_szChromNames[cMaxChromNames * cMaxDatasetSpeciesChrom];	// used to hold concatenated chromosome names, each separated by '\0'
	uint32_t m_szChromIdx[cMaxChromNames];			// array of indexes into m_szChromNames giving the starts of each chromosome name

	uint32_t m_NumProgenyGenotypes;			// number of progeny genotypes processed
	tsProgenyMetadata m_ProgenyMetadata[cMaxNumProgenies];	// to hold all progeny genotypes

	uint64_t m_NumGenotypes;		// number of genotypes in m_pGenotypes
	uint64_t m_NumAllocdGenotypes;	// m_pGenotypes currently allocated to hold this many genotypes
	uint8_t *m_pGenotypes;			// allocated to hold all genotypes

	// iterate over all specified haplotype files and populate genotype matrix
	int			// total number of files loaded used to populate genotype matrix
		PopulateGenotypes(int NumBinnedHaplotypeFiles,	// number of input called haplotype file specs
						  char* pszBinnedHaplotypeFiles[]);	// names of input called haplotype files (wildcards allowed)
	// load and parse an individual haplotype file
	int								 // eBSFSuccess or error
		LoadHaplotypes(char* pszInFile,				// load haplotypes from this file
					   bool bFirst);	// if true then this is first to be process and will be used to initialise the reference assembly metadata

	void Reset(void);		// resets class instance state back to that immediately following instantiation
	
public:
	int Process(eGTHMode PMode,	// processing mode 0: default processing mode which is to create a genotyping matrix for haplotypes generated by 'ngskit4b callhaplotypes'
				char* pszRefAssemb,	// reference assembly
				int NumBinnedHaplotypeFiles,	// number of input called haplotype file specs
				char* pszBinnedHaplotypeFiles[],	// names of input called haplotype files (wildcards allowed)
				char* pszOutFile);		// output genotype matrix to this CSV file
};

