#pragma once


const UINT32 cMaxMAFBlockRowLen = 0x03fffff;    // assuming upper limit on length of any single MAF row
const UINT32 cMaxMAFKmerDistBlockLen = (cMaxMAFBlockRowLen * 100); // expect maximally sized alignment blocks to be no m ore than this size
const UINT32 cAllocRptBuffSize = 0x07ffff;      // output report buffer size

const int cMaxKMerLenCnts = 25;                // KMer counts accumulated for up to this KMer length

#pragma pack(1)
typedef struct TAG_sKmerConfBase {   // associating consensus base with corresponding concensus confidence
	etSeqBase ConsBase;		// consensus base 
	UINT8 Conf;				// confidence in consensus base
	etSeqBase ProbeBase;	// probe (or reference) sequence base
	etSeqBase TargBase;		// target (or relative) sequence base
} tsKmerConfBase;

#pragma pack()

class CMAFKMerDist
{
	bool m_bIsGZ;					// true if processing a gz compressed multialignment file
	gzFile m_gzFile;				// opened for reading (if compressed) a multialignment file as may have been generated by MAlignCols2MFA()
	int m_hMAFFile;					// opened for reading (if not compressed) a multialignment file as may have been generated by MAlignCols2MFA()
	int m_hConsSeqFile;				// opened for writing the consensus sequences to
	INT64 m_MAFFileOfs;				// will contain file offset corresponding to last read from file
	int m_MAFAlignBuffIdx;			// offset in m_pszMAFAlignBlock at which next char is being parsed
	int m_MAFAlignBuffered;			// number of chars currently buffered in m_pszMAFAlignBuff
	INT64 m_MAFFileLineNum;			// line number in MAF file currently being parsed
	UINT32 m_NumParsedBlocks;       // this many alignment blocks have been parsed from MAF file
	UINT32 m_AllocMAFAlignBuffSize;	// m_pszMAFAlignBlock allocated to hold this many chars
	char *m_pszMAFAlignBuff;		// allocated to buffer the MAF alignment blocks whilst parsing
	tsKmerConfBase *m_pConsConfSeq;		// allocated to hold the parsed consensus bases and consensus confidence scores
	UINT32 m_OfsRptBuff;			// offset in m_pszRptBuff at which to next write
	UINT32 m_AllocRptBuffSize;      // m_pszRptBuff allocation size
	char *m_pszRptBuff;				// allocated to buffer the generated K-mer stats ready to be written to disk

public:
	CMAFKMerDist();
	~CMAFKMerDist();

	void Reset(void);				// reset class state back to that immediately following class instantiation

	int
		GenKmerDistFromMAF(int MinSeqLen,			// sequences must be of at least this minimum length
				 int MinConcScore,					// K-mer distributions from subsequences with consensus score to be at least this threshold
				char *pszKmerDistFile,				// name of file into which write error corrected sequences
				char *pszMultiAlignFile);			// name of file containing multiple alignments to process

	int    // parse out the next multialignment block consensus bases and consensus confidence scores into m_pConsConfSeq
		ParseConsConfSeq(bool bCpltdReadMAF,		// true if m_pConsConfSeq contains all remaining multialignment blocks loaded from file 
						 int MinErrCorrectLen);		// error corrected sequences must be at least this minimum length

	int GenKMerDist(int ProbeID,					// alignment using this probe identifier
					int NumAlignCols);	    		// number of alignment columns to analyse for K-mers
};

