// prednucleosomes.cpp : Defines the entry point for the console application.
// predicts nucleosome occupied positions from short read loci as aligned by kanga
//

#include "stdafx.h"
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#if _WIN32
#include "../libkit4b/commhdrs.h"
#else
#include "../libkit4b/commhdrs.h"
#endif

const int cMaxIncludeChroms = 20;		// max number of include chromosomes regular expressions
const int cMaxExcludeChroms = 20;		// max number of exclude chromosomes regular expressions


// processing modes
typedef enum TAG_ePMode {
	 ePMpaired = 0,				// paired reads @ 147 +/- 10bp
	 ePMfulllength,				// full length ~147 reads
	 ePMunpaired,				// unpaired reads extended to 147
	 ePMplaceholder				// used to set the enumeration range
	} etPMode;

// output format modes
typedef enum TAG_eFMode {		
	eFMbedGraphDyads,			// default is for ucsc bedGraph dyads
	eFMbedDyads,				// ucsc bed format dyads
	eFMcsvDyads,				// CSV format dyads
	eFMbedGraphNucs,			// ucsc bedGraph nucleosomes
	eFMbedNucs,					// ucsc bed nucleosomes
	eFMcsvNucs,					// CSV format nucleosomes
	eFMMNaseScore,				// MNase score distribution
	eFMMcsvScores,				// CSV all scores along genome
	eFMplaceholder				// used to set the enumeration range
	} etFMode;

typedef enum TAG_eReadsSortMode {
		eRSMReadID,				// index by ascending ReadID
		eRSMHitMatch,			// index by ascending chrom, loci, strand, level
		eRSMplaceholder			// used to limit the enumeration range
} etReadsSortMode;

// output format modes used when alignments generated
typedef enum TAG_eAFMode {		
	eAFMdefault,				// default is for match loci only
	eAFMmatch,					// loci + match sequence
	eAFMread,					// loci + read sequence
	eAFMreadmatch,				// loci + read + match sequence
	eAFMplaceholder				// used to set the enumeration range
	} etAFMode;

#pragma pack(1)
typedef struct TAG_sAlignHit {
	UINT32 AlignHitIdx;			// current read hit index + 1 for this read
	UINT32 ReadID;				// read identifier from the preprocessed read (tsProcRead)
	char szChromName[cMaxDatasetSpeciesChrom];	// identifies hit chromosome
	UINT32 ChromID;				// chromosome identifier
	UINT8 Strand;				// hit strand - '+' or '-'
	UINT32 Loci;				// offset on chromosome of hit
	UINT16 AlignLen;			// alignment length
	UINT8 Processed:1;			// 0 until this reads has been processed for dyad potential
} tsAlignHit;
#pragma pack()


int
Process(etPMode PMode,					// processing mode
		etFMode FMode,					// output format mode
		int MovAvgFilter,				// apply this moving average window size filter
		int BaselineFilter,				// baseline normalisation window size
		char *pszTrackName,				// UCSC track name
		char *pszInFile,				// file containing aligned short reads
		bool bBiasMNase,				// true if dyad scores to be normalised for MNase biases
		char *pszInMNaseFile,			// optionally also score from this MNase site selectivity file (generated by MNaseSitePred process)
		char *pszInBioseqFile,			// if scoring on MNase selectivity then also need the bioseq genome file
		char *pszOutFile,				// where to write nucleosome predictions
		int	NumIncludeChroms,			// number of chromosome regular expressions to include
		char **ppszIncludeChroms,		// array of include chromosome regular expressions
		int	NumExcludeChroms,			// number of chromosome expressions to exclude
		char **ppszExcludeChroms);		// array of exclude chromosome regular expressions

int
LoadReads(char *pszInFile,				// load aligned reads from these files
		  int NumIncludeChroms,			// number of chromosomes explicitly defined to be included
			char **ppszIncludeChroms,	// ptr to array of reg expressions defining chroms to include - overides exclude
			int NumExcludeChroms,		// number of chromosomes explicitly defined to be excluded
			char **ppszExcludeChroms);	// ptr to array of reg expressions defining chroms to exclude

tsAlignHit *LocateRead(UINT32 ReadID);			// locate read identified by ReadID

tsAlignHit *IterReads(tsAlignHit *pCurAlignHit);	// iterate over unsorted reads
tsAlignHit *IterSortedReads(tsAlignHit *pCurAlignHit, bool bForward); //iterate over sorted rads
int SortAlignHits(etReadsSortMode SortMode);		// index read hits according to specified SortMode

static int SortHitReadIDs(const void *arg1, const void *arg2);
static int SortHitMatch(const void *arg1, const void *arg2);


CStopWatch gStopWatch;
CDiagnostics gDiagnostics;				// for writing diagnostics messages to log file
char gszProcName[_MAX_FNAME];			// process name

const int cDyadsInitialAlloc = 30000000;						 // inital allocation for dyads to hold this many dyad loci scores
const int cDyadsReAlloc = 10000000;								 // realloc allocation for dyads
const int cReadsInitalAlloc   = 10000000;						 // initial allocation to hold this many reads
const int cReadsReAlloc = 5000000;								// realloc allocation in this sized increments


tsAlignHit *m_pAlignHits = NULL;	// memory allocated to hold reads, reads are written contiguously into this memory
UINT32 m_AllocdAlignHits = 0;		// how instances of tsAlignHit have been allocated
UINT32 m_NumAlignHits = 0;			// m_pAlignHits contains this many reads
UINT32 m_FinalReadID = 0;			// final read identifier loaded as a preprocessed read (tsProcRead)

tsAlignHit **m_ppAlignHitsIdx = NULL;	// memory allocated to hold array of ptrs to read hits in m_pAlignHits - usually sorted by some critera
UINT32 m_AllocdAlignHitsIdx = 0;		// how many elements for m_pAlignHitsIdx have been allocated
etReadsSortMode	m_CurReadsSortMode;	    // sort mode last used on m_ppAlignHitsIdx

CCSVFile *m_pCSVAligns;				// used if loading aligned reads from csv file
CBEDfile *m_pBEDAligns;				// used if loading aligned reads from BED file

CCSVFile *m_pMNaseCSV;				// used to hold DNase site preferences whilst loading into m_pMNaseSel 
CBioSeqFile *m_pBioSeqFile;			// holds instantiated genome assembly sequences, used if MNase scoring
etSeqBase *m_pChromSeq;				// holds current assembly chromosome sequence, used if MNase scoring
int m_AllocdChromSeq;				// allocated assembly chromosome sequence length
int m_ChromSeqLen;					//  current assembly chromosome sequence length
double *m_pMNaseSel;				// allocated array of MNase site selection preferences (0.0..1.0) indexed by sequence octamers
int m_MaxMNaseScore;				// to hold maximum MNase sequence score
int m_MinMNaseScore;				// to hold minimum MNase sequence score
int m_MNaseScoreHist[1000];			// used to build a histogram of MNase score distributions 

int m_NumIncludeChroms;				// number of RE include chroms
int m_NumExcludeChroms;				// number of RE exclude chroms

#ifdef _WIN32
Regexp *m_IncludeChromsRE[cMaxIncludeChroms];	// compiled regular expressions
Regexp *m_ExcludeChromsRE[cMaxExcludeChroms];
#else
regex_t m_IncludeChromsRE[cMaxIncludeChroms];	// compiled regular expressions
regex_t m_ExcludeChromsRE[cMaxExcludeChroms];
#endif


#ifdef _WIN32
// required by str library
#if !defined(__AFX_H__)  ||  defined(STR_NO_WINSTUFF)
HANDLE STR_get_stringres()
{
	return NULL;	//Works for EXEs; in a DLL, return the instance handle
}
#endif

const STRCHAR* STR_get_debugname()
{
	return _T("prednucleosomes");
}
// end of str library required code
#endif


#ifdef _WIN32
int _tmain(int argc, char* argv[])
{
// determine my process name
_splitpath(argv[0],NULL,NULL,gszProcName,NULL);
#else
int 
main(int argc, const char** argv)
{
// determine my process name
CUtility::splitpath((char *)argv[0],NULL,gszProcName);
#endif
int iScreenLogLevel;		// level of screen diagnostics
int iFileLogLevel;			// level of file diagnostics
char szLogFile[_MAX_PATH];	// write diagnostics to this file
int Rslt = 0;   			// function result code >= 0 represents success, < 0 on failure
int Idx;
int LenChromList;

etPMode PMode;				// processing mode
etFMode FMode;				// format output mode

bool bBiasMNase;
int MovAvgFilter;			// apply this moving average window size filter
int BaselineFilter;			// use this window size when normalising for baseline
char szTrackTitle[cMaxDatasetSpeciesChrom];			// title to identify predicted nucleosome track

char szRsltsFile[_MAX_PATH];
char szInFile[_MAX_PATH];
char szInMNaseFile[_MAX_PATH];
char szInGenomeFile[_MAX_PATH];

int NumIncludeChroms;
char *pszIncludeChroms[cMaxIncludeChroms];
int NumExcludeChroms;
char *pszExcludeChroms[cMaxExcludeChroms];

// command line args
struct arg_lit  *help    = arg_lit0("hH","help",                "print this help and exit");
struct arg_lit  *version = arg_lit0("v","version,ver",			"print version information and exit");
struct arg_int *FileLogLevel=arg_int0("f", "FileLogLevel",		"<int>","Level of diagnostics written to logfile 0=fatal,1=errors,2=info,3=diagnostics,4=debug");
struct arg_file *LogFile = arg_file0("F","log","<file>",		"diagnostics log file");

struct arg_int *pmode = arg_int0("m","mode","<int>",		    "processing mode: 0 - paired reads @ 147 +/- 20bp, 1 - full length @ 147 +/- 20bp, 2 - unpaired reads extended to 147 (default = 0)");
struct arg_file *infile = arg_file1("i","in","<file>",			"input from this aligned reads (kanga generated) CSV file");
struct arg_file *inMNase = arg_file0("I","mnase","<file>",		"score from this MNase selectivity file generated by MNaseSitePred");
struct arg_file *ingenome = arg_file0("g","genome","<file>",	"if MNase selectivity then bioseq file for targeted genome must be specified");

struct arg_lit *biasmnmase = arg_lit0("b","biasenmase",			"normalise dyad scores for mnase biases");

struct arg_file *outfile = arg_file1("o","out","<file>",		"output nucleosome predictions (or MNase score distribution) to this file");
struct arg_int *format = arg_int0("M","format","<int>",		    "output format: 0 - UCSC bedGraph dyads, 1 - UCSC BED dyads, 2 - CSV dyads,  3 - UCSC bedGraph nucleosomes, 4 - UCSC BED nucleosomes, 5 - CSV nucleosomes, 6 - CSV NNase Score Distribution, 7 - CSV Dyad scores (default: 0)");
struct arg_str  *title = arg_str0("t","title","<string>",       "track title");
struct arg_int *movavgfilter = arg_int0("a","avgwindow","<int>","apply lowpass filter as a moving average window of this size, 0 if none else 5..100 (default: 10)");
struct arg_int *baselinefilter = arg_int0("A","basewindow","<int>","baseline normalisation window size, 0 if none else 25..5000 (default: 500)");

struct arg_str  *ExcludeChroms = arg_strn("Z","chromexclude","<string>",0,cMaxExcludeChroms,"high priority - regular expressions defining chromosomes to exclude");
struct arg_str  *IncludeChroms = arg_strn("z","chromeinclude","<string>",0,cMaxIncludeChroms,"low priority - regular expressions defining chromosomes to include");

struct arg_end *end = arg_end(20);

void *argtable[] = {help,version,FileLogLevel,LogFile,
					pmode,format,movavgfilter,baselinefilter,title,infile,biasmnmase,inMNase,ingenome,outfile,ExcludeChroms,IncludeChroms,
					end};

char **pAllArgs;
int argerrors;
argerrors = CUtility::arg_parsefromfile(argc,(char **)argv,&pAllArgs);
if(argerrors >= 0)
	argerrors = arg_parse(argerrors,pAllArgs,argtable);

/* special case: '--help' takes precedence over error reporting */
if (help->count > 0)
        {
		printf("\n%s Predict Nucleosomes from Aligned Reads, Version %s\nOptions ---\n", gszProcName,kit4bversion);
        arg_print_syntax(stdout,argtable,"\n");
        arg_print_glossary(stdout,argtable,"  %-25s %s\n");
		printf("\nNote: Parameters can be entered into a parameter file, one parameter per line.");
		printf("\n      To invoke this parameter file then precede its name with '@'");
		printf("\n      e.g. %s @myparams.txt\n",gszProcName);
		printf("\nPlease report any issues regarding usage of %s to https://github.com/kit4b/kit4b/issues\n\n",gszProcName);
		exit(1);
        }

    /* special case: '--version' takes precedence error reporting */ 
if (version->count > 0)
        {
		printf("\n%s Version %s\n",gszProcName,kit4bversion);
		exit(1);
        }

if (!argerrors)
	{
	if(FileLogLevel->count && !LogFile->count)
		{
		printf("\nError: FileLogLevel '-f%d' specified but no logfile '-F<logfile>'",FileLogLevel->ival[0]);
		exit(1);
		}

	iScreenLogLevel = iFileLogLevel = FileLogLevel->count ? FileLogLevel->ival[0] : eDLInfo;
	if(iFileLogLevel < eDLNone || iFileLogLevel > eDLDebug)
		{
		printf("\nError: FileLogLevel '-l%d' specified outside of range %d..%d",iFileLogLevel,eDLNone,eDLDebug);
		exit(1);
		}
	
	if(LogFile->count)
		{
		strncpy(szLogFile,LogFile->filename[0],_MAX_PATH);
		szLogFile[_MAX_PATH-1] = '\0';
		}
	else
		{
		iFileLogLevel = eDLNone;
		szLogFile[0] = '\0';
		}

	PMode = (etPMode)(pmode->count ? pmode->ival[0] : ePMpaired);
	if(PMode < ePMpaired || PMode >= ePMplaceholder)
		{
		printf("\nError: Processing mode '-m%d' specified outside of range %d..%d",PMode,0,(int)ePMplaceholder-1);
		exit(1);
		}

	FMode = (etFMode)(format->count ? format->ival[0] : eFMbedGraphDyads);
	if(FMode < eFMbedGraphDyads || FMode >= eFMplaceholder)
		{
		printf("\nError: Output format mode '-m%d' specified outside of range %d..%d",FMode,eFMbedGraphDyads,(int)eFMplaceholder-1);
		exit(1);
		}

	MovAvgFilter = movavgfilter->count ? movavgfilter->ival[0] : 10;
	if(MovAvgFilter != 0 && (MovAvgFilter < 5 || MovAvgFilter > 100))
		{
		printf("\nError: Moving average filter width '-a%d' specified outside of range 0 or 5..100",MovAvgFilter);
		exit(1);
		}


	BaselineFilter = baselinefilter->count ? baselinefilter->ival[0] : 500;
	if(BaselineFilter != 0 && (BaselineFilter < 25 || MovAvgFilter > 5000))
		{
		printf("\nError: Baseline normalisation window width '-A%d' specified outside of range 0 or 25..5000",BaselineFilter);
		exit(1);
		}

	bBiasMNase = biasmnmase->count ? true : false;

	NumIncludeChroms = IncludeChroms->count;
	for(Idx=0;Idx < IncludeChroms->count; Idx++)
		{
		LenChromList = (int)strlen(IncludeChroms->sval[Idx]);
		pszIncludeChroms[Idx] = new char [LenChromList+1];
		strcpy(pszIncludeChroms[Idx],IncludeChroms->sval[Idx]);
		CUtility::TrimQuotes(pszIncludeChroms[Idx]);
		}

	NumExcludeChroms = ExcludeChroms->count;
	for(Idx=0;Idx < ExcludeChroms->count; Idx++)
		{
		LenChromList = (int)strlen(ExcludeChroms->sval[Idx]);
		pszExcludeChroms[Idx] = new char [LenChromList+1];
		strcpy(pszExcludeChroms[Idx],ExcludeChroms->sval[Idx]);
		CUtility::TrimQuotes(pszExcludeChroms[Idx]);
		}

	if(FMode != eFMMNaseScore)
		{
		if(!title->count)
			{
			printf("\nError: no track title has been specified with '-t<title>' option");
			exit(1);
			}
		strncpy(szTrackTitle,title->sval[0],sizeof(szTrackTitle));
		szTrackTitle[sizeof(szTrackTitle)-1] = '\0';
		CUtility::TrimQuotedWhitespcExtd(szTrackTitle);
		CUtility::ReduceWhitespace(szTrackTitle);
		if(szTrackTitle[0] == '\0')
			{
			printf("\nError: specified track title is empty or whitespace only");
			exit(1);
			}
		}
	else
		szTrackTitle[0] = '\0';

	strcpy(szRsltsFile,outfile->filename[0]);
	strcpy(szInFile,infile->filename[0]);

	if(FMode == eFMMNaseScore || bBiasMNase == true)
		{
		if(!inMNase->count)
			{
			printf("\nError: You have specified to use MNase selectivity scoring but have not specified the MNase score file with '-I<file' option");
			exit(1);
			}
		if(!ingenome->count)
			{
			printf("\nError: You have specified to use MNase selectivity scoring but have not specified the bioseq genome file with '-g<file' option");
			exit(1);
			}
		strncpy(szInMNaseFile,inMNase->filename[0],_MAX_PATH);
		szInMNaseFile[_MAX_PATH-1] = '\0';
		strncpy(szInGenomeFile,ingenome->filename[0],_MAX_PATH);
		szInGenomeFile[_MAX_PATH-1] = '\0';
		}
	else
		{
		szInMNaseFile[0] = '\0';
		szInGenomeFile[0] = '\0';
		}

		// now that command parameters have been parsed then initialise diagnostics log system
	if(!gDiagnostics.Open(szLogFile,(etDiagLevel)iScreenLogLevel,(etDiagLevel)iFileLogLevel,true))
		{
		printf("\nError: Unable to start diagnostics subsystem.");
		if(szLogFile[0] != '\0')
			printf(" Most likely cause is that logfile '%s' can't be opened/created",szLogFile);
		exit(1);
		}

// show user current resource limits
#ifndef _WIN32
	gDiagnostics.DiagOut(eDLInfo, gszProcName, "Resources: %s",CUtility::ReportResourceLimits());
#endif

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Version: %s Processing parameters:",kit4bversion);
	const char *pszDescr;
	switch(PMode) {
		case ePMpaired:
			pszDescr = "paired reads @ 147 +/- 20bp";
			break;
		case ePMfulllength:
			pszDescr = "full length @ 147 +/- 20bp";
			break;
		case ePMunpaired:
			pszDescr = "unpaired reads extended to 147";
			break;
		}
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Processing mode is : '%s'",pszDescr);	
	switch(FMode) {
		case eFMbedGraphDyads:				
			pszDescr = "UCSC bedGraph dyads";
			break;
		case eFMbedDyads:					
			pszDescr = "UCSC BED dyads";
			break;
		case eFMcsvDyads:					
			pszDescr = "CSV dyads";
			break;
		case eFMbedGraphNucs:					
			pszDescr = "UCSC bedGraph nucleosomes";
			break;
		case eFMbedNucs:					
			pszDescr = "UCSC BED nucleosomes";
			break;
		case eFMcsvNucs:					
			pszDescr = "CSV nucleosomes";
			break;
		case eFMMNaseScore:					
			pszDescr = "CSV MNase score distribution";
			break;
		case eFMMcsvScores:					
			pszDescr = "CSV dyad scores along genome";
			break;

		}
	
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"output format is : '%s'",pszDescr);

	gDiagnostics.DiagOutMsgOnly(eDLInfo,"moving average filter width : %d",MovAvgFilter);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"baseline noramlisation width : %d",BaselineFilter);

	if(FMode != eFMMNaseScore)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"track title: '%s'",szTrackTitle);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"input aligned short reads file: '%s'",szInFile);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"output predicted %s file: '%s'",FMode == eFMMNaseScore ? "MNase score distribution" : FMode <= eFMcsvDyads ? "dyads" : "nucleosomes", szRsltsFile);
	gDiagnostics.DiagOutMsgOnly(eDLInfo,"Normalise dyad scores for MNase biases: '%s'",bBiasMNase ? "Yes" : "No");
	if(FMode == eFMMNaseScore || bBiasMNase == true)
		{
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"score from this MNase selectivity file: '%s'",szInMNaseFile);
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"score MNase using genome file: '%s'",szInGenomeFile);
		}

	for(Idx = 0; Idx < NumIncludeChroms; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"reg expressions defining chroms to include: '%s'",pszIncludeChroms[Idx]);
	for(Idx = 0; Idx < NumExcludeChroms; Idx++)
		gDiagnostics.DiagOutMsgOnly(eDLInfo,"reg expressions defining chroms to exclude: '%s'",pszExcludeChroms[Idx]); 


#ifdef _WIN32
	SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);
#endif
	gStopWatch.Start();
	Rslt = Process(PMode,FMode,MovAvgFilter,BaselineFilter,szTrackTitle,szInFile,bBiasMNase,szInMNaseFile,szInGenomeFile,szRsltsFile,NumIncludeChroms,pszIncludeChroms,NumExcludeChroms,pszExcludeChroms);
	gStopWatch.Stop();
	Rslt = Rslt >=0 ? 0 : 1;
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Exit code: %d Total processing time: %s",Rslt,gStopWatch.Read());
	exit(Rslt);
	}
else
	{
	printf("\n%s Predict Nucleosomes from Aligned Reads, Version %s\n",gszProcName,kit4bversion);
	arg_print_errors(stdout,end,gszProcName);
	arg_print_syntax(stdout,argtable,"\nUse '-h' to view option and parameter usage\n");
	exit(1);
	}
return 0;
}

void
Reset(void)
{
if(m_pCSVAligns != NULL)
	{
	delete m_pCSVAligns;
	m_pCSVAligns = NULL;
	}
if(m_pBEDAligns != NULL)
	{
	delete m_pBEDAligns;
	m_pBEDAligns = NULL;
	}
if(m_pAlignHits != NULL)
	{
	delete m_pAlignHits;
	m_pAlignHits = NULL;
	}
if(m_ppAlignHitsIdx != NULL)
	{
	delete m_ppAlignHitsIdx;
	m_ppAlignHitsIdx = NULL;
	}
if(m_pBioSeqFile != NULL)
	{
	delete m_pBioSeqFile;
	m_pBioSeqFile = NULL;
	}
if(m_pChromSeq != NULL)
	{
	delete m_pChromSeq;
	m_pChromSeq = NULL;
	}
if(m_pMNaseSel != NULL)
	{
	delete m_pMNaseSel;
	m_pMNaseSel = NULL;
	}
if(m_pMNaseCSV != NULL)
	{
	delete m_pMNaseCSV;
	m_pMNaseCSV = NULL;
	}
m_AllocdChromSeq = 0;				// allocated assembly chromosome sequence length
m_ChromSeqLen = 0;					// current assembly chromosome sequence length
m_NumAlignHits = 0;					// m_pAlignHits contains this many reads
m_FinalReadID = 0;	
m_MinMNaseScore = 10000;
m_MaxMNaseScore = 0;
memset(m_MNaseScoreHist,0,sizeof(m_MNaseScoreHist));
}

void
Init(void)
{
m_pAlignHits = NULL;
m_ppAlignHitsIdx = NULL;
m_pCSVAligns = NULL;		// used if loading aligned reads from csv file
m_pBEDAligns = NULL;		// used if loading aligned reads from BED file
m_pBioSeqFile = NULL;		// holds instantiated genome assembly sequences, used if MNase scoring
m_pChromSeq = NULL;			// holds current assembly chromosome sequence, used if MNase scoring
m_pMNaseSel = NULL;			// allocated array of MNase site selection preferences (0.0..1.0) indexed by sequence octamers
m_pMNaseCSV = NULL;			// used to hold DNase site preferences whilst loading into m_pMNaseSel 
Reset();
memset(m_MNaseScoreHist,0,sizeof(m_MNaseScoreHist));
}




int
GenSeqIdx(int SeqLen,etSeqBase *pSeq)
{
int Idx;
int SeqIdx;
int Base;
for(Idx=SeqIdx=0; Idx < SeqLen; Idx++,pSeq++)
	{
	Base = *pSeq & ~cRptMskFlg;
	if(Base > eBaseT)
		return(-1);
	SeqIdx <<= 2;
	SeqIdx |= Base;
	}
return(SeqIdx);
}

char *
StepIdx2Seq(int SeqLen,int SeqIdx)
{
static char szSeqBuff[256];
char *pChr;
int Base;
int Idx;

szSeqBuff[SeqLen] = '\0';
pChr = &szSeqBuff[SeqLen-1];
for(Idx=0; Idx < SeqLen; Idx++,pChr--)
	{
	Base = SeqIdx & 0x03;
	switch(Base) {
		case 0: *pChr = 'a'; break;
		case 1: *pChr = 'c'; break;
		case 2: *pChr = 'g'; break;
		case 3: *pChr = 't'; break;
		}
	SeqIdx >>= 2;
	}
return(szSeqBuff);
}

int					// 0 if filtered out, 1 if alignment accepted, < 0 if errors
AddAlignedRead(int ReadID,char *pszChromName,int Loci,int ReadLen,char Strand)
{
int Idx;
tsAlignHit *pAlignHit;
bool bProcChrom;
#ifdef _WIN32
RegexpMatch mc;
#else
regmatch_t mc;
int RegErr;				// regular expression parsing error
char szRegErr[128];			// to hold RegErr as textual representation ==> regerror();
#endif
// check if this chromosome to be processed

bProcChrom = true;
for(Idx = 0; Idx < m_NumExcludeChroms; Idx++)
#ifdef _WIN32	
	if(m_ExcludeChromsRE[Idx]->Match(pszChromName,&mc))
#else
	if(!regexec(&m_ExcludeChromsRE[Idx],pszChromName,1,&mc,0))
#endif
		{
		bProcChrom = false;
		break;
		}

if(bProcChrom && m_NumIncludeChroms > 0)
	{
	bProcChrom = false;
	for(Idx = 0; Idx < m_NumIncludeChroms; Idx++)
		{
#ifdef _WIN32
		if(m_IncludeChromsRE[Idx]->Match(pszChromName,&mc))
#else
		if(!regexec(&m_IncludeChromsRE[Idx],pszChromName,1,&mc,0))
#endif
			{
			bProcChrom = true;
			break;
			}
		}
	}
	
if(!bProcChrom)
	return(0);

		// need to allocate more memory?
if(m_NumAlignHits >= m_AllocdAlignHits)
	{
	pAlignHit = (tsAlignHit *) new tsAlignHit [m_AllocdAlignHits + cReadsReAlloc];	
	if(pAlignHit == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"AddAlignedRead: Memory re-allocation to %d bytes - %s",(m_AllocdAlignHits + cReadsReAlloc) * sizeof(tsAlignHit),strerror(errno));
		Reset();
		return(eBSFerrMem);
		}

	memcpy(pAlignHit,m_pAlignHits,m_NumAlignHits*sizeof(tsAlignHit));
	delete m_pAlignHits;
	m_pAlignHits = pAlignHit;
	m_AllocdAlignHits += cReadsReAlloc;
	}

pAlignHit = &m_pAlignHits[m_NumAlignHits++];
memset(pAlignHit,0,sizeof(tsAlignHit));
pAlignHit->ReadID = ReadID;
pAlignHit->AlignLen = ReadLen;
strcpy(pAlignHit->szChromName,pszChromName);
pAlignHit->Loci = Loci;
pAlignHit->Strand = Strand;
pAlignHit->Processed = 0;
m_FinalReadID = ReadID;
return(1);
}

int
LoadAlignedCSV(char *pszInFile)
{
int Rslt;
int NumFields;
int NumExclReads;
int NumProcessed;
int ReadID;
int ReadLen;
char *pszTargSpecies;
char *pszChromName;
int Loci;
char *pszStrand;

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading aligned reads from CSV file: %s",pszInFile);

if(m_pCSVAligns != NULL)
	delete m_pCSVAligns;

// load into memory
if((m_pCSVAligns = new CCSVFile) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CCSVfile");
	return(eBSFerrObj);
	}
m_pCSVAligns->SetMaxFields(8);	// require at most 8 fields in reads alignment CSV file
if((Rslt=m_pCSVAligns->Open(pszInFile))!=eBSFSuccess)
	{
	while(m_pCSVAligns->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pCSVAligns->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open file: %s",pszInFile);
	Reset();
	return(Rslt);
	}

NumExclReads = 0;
NumProcessed = 0;
while((Rslt=m_pCSVAligns->NextLine()) > 0)	// onto next line containing fields
	{
	if(!(NumProcessed % 100000))
		{
		if(!NumProcessed)
			printf("\n     processing read alignment %8.8d",NumProcessed);
		else
			printf("\b\b\b\b\b\b\b\b%8.8d",NumProcessed);
		}

	NumFields = m_pCSVAligns->GetCurFields();
	if(NumFields < 8)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"file: %s contains %d fields, expected at least %d",pszInFile,NumFields,8);
		Reset();
		return(eBSFerrParams);
		}

	if(!NumProcessed && m_pCSVAligns->IsLikelyHeaderLine())
		continue;

	NumProcessed += 1;

	m_pCSVAligns->GetInt(1,&ReadID);
	m_pCSVAligns->GetText(3,&pszTargSpecies);
	m_pCSVAligns->GetText(4,&pszChromName);
	m_pCSVAligns->GetInt(5,&Loci);
	m_pCSVAligns->GetInt(7,&ReadLen);
	m_pCSVAligns->GetText(8,&pszStrand); 
	Rslt =	AddAlignedRead(ReadID,pszChromName,Loci,ReadLen,*pszStrand);
	switch(Rslt) {
		case 0:
			NumExclReads += 1;
			break;
		case 1:
			break;
		default:
			Reset();
			return(Rslt);
		}
	}
delete m_pCSVAligns;
m_pCSVAligns = NULL;
printf("\b\b\b\b\b\b\b\b%8.8d",NumProcessed);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedCSV: Processed %d alignments of which %d were filtered, accepted %d",NumProcessed,NumExclReads,m_NumAlignHits);
return(m_NumAlignHits);
}

int LoadAlignedBED(char *pszInFile)		// load aligned reads from this file
{
int Rslt;
int CurFeatureID;
int StartLoci;
int EndLoci;
int Score;
char szFeatName[128];
char szChrom[128];
char Strand;
int NumProcessed;
int NumExclAlignments;

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading read alignments from BED file: %s",pszInFile);

if(m_pBEDAligns != NULL)
	delete m_pBEDAligns;
if((m_pBEDAligns = new CBEDfile)==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CBEDfile");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt=m_pBEDAligns->Open(pszInFile,eBTAnyBed)) != eBSFSuccess)
	{
	while(m_pBEDAligns->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pBEDAligns->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open '%s' for processing",pszInFile);
	Reset();
	return(eBSFerrOpnFile);
	}
gDiagnostics.DiagOut(eDLInfo,gszProcName,"Load completed, iterating alignments...");

// now iterate over the alignments 
CurFeatureID = 0;
Rslt = eBSFSuccess;
NumProcessed = 0;
NumExclAlignments = 0;
while(Rslt == eBSFSuccess && (CurFeatureID = m_pBEDAligns->GetNextFeatureID(CurFeatureID)) > 0)
	{
	NumProcessed += 1;
	m_pBEDAligns->GetFeature(CurFeatureID,	// feature instance identifier
				szFeatName,				// where to return feature name
				szChrom,				// where to return chromosome name
				&StartLoci,				// where to return feature start on chromosome (0..n) 
				&EndLoci,				// where to return feature end on chromosome
 				&Score,					// where to return score
 				&Strand);				// where to return strand
	CurFeatureID += 1;
	Rslt =	AddAlignedRead(CurFeatureID,szChrom,StartLoci,1+EndLoci-StartLoci,Strand);
	switch(Rslt) {
		case 0:
			NumExclAlignments += 1;
			break;
		case 1:
			Rslt = 0;
			break;
		default:
			Reset();
			return(Rslt);
		}
	}
printf("\b\b\b\b\b\b\b\b%8.8d",NumProcessed);
gDiagnostics.DiagOut(eDLInfo,gszProcName,"LoadAlignedBED: Processed %d alignments of which %d were filtered, accepted %d",NumProcessed,NumExclAlignments,m_NumAlignHits);
return(m_NumAlignHits);
}

// GetFileType
// First determines if the file is actually read accessiable
// Then assumes the file type from it's extension and returns same
// returns:
// < 0 if errors accessing the file for read
typedef enum TAG_eFileTypeExtns {
	eFTerrors = -1,		// errors accessing the file
	eFTindeterminate=0,	// unable to determine file type
	eFTBedExtn,			// file extension is .bed
	eFTbsbExtn,			// file extension is .bsb
	eFTseqExtn,			// file extension is .seq
	eFTsfxExtn,			// file extension is .sfx
	eFTcsvExtn,			// file extension is .csv
	eFTfastaExtn,		// file extension for fasta
	eFTfastqExtn,		// file extension for fastq
} teFileTypeExtns;

teFileTypeExtns
GetFileType(char *pszInFile)
{
int hFile;
int Len;
UINT8 Buff[10];

// try to actually open file
hFile = open(pszInFile,O_READSEQ);
if(hFile == -1)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open %s for reading - %s",pszInFile,strerror(errno));
	Reset();
	return(eFTerrors);
	}

// at least file does exist!
// try reading it
Len = read(hFile,Buff,sizeof(Buff));
close(hFile);
if(Len < sizeof(Buff))
	{
	if(Len < 0)
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"%s exists but errors whilst reading - %s",pszInFile,strerror(errno));
	else
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"%s exists but of insufficent length - %d",pszInFile,Len);
	Reset();
	return(eFTerrors);
	}
// now try and determine file type from it's extension
Len = (int)strlen(pszInFile);
while(Len > 2 && pszInFile[Len-1] != '.')
	Len -= 1;
if(Len < 2)
	return(eFTindeterminate);
if(!stricmp(&pszInFile[Len],"bed"))
   return(eFTBedExtn);
if(!stricmp(&pszInFile[Len],"bsb"))
   return(eFTbsbExtn);
if(!stricmp(&pszInFile[Len],"seq"))
   return(eFTseqExtn);
if(!stricmp(&pszInFile[Len],"sfx"))
   return(eFTsfxExtn);
if(!stricmp(&pszInFile[Len],"csv"))
   return(eFTcsvExtn);
if(!stricmp(&pszInFile[Len],"fa") || !stricmp(&pszInFile[Len+1],"fasta"))
   return(eFTfastaExtn);
if(!stricmp(&pszInFile[Len],"fastq"))
   return(eFTfastqExtn);
return(eFTindeterminate);	
}

int
LoadReads(char *pszInFile,				// load reads from this file, could be either CSV or BED format
		    int NumIncludeChroms,		// number of chromosomes explicitly defined to be included
			char **ppszIncludeChroms,	// ptr to array of reg expressions defining chroms to include - overides exclude
			int NumExcludeChroms,		// number of chromosomes explicitly defined to be excluded
			char **ppszExcludeChroms)	// ptr to array of reg expressions defining chroms to exclude
{
int Rslt;
int BuffLen = 0;
int BuffOfs = 0;
m_NumAlignHits = 0;
int Idx;
m_NumIncludeChroms = 0;
m_NumExcludeChroms = 0;
#ifdef _WIN32
RegexpMatch mc;
try {
	for(Idx=0;Idx < NumIncludeChroms;Idx++)
		{
		m_IncludeChromsRE[Idx] = new Regexp();
		m_NumIncludeChroms += 1;
		m_IncludeChromsRE[Idx]->Parse(ppszIncludeChroms[Idx],false);	// note case insensitive
		}
	}
catch(...)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process include regexpr chrom '%s'",ppszIncludeChroms[Idx]);
	return(eBSFerrMem);
	}
try {
	for(Idx=0;Idx < NumExcludeChroms;Idx++)
		{
		m_ExcludeChromsRE[Idx] = new Regexp();
		m_NumExcludeChroms += 1;
		m_ExcludeChromsRE[Idx]->Parse(ppszExcludeChroms[Idx],false);	// note case insensitive
		}
	}
catch(...)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process exclude regexpr chrom '%s'",ppszExcludeChroms[Idx]);
	return(eBSFerrMem);
	}

#else
regmatch_t mc;
int RegErr;				// regular expression parsing error
char szRegErr[128];			// to hold RegErr as textual representation ==> regerror();

for(Idx=0;Idx < NumIncludeChroms;Idx++)
	{

	RegErr=regcomp(&m_IncludeChromsRE[Idx],ppszIncludeChroms[Idx],REG_EXTENDED | REG_ICASE);	// note case insensitive
	if(RegErr)
		{
		regerror(RegErr,&m_IncludeChromsRE[Idx],szRegErr,sizeof(szRegErr));
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process include chrom '%s' error: %s",ppszIncludeChroms[Idx],szRegErr);
		return(eBSFerrMem);
		}
	m_NumIncludeChroms += 1;
	}
for(Idx=0;Idx < NumExcludeChroms;Idx++)
	{
	RegErr = regcomp(&m_IncludeChromsRE[Idx],ppszExcludeChroms[Idx],REG_EXTENDED | REG_ICASE);	// note case insensitive
	if(RegErr)
		{
		regerror(RegErr,&m_ExcludeChromsRE[Idx],szRegErr,sizeof(szRegErr));
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to process exclude chrom '%s' error: %s",ppszExcludeChroms[Idx],szRegErr);
		return(eBSFerrMem);
		}
	m_NumExcludeChroms += 1;
	}
#endif

if(m_pAlignHits == NULL)		// initial allocation required?
	{
	m_pAlignHits = (tsAlignHit *) new tsAlignHit [cReadsInitalAlloc];	// initial allocation
	if(m_pAlignHits == NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory allocation of %d bytes - %s",cReadsInitalAlloc*sizeof(tsAlignHit),strerror(errno));
		return(eBSFerrMem);
		}
	m_AllocdAlignHits = cReadsInitalAlloc;
	m_NumAlignHits = 0;
	}

Rslt = GetFileType(pszInFile);		// take best guess at file type
if(Rslt < 0)
	{
	Reset();
	return(Rslt);
	}

switch(Rslt) {
	case 0:							// can't determine type
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to determine input file type as CSV or BED");
		Reset();
		return(-1);
		
	case eFTBedExtn:							// BED
	case eFTbsbExtn:							// processed BED
		Rslt = LoadAlignedBED(pszInFile);
		break;
	case eFTcsvExtn:							// CSV
		Rslt = LoadAlignedCSV(pszInFile);
		break;
	default:
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unsupported input file type - must be either '.bed' or '.csv'");
		Reset();
		return(-1);
	}

if(Rslt < 0)
	{
	Reset();
	return(Rslt);
	}
// finally, create sorted index by chrom, loci, strand over loaded reads
if(Rslt > 0)
	Rslt = SortAlignHits(eRSMHitMatch);
return(Rslt);
}


int
InitMNaseSitePrefs(char *pszInMNaseFile,			// optionally also score from this MNase site selectivity file (generated by MNaseSitePred process)
		char *pszInBioseqFile)				// if scoring on MNase selectivity then also need the bioseq genome file
{
int Rslt;
int NumProcessed;
int NumFields;
int OctIdx;
char *pszOctamer;
etSeqBase Octamer[9];
double SitePref;

gDiagnostics.DiagOut(eDLInfo,gszProcName,"Loading MNase site selection preferences from file: %s",pszInMNaseFile);

m_pMNaseSel = (double *) new double [0x010000];	// to hold 4^8 (octamer) site preferences
if(m_pMNaseSel == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"LoadReads: Memory allocation for MNase site preferences of 64k doubles failed");
	Reset();
	return(eBSFerrMem);
	}
for(OctIdx = 0; OctIdx < 0x010000; OctIdx++)
	m_pMNaseSel[OctIdx] = 0.0f;

if((m_pMNaseCSV = new CCSVFile) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CCSVfile");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt=m_pMNaseCSV->Open(pszInMNaseFile))!=eBSFSuccess)
	{
	while(m_pMNaseCSV->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pMNaseCSV->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open file: %s",pszInMNaseFile);
	Reset();
	return(Rslt);
	}
NumProcessed = 0;
while((Rslt=m_pMNaseCSV->NextLine()) > 0)	// onto next line containing fields
	{
	NumFields = m_pMNaseCSV->GetCurFields();
	if(NumFields < 4)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"file: %s contains % fields, expected at least 4",pszInMNaseFile,NumFields);
		Reset();
		return(eBSFerrParams);
		}
	if(!NumProcessed && m_pMNaseCSV->IsLikelyHeaderLine())
		continue;
	NumProcessed += 1;
	m_pMNaseCSV->GetText(1,&pszOctamer);
	memcpy(Octamer,CSeqTrans::MapAscii2Sense(pszOctamer),8);
	OctIdx = GenSeqIdx(8,Octamer);
	m_pMNaseCSV->GetDouble(4,&SitePref);
	m_pMNaseSel[OctIdx] = SitePref;
	}
delete m_pMNaseCSV;
m_pMNaseCSV = NULL;

if((m_pBioSeqFile = new CBioSeqFile) == NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to instantiate CBioSeqFile object");
	Reset();
	return(eBSFerrObj);
	}

if((Rslt = m_pBioSeqFile->Open(pszInBioseqFile))!=eBSFSuccess)
	{
	while(m_pBioSeqFile->NumErrMsgs())
		gDiagnostics.DiagOut(eDLFatal,gszProcName,m_pBioSeqFile->GetErrMsg());
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to open genome assembly sequence file '%s'",pszInBioseqFile);
	Reset();
	return(Rslt);
	}
return(Rslt);
}

// MNaseScore
// Returns the probabilty of the sequence starting at StartLoci and of length SeqLen being cut by
// MNase assuming a parallel system of independent probalistic MNase cut events whereby the occurance of any
// of these events would have resulted in the sequence being cut
// The probablity is returned as a double in the range 0.0 to 1.0 or -1.0 if errors
double
MNaseSeqScore(char *pszChrom, int StartLoci, int SeqLen)
{
static int ChromID = -1;
static char szCurChrom[cMaxDatasetSpeciesChrom];
int Rslt;
double MNaseScore;
int iScore;
etSeqBase *pSeq;
int Ofs;
int OctIdx;

MNaseScore = 0.0f;
if(m_pMNaseSel == NULL || m_pBioSeqFile == NULL)		// if no MNase cut probs to utilise..
	return(0.0);
if(ChromID == -1 || stricmp(pszChrom,szCurChrom))
	{
	strcpy(szCurChrom,pszChrom);
	if((ChromID = m_pBioSeqFile->LocateEntryIDbyName(szCurChrom)) < 1)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to locate chromosome '%s' in bioseq genome file",szCurChrom);
		return(-1.0);
		}
	m_ChromSeqLen = m_pBioSeqFile->GetDataLen(ChromID);
	if(m_pChromSeq == NULL || m_ChromSeqLen >= m_AllocdChromSeq)
		{
		if(m_pChromSeq != NULL)
			{
			delete m_pChromSeq;
			m_pChromSeq = NULL;
			m_AllocdChromSeq = 0;
			}
		if((m_pChromSeq = new etSeqBase [m_ChromSeqLen + cReadsReAlloc]) == NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate memory for chromosome sequence of %d bytes",m_ChromSeqLen + cReadsReAlloc);
			return(-1.0);
			}
		m_AllocdChromSeq = m_ChromSeqLen + cReadsReAlloc;
		}
	if((Rslt=m_pBioSeqFile->GetData(ChromID,eSeqBaseType,0,m_pChromSeq,m_ChromSeqLen))!=m_ChromSeqLen)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to load chromosome sequence for '%s' of expected length",szCurChrom,m_ChromSeqLen);
		return(-1.0);
		}
	}
// chromosome sequence is now in memory, start scoring
// simply slide octamer window over sequence starting from StartLoci, and multiply (1-scores) to get the expected probability 
// of at least one MNase site cut for that sequence. 
// MNaseScore = 1.0
// for each octamer
//     MNaseScore *= 1 - m_pMNaseSel[octamer]
// MNaseScore = 1.0 - MNaseScore
MNaseScore = 1.0f;
pSeq = &m_pChromSeq[StartLoci];
for(Ofs = 0; Ofs+7 < SeqLen; Ofs++,pSeq++)
	{
	OctIdx = GenSeqIdx(8,pSeq);
	if(OctIdx >= 0)		// -1 if seq contained 'n' 
		MNaseScore *= 1.0 - m_pMNaseSel[OctIdx];
	}
MNaseScore = 1.0 - MNaseScore;
iScore = (int)(10000*MNaseScore);
if(iScore > m_MaxMNaseScore)
	m_MaxMNaseScore = iScore;
if(iScore < m_MinMNaseScore)
	m_MinMNaseScore = iScore;
m_MNaseScoreHist[iScore/10] += 1;
return(MNaseScore);
}

// DyadScore
// returns score to associate with dyad
const int cDyadScores[] = {1,1,1,2,3,3,2,1,1,1};				// base score per psn
int
DyadScore(int Psn)						// psn (0..n) in aligment being scored
{
if(Psn < 0 || Psn >= 10)			    // only score if within 1st 10nt of alignment
	return(0);
return(cDyadScores[Psn]);
}

static int m_NumEls = 0;

double 
Log2(double a)
{
return log(a) / log(2.0);
}

// Simple inplace moving average filter for smoothing
int
MoveAvgFilter(int WinSize,int ValueLen,int *pValues)
{
int WinValues[8196];
int WinIdx;
int Idx;
int Sum;
int *pAvg;

if(ValueLen < 10)
	return(0);

if(WinSize > 8196)
	WinSize = 8196;
else
	if(WinSize < 5)
		WinSize = 5;

if(ValueLen < WinSize)
	WinSize = ValueLen;

Sum = 0;

// leadin..
WinIdx = 0;
pAvg = pValues;
for(Idx = 0; Idx < WinSize/2; Idx++)
	{
	WinValues[WinIdx++] = *pValues;
	Sum += *pValues++;
	}
for(; Idx < WinSize; Idx++)
	{
	*pAvg++ = Sum/Idx;
	WinValues[WinIdx++] = *pValues;
	Sum += *pValues++;
	}
WinIdx %= WinSize;
for(; Idx < ValueLen; Idx++)
	{
	*pAvg++ = Sum/WinSize;
	Sum -= WinValues[WinIdx];
	WinValues[WinIdx++] = *pValues;
	Sum += *pValues++;
	WinIdx %= WinSize;
	}

// lead out
for(Idx = 0; Idx < (WinSize - WinSize/2); Idx++)
	{
	*pAvg++ = Sum/(WinSize - Idx);
	Sum -= WinValues[WinIdx++];
	WinIdx %= WinSize;
	}
return(1);
}

// Simple inplace base line correction
// determines baseline through a wide moving average filter and then subtracts baseline from values
int
BaselineCorrection(int WinSize,int ValueLen,int *pValues)
{
int WinValues[8196];
int WinIdx;
int Idx;
int Sum;
int *pAvg;
int Baseline;

if(ValueLen < 10)
	return(0);

if(WinSize > 8196)
	WinSize = 8196;
else
	if(WinSize < 5)
		WinSize = 5;

if(ValueLen < WinSize)
	WinSize = ValueLen;

Sum = 0;

// leadin..
WinIdx = 0;
pAvg = pValues;
for(Idx = 0; Idx < WinSize/2; Idx++)
	{
	WinValues[WinIdx++] = *pValues;
	Sum += *pValues++;
	}
for(; Idx < WinSize; Idx++)
	{
	Baseline = Sum/Idx;
	if(*pAvg <= Baseline)
		*pAvg++ = 0;
	else
		*pAvg++ -= Baseline;
	WinValues[WinIdx++] = *pValues;
	Sum += *pValues++;
	}
WinIdx %= WinSize;
for(; Idx < ValueLen; Idx++)
	{
	Baseline = Sum/WinSize;
	if(*pAvg <= Baseline)
		*pAvg++ = 0;
	else
		*pAvg++ -= Baseline;
	Sum -= WinValues[WinIdx];
	WinValues[WinIdx++] = *pValues;
	Sum += *pValues++;
	WinIdx %= WinSize;
	}

// lead out
for(Idx = 0; Idx < (WinSize - WinSize/2); Idx++)
	{
	Baseline = Sum/(WinSize - Idx);
	if(*pAvg <= Baseline)
		*pAvg++ = 0;
	else
		*pAvg++ -= Baseline;
	Sum -= WinValues[WinIdx++];
	WinIdx %= WinSize;
	}
return(1);
}


int
OutputDyads(int hFile,					// results file
			etFMode FMode,				// output format mode
			int MovAvgFilt,				// apply this width moving average filter
			int BaselineFilter,			// use this window size when normalising for baseline
			char *pszTrackName,			// track name
			char *pszCurChromName,		// dyads on this chromosome
			int MaxDyadLoci,			// last dyad loci
			int *pDyadScores)			// dyad scores
{
int Rslt;
char szBuff[4096];
int BuffIdx;
int CurDyadLoci;
int StartDyadLoci;
int CurDyadScore;
int PeakScore;
BuffIdx = 0;

if(MovAvgFilt > 0)
	MoveAvgFilter(MovAvgFilt,MaxDyadLoci,pDyadScores);
if(BaselineFilter > 0)
	BaselineCorrection(BaselineFilter,MaxDyadLoci,pDyadScores);
	
if(FMode == eFMMcsvScores)
	{
	for(CurDyadLoci = 0; CurDyadLoci <= MaxDyadLoci; CurDyadLoci += 1)
		{
		CurDyadScore = pDyadScores[CurDyadLoci];

		BuffIdx += sprintf(&szBuff[BuffIdx],"%s,%d,%d\n",pszCurChromName,CurDyadLoci,CurDyadScore);
		if((BuffIdx + 500) > sizeof(szBuff))
			{
			if((Rslt=write(hFile,szBuff,BuffIdx))!=BuffIdx)
				return(eBSFerrWrite);
			BuffIdx = 0;
			}
		}
	if((BuffIdx + 500) > sizeof(szBuff))
		{
		if((Rslt=write(hFile,szBuff,BuffIdx))!=BuffIdx)
			return(eBSFerrWrite);
		BuffIdx = 0;
		}
	return(eBSFSuccess);
	}

StartDyadLoci = -1;
PeakScore = 0;
for(CurDyadLoci = 0; CurDyadLoci <= MaxDyadLoci; CurDyadLoci += 1)
	{
	CurDyadScore = pDyadScores[CurDyadLoci];
	if(CurDyadScore <= 0 && StartDyadLoci == -1)
		continue;
	if(CurDyadScore >= PeakScore) 
		{
		if(CurDyadScore > PeakScore)
			{
			StartDyadLoci = CurDyadLoci;
			PeakScore = CurDyadScore;
			}
		continue;
		}
	// past local peak?
	if(StartDyadLoci != -1)
		{
		PeakScore = (int)(10.0 * Log2((double)PeakScore));
		if(StartDyadLoci > 73)
			{
			switch(FMode) {
				case eFMbedDyads:
					BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%s\t%d\n",pszCurChromName,StartDyadLoci,CurDyadLoci,pszTrackName,PeakScore);
					break;	
				case eFMbedGraphDyads:
					BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%d\n",pszCurChromName,StartDyadLoci,CurDyadLoci,PeakScore);
					break;
				case eFMcsvDyads:
					BuffIdx += sprintf(&szBuff[BuffIdx],"%d,Dyad,%s,%s,%d,%d,%d,%d\n",++m_NumEls,pszTrackName,pszCurChromName,StartDyadLoci,CurDyadLoci-1,CurDyadLoci-StartDyadLoci,PeakScore);
					break;

				case eFMbedNucs:
					BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%s\t%d\n",pszCurChromName,StartDyadLoci-73,CurDyadLoci+73,pszTrackName,PeakScore);
					break;
				case eFMbedGraphNucs:
					BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%d\n",pszCurChromName,StartDyadLoci-73,CurDyadLoci+73,PeakScore);
					break;
				case eFMcsvNucs:
					BuffIdx += sprintf(&szBuff[BuffIdx],"%d,Nucleosome,%s,%s,%d,%d,%d,%d\n",++m_NumEls,pszTrackName,pszCurChromName,StartDyadLoci-73,CurDyadLoci+72,146+CurDyadLoci-StartDyadLoci,PeakScore);
					break;
				}
			if((BuffIdx + 500) > sizeof(szBuff))
				{
				if((Rslt=write(hFile,szBuff,BuffIdx))!=BuffIdx)
					return(eBSFerrWrite);
				BuffIdx = 0;
				}
			}
		StartDyadLoci = -1;
		}
	PeakScore = (CurDyadScore * 110) / 100;			// allow 10% so as to provide some hysteresis
	}

if(StartDyadLoci != -1)
	{
	PeakScore = (int)(10.0 * Log2((double)PeakScore));
	switch(FMode) {
		case eFMbedDyads:
			BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%s\t%d\n",pszCurChromName,StartDyadLoci,CurDyadLoci,pszTrackName,PeakScore);
			break;	
		case eFMbedGraphDyads:
			BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%d\n",pszCurChromName,StartDyadLoci,CurDyadLoci,PeakScore);
			break;
		case eFMcsvDyads:
			BuffIdx += sprintf(&szBuff[BuffIdx],"%d,Dyad,%s,%s,%d,%d,%d,%d\n",++m_NumEls,pszTrackName,pszCurChromName,StartDyadLoci,CurDyadLoci-1,CurDyadLoci-StartDyadLoci,PeakScore);
			break;

		case eFMbedNucs:
			BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%s\t%d\n",pszCurChromName,StartDyadLoci-73,CurDyadLoci+73,pszTrackName,PeakScore);
			break;
		case eFMbedGraphNucs:
			BuffIdx += sprintf(&szBuff[BuffIdx],"%s\t%d\t%d\t%d\n",pszCurChromName,StartDyadLoci-73,CurDyadLoci+73,PeakScore);
			break;
		case eFMcsvNucs:
			BuffIdx += sprintf(&szBuff[BuffIdx],"%d,Nucleosome,%s,%s,%d,%d,%d,%d\n",++m_NumEls,pszTrackName,pszCurChromName,StartDyadLoci-73,CurDyadLoci+72,146+CurDyadLoci-StartDyadLoci,PeakScore);
			break;
		}		
	}

if(BuffIdx)
	if((Rslt=write(hFile,szBuff,BuffIdx))!=BuffIdx)
		return(eBSFerrWrite);
return(eBSFSuccess);
}

// locate a paired read which is near to 147bp away from the reference read
// returns nearest paired read or NULL if unable to locate read within +/- 20bp
tsAlignHit *
FindPaireedRead(tsAlignHit *pRefAlignHit)
{
int NucLen;
int PairNucLen;
tsAlignHit *pCurAlignHit;
tsAlignHit *pPairAlignHit;

pPairAlignHit = NULL;
PairNucLen = -1;
NucLen = -1;
pCurAlignHit = pRefAlignHit;
if(pRefAlignHit->Strand == '+')		// if on '+' strand then look ahead for at least one match on '-' strand
	{
	while((pCurAlignHit = IterSortedReads(pCurAlignHit, true))!=NULL)
		{
		if(pCurAlignHit->ChromID != pRefAlignHit->ChromID)
			break;
		if(pCurAlignHit->Strand == '+')
			continue;

		// have a putative paired read on '-' strand....
		NucLen = pCurAlignHit->Loci +  pCurAlignHit->AlignLen - pRefAlignHit->Loci;
		if(NucLen > 165)					// nucleosome bound dsDNA would be too long?
			break;
		if(NucLen < 127)					// nucleosome bound dsDNA would be too short?
			continue;								
		if(pCurAlignHit->Processed == 1)	// can't accept, already paired
			continue;
		if(pPairAlignHit == NULL || (abs(147 - NucLen) < abs(147 - PairNucLen)))
			{
			pPairAlignHit = pCurAlignHit;
			PairNucLen = NucLen;
			}
		}
	}
else	// else need to look back for at least 1 match on '+' strand
	{
	while((pCurAlignHit = IterSortedReads(pCurAlignHit, false))!=NULL)
		{
		if(pCurAlignHit->ChromID != pRefAlignHit->ChromID)
			break;
		if(pCurAlignHit->Strand == '-')
			continue;
		// have a putative paired read on '+' strand....
		NucLen = pRefAlignHit->Loci +  pRefAlignHit->AlignLen - pCurAlignHit->Loci;
		if(NucLen > 165)					// nucleosome bound dsDNA would be too long?
			break;
		if(NucLen < 127)					// nucleosome bound dsDNA would be too short?
			continue;								
		if(pCurAlignHit->Processed == 1)	// can't accept, already paired
			continue;
		if(pPairAlignHit == NULL || (abs(147 - NucLen) < abs(147 - PairNucLen)))
			{
			pPairAlignHit = pCurAlignHit;
			PairNucLen = NucLen;
			}
		}
	}
return(pPairAlignHit);
}

int
Process(etPMode PMode,					// processing mode
		etFMode FMode,					// output format mode
		int MovAvgFilter,				// apply this moving average window size filter
		int BaselineFilter,				// baseline normalisation window size
		char *pszTrackName,				// UCSC track name
		char *pszInFile,				// file containing aligned short reads
		bool bBiaseMNmase,				// true if dyad scores to be normalised for MNase biases
		char *pszInMNaseFile,			// optionally also score from this MNase site selectivity file (generated by MNaseSitePred process)
		char *pszInBioseqFile,			// if scoring on MNase selectivity then also need the bioseq genome file
		char *pszOutFile,				// where to write nucleosome predictions
		int	NumIncludeChroms,			// number of chromosome regular expressions to include
		char **ppszIncludeChroms,		// array of include chromosome regular expressions
		int	NumExcludeChroms,			// number of chromosome expressions to exclude
		char **ppszExcludeChroms)		// array of exclude chromosome regular expressions
{
int Rslt;
int hFile;
int *pDyadScores;
tsAlignHit *pCurAlignHit;
tsAlignHit *pPairAlignHit;
int *pTmpDyadScores;
int AllocdDyads;
int MaxDyadLoci;
int CurDyadLoci;
char szCurChromName[cMaxDatasetSpeciesChrom];
UINT32 CurChromID;
int NumProcessed = 0;
int Unprocessed = 0;
int NucLen;
int Idx;
double MNaseScore;

Init();

if(FMode == eFMMNaseScore || bBiaseMNmase == true)
	{
	if((Rslt = InitMNaseSitePrefs(pszInMNaseFile,pszInBioseqFile)) < 0)
		{
		Reset();
		return(Rslt);
		}
	}

if((Rslt = LoadReads(pszInFile,NumIncludeChroms,ppszIncludeChroms,NumExcludeChroms,ppszExcludeChroms)) < eBSFSuccess)
	{
	Reset();
	return(Rslt);
	}

#ifdef _WIN32
if((hFile = open(pszOutFile, _O_RDWR | _O_BINARY | _O_SEQUENTIAL | _O_CREAT | _O_TRUNC, _S_IREAD | _S_IWRITE ))==-1)
#else
if((hFile = open(pszOutFile, O_RDWR | O_CREAT | O_TRUNC, S_IREAD | S_IWRITE ))==-1)
#endif
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to create predicted nucleosome output file: %s - %s",pszOutFile,strerror(errno));
	Reset();
	return(eBSFerrCreateFile);
	}

if(FMode == eFMbedGraphDyads)
	{
	char szBuff[2048];
	int BuffIdx;

	BuffIdx = sprintf(szBuff,
	 "track type=bedGraph name=\"%s\" description=\"%s\" visibility=full color=200,100,0 altColor=0,100,200 priority=20 autoScale=on alwaysZero=on graphType=bar smoothingWindow=4\n",
		pszTrackName,pszTrackName);
	CUtility::SafeWrite(hFile,szBuff,BuffIdx);
	}

if((pDyadScores = new int [cDyadsInitialAlloc])==NULL)
	{
	gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate %d bytes to hold dyad scores",cDyadsInitialAlloc * sizeof(int));
	close(hFile);
	Reset();
	return(eBSFerrMem);
	}
AllocdDyads = cDyadsInitialAlloc;
memset(pDyadScores,0,sizeof(int) * AllocdDyads);
pCurAlignHit = NULL;
MaxDyadLoci = -1;				// -1 whilst no nucleosome dyads on chromosome currently being processed
szCurChromName[0] = '\0';
CurChromID = 0;
NumProcessed = 0;
while((pCurAlignHit = IterSortedReads(pCurAlignHit, true))!=NULL)
	{
	if(!(NumProcessed % 10000))
		{
		if(!NumProcessed)
			printf("\n     processing aligned read %8.8d",NumProcessed);
		else
			printf("\b\b\b\b\b\b\b\b%8.8d",NumProcessed);
		}
	NumProcessed += 1;
	if(pCurAlignHit->Loci >= (UINT32)AllocdDyads)
		{
		if((pTmpDyadScores = new int [pCurAlignHit->Loci + cDyadsReAlloc])==NULL)
			{
			gDiagnostics.DiagOut(eDLFatal,gszProcName,"Unable to allocate %d bytes to hold dyad scores",(pCurAlignHit->Loci + cDyadsReAlloc) * sizeof(int));
			delete pDyadScores;
			close(hFile);
			return(eBSFerrMem);
			}
		AllocdDyads = pCurAlignHit->Loci + cDyadsReAlloc;
		memset(pTmpDyadScores,0,sizeof(int) * AllocdDyads);
		if(MaxDyadLoci > 0)
			{
			memcpy(pTmpDyadScores,pDyadScores,sizeof(int) * MaxDyadLoci);
			delete pDyadScores;
			}
		pDyadScores = pTmpDyadScores;
		}
	CurDyadLoci = -1;

	if(CurChromID == 0 || CurChromID == pCurAlignHit->ChromID) // first time or on same chromosome?
		{
		if(CurChromID == 0)	// if first time then make a copy of chromosome name
			{
			strcpy(szCurChromName,pCurAlignHit->szChromName);
			CurChromID = pCurAlignHit->ChromID;
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"Scoring dyads on chromosome: %s",szCurChromName);
			}

		// only process each accepted read once - relevant to paired reads processing
		if(pCurAlignHit->Processed)
			continue;

		switch(PMode) {
			case ePMpaired:							// reads expected to be paired at 147 +/- 20bp
				if((pPairAlignHit=FindPaireedRead(pCurAlignHit))!=NULL)
					{
					if(pCurAlignHit->Strand == '+')
						{
						NucLen = pPairAlignHit->Loci +  pPairAlignHit->AlignLen - pCurAlignHit->Loci;
						CurDyadLoci = pCurAlignHit->Loci + (NucLen/2) - 5;
						for(Idx=0;Idx < 10;Idx++)
							pDyadScores[CurDyadLoci++] += DyadScore(Idx);
						
						}
					else
						{
						NucLen = pCurAlignHit->Loci +  pCurAlignHit->AlignLen - pPairAlignHit->Loci; 
						CurDyadLoci = pPairAlignHit->Loci + (NucLen/2) - 5;
						for(Idx=0;Idx < 10;Idx++)
							pDyadScores[CurDyadLoci++] += DyadScore(Idx);
						}
					if(MaxDyadLoci < CurDyadLoci)
						MaxDyadLoci = CurDyadLoci;
					pCurAlignHit->Processed = 1;
					pPairAlignHit->Processed = 1;
					}
				break;

			case ePMfulllength:						// full length ~147 reads
				if(pCurAlignHit->AlignLen < 127 || pCurAlignHit->AlignLen > 167)	// don't bother with under/over length reads
					break;
				CurDyadLoci = pCurAlignHit->Loci + (pCurAlignHit->AlignLen/2) - 5;
				for(Idx=0;Idx < 10;Idx++)
					pDyadScores[CurDyadLoci++] += DyadScore(Idx);
				pCurAlignHit->Processed = 1;
				break;

			case ePMunpaired:					// unpaired reads extended to 147
				if(pCurAlignHit->Strand == '+')
					{
					CurDyadLoci = pCurAlignHit->Loci + 69;
					for(Idx=0;Idx < 10;Idx++)
						pDyadScores[CurDyadLoci++] += DyadScore(Idx);
					}
				else // else on '-' strand
					{
					if((pCurAlignHit->Loci + pCurAlignHit->AlignLen) > 130)	// not worried if the first nucleosome dyad is skipped
																			// more concerned to ensure dyad loci will never be negative!
						{
						CurDyadLoci = pCurAlignHit->Loci + pCurAlignHit->AlignLen - 78;
						for(Idx=9; Idx >= 0; Idx--)
							pDyadScores[CurDyadLoci++] += (int)DyadScore(Idx);
						}
					}
				pCurAlignHit->Processed = 1;
				break;
			}
		if(MaxDyadLoci < CurDyadLoci)
			MaxDyadLoci = CurDyadLoci;
		continue;
		}

	// different chromosome
	if(MaxDyadLoci >= 0)		// if any dyads on szCurChromName then write out the dyads with score > 0
		{
		// apply any MNase normalisation
		if(MaxDyadLoci >= 147 && m_pMNaseSel != NULL && m_pBioSeqFile != NULL)
			{
			gDiagnostics.DiagOut(eDLInfo,gszProcName,"Normalising for MNase bias on %s",szCurChromName);
			for(Idx = 0; Idx < MaxDyadLoci - 147; Idx++)
				{
				MNaseScore = MNaseSeqScore(szCurChromName, Idx, 147);
				if(MNaseScore < 0.0)		// any errors?
					{
					if(pDyadScores != NULL)
						delete pDyadScores;
					Reset();
					return(eBSFerrStructStep);
					}
				if(MNaseScore > 0.001)
					pDyadScores[Idx+73] = (int)((double)pDyadScores[Idx+73] / (1.0-MNaseScore)); 
				}
			}
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Saving dyads on chromosome: %s",szCurChromName);
		if((Rslt = OutputDyads(hFile,FMode,MovAvgFilter,BaselineFilter,pszTrackName,szCurChromName,MaxDyadLoci,pDyadScores)) < eBSFSuccess)
			{
			if(pDyadScores != NULL)
				delete pDyadScores;
			Reset();
			return(Rslt);
			}
		memset(pDyadScores,0,sizeof(int) * MaxDyadLoci);
		}
	szCurChromName[0] = '\0';
	CurChromID = 0;
	MaxDyadLoci = -1;
	pCurAlignHit = IterSortedReads(pCurAlignHit, false); // reprocess the current read on next iteration
	}

if(FMode != eFMMNaseScore && MaxDyadLoci >= 0)		// if any dyads on szCurChromName then write out the dyads with score > 0
	{
	// apply any MNase normalisation
	if(MaxDyadLoci >= 147 && m_pMNaseSel != NULL && m_pBioSeqFile != NULL)
		{
		gDiagnostics.DiagOut(eDLInfo,gszProcName,"Normalising for MNase bias on %s",szCurChromName);
		for(Idx = 0; Idx < MaxDyadLoci - 147; Idx++)
			{
			MNaseScore = MNaseSeqScore(szCurChromName, Idx, 147);
			if(MNaseScore < 0.0)		// any errors?
				{
				if(pDyadScores != NULL)
					delete pDyadScores;
				Reset();
				return(eBSFerrStructStep);
				}
			if(MNaseScore > 0.001)
				pDyadScores[Idx+73] = (int)((double)pDyadScores[Idx+73] / (1.0-MNaseScore)); 
			}
		}
	if((Rslt=OutputDyads(hFile,FMode,MovAvgFilter,BaselineFilter,pszTrackName,szCurChromName,MaxDyadLoci,pDyadScores)) < eBSFSuccess)
		{
		if(pDyadScores != NULL)
			delete pDyadScores;
		Reset();
		return(Rslt);
		}
	gDiagnostics.DiagOut(eDLInfo,gszProcName,"Saving %s on chromosome: %s",FMode <= eFMcsvDyads ? "dyads" : "nucleosomes",szCurChromName);
	}

pCurAlignHit = NULL;
Unprocessed = 0;
while((pCurAlignHit = IterSortedReads(pCurAlignHit, true))!=NULL)
	if(!pCurAlignHit->Processed)
		Unprocessed += 1;
gDiagnostics.DiagOut(eDLInfo,gszProcName,"There were %d reads dyad accepted and %d unaccepted because they were %s",NumProcessed, Unprocessed, PMode == ePMfulllength ? "over/underlength" : "unpaired");

if(pDyadScores != NULL)
	delete pDyadScores;

if(FMode == eFMMNaseScore)
	{
	char szLineBuff[4096];
	int BuffIdx;
	if(MaxDyadLoci >= 147 && m_pMNaseSel != NULL && m_pBioSeqFile != NULL)
		{
		for(Idx = 0; Idx < MaxDyadLoci - 147; Idx++)
			{
			MNaseScore = MNaseSeqScore(szCurChromName, Idx, 147);
			if(MNaseScore < 0.0)		// any errors?
				{
				if(pDyadScores != NULL)
					delete pDyadScores;
				Reset();
				return(eBSFerrStructStep);
				}
			}
		}

	gDiagnostics.DiagOut(eDLInfo,gszProcName,"MNase Score Distribution (min: %1.4f max: %1.4f)",(double)m_MinMNaseScore/10000.0f,(double)m_MaxMNaseScore/10000.0f);
	BuffIdx = 0;
	for(Idx = 500; Idx < 1000; Idx++)
		{
		BuffIdx += sprintf(&szLineBuff[BuffIdx],"%1.3f,%d\n",(double)Idx/1000.0f,m_MNaseScoreHist[Idx]);
		if((BuffIdx + 100) > sizeof(szLineBuff))
			{
			CUtility::SafeWrite(hFile,szLineBuff,BuffIdx);
			BuffIdx = 0;
			}
		}
	if(BuffIdx)
		CUtility::SafeWrite(hFile,szLineBuff,BuffIdx);
	}
if(hFile != -1)
	{
	close(hFile);
	hFile = -1;
	}
Reset();
return(Rslt);
}

// LocateRead
// Locate read with requested ReadID
tsAlignHit *
LocateRead(UINT32 ReadID)
{
int Rslt;
tsAlignHit *pProbe;
int Lo,Mid,Hi;	// search limits

if(m_ppAlignHitsIdx == NULL || m_AllocdAlignHitsIdx < m_NumAlignHits)
	return(NULL);

Lo = 0; 
Hi = m_NumAlignHits-1;
while(Hi >= Lo) {
	Mid = (Hi + Lo)/2;
	pProbe = m_ppAlignHitsIdx[Mid];
	Rslt = pProbe->ReadID - ReadID;
	if(Rslt > 0)	
		{
		Hi = Mid - 1;
		continue;
		}
	if(Rslt < 0)	
		{
		Lo = Mid + 1;
		continue;
		}
	return(pProbe);
	}
return(NULL);
}



// IterReads
// use to iterate over reads returning ptr to next read following the current read
// To start from first read then pass in NULL as pCurAlignHit
// Returns NULL if all read hits have been iterate
tsAlignHit *
IterReads(tsAlignHit *pCurAlignHit)
{
tsAlignHit *pNxtAlignHit = NULL;
if(pCurAlignHit == NULL)
	pNxtAlignHit = m_pAlignHits;
else
	if(pCurAlignHit->ReadID != m_FinalReadID)
		pNxtAlignHit = (tsAlignHit *)((UINT8 *)pCurAlignHit + sizeof(tsAlignHit));
return(pNxtAlignHit);
}

// IterSortedReads
// use to iterate over sorted reads returning ptr to -
// bForward == true : next read following the current read
// bForward == false : read previous to the current read
// To start from first (bForward == true) read then pass in NULL as pCurAlignHit
// To start from last (bForward == false) read then pass in NULL as pCurAlignHit
// Returns NULL if all read hits have been iterated
tsAlignHit *
IterSortedReads(tsAlignHit *pCurAlignHit, bool bForward)
{
tsAlignHit *pNxtAlignHit = NULL;
if(bForward)
	{
	if(pCurAlignHit == NULL)
		pNxtAlignHit = m_ppAlignHitsIdx[0];
	else
		if(pCurAlignHit->AlignHitIdx < m_NumAlignHits)
			pNxtAlignHit = m_ppAlignHitsIdx[pCurAlignHit->AlignHitIdx];
	}
else
	{
	if(pCurAlignHit == NULL)
		pNxtAlignHit = m_ppAlignHitsIdx[m_NumAlignHits-1];
	else
		if(pCurAlignHit->AlignHitIdx > 1)
			pNxtAlignHit = m_ppAlignHitsIdx[pCurAlignHit->AlignHitIdx-2];
	}
return(pNxtAlignHit);
}

int
SortAlignHits(etReadsSortMode SortMode)
{
tsAlignHit *pAlignHit;
int Idx;

if(SortMode == m_CurReadsSortMode && m_ppAlignHitsIdx != NULL && m_AllocdAlignHitsIdx >= m_NumAlignHits)
	return(eBSFSuccess);

if(m_ppAlignHitsIdx == NULL || m_AllocdAlignHitsIdx < m_NumAlignHits)
	{
	if(m_ppAlignHitsIdx != NULL)
		{
		delete m_ppAlignHitsIdx;
		m_ppAlignHitsIdx = NULL;
		m_AllocdAlignHitsIdx = 0;
		}
	if((m_ppAlignHitsIdx = (tsAlignHit **) new tsAlignHit * [m_NumAlignHits])==NULL)
		{
		gDiagnostics.DiagOut(eDLFatal,gszProcName,"SortAlignHits: Memory reads index allocation for %d ptrs - %s",m_NumAlignHits,strerror(errno));
		return(eBSFerrMem);
		}
	m_AllocdAlignHitsIdx = m_NumAlignHits;
	}

pAlignHit = NULL;
tsAlignHit **pIdx = m_ppAlignHitsIdx;
while((pAlignHit = IterReads(pAlignHit))!=NULL)
	*pIdx++ = pAlignHit;

switch(SortMode) {
	case eRSMReadID: 
		qsort(m_ppAlignHitsIdx,m_NumAlignHits,sizeof(tsAlignHit *),SortHitReadIDs);
		break;
	case eRSMHitMatch:
		qsort(m_ppAlignHitsIdx,m_NumAlignHits,sizeof(tsAlignHit *),SortHitMatch);
		break;
	default:
		break;
	}

UINT32 ChromID = 0;
char *pszCurChrom = NULL;
for(Idx = 0; Idx < (int)m_NumAlignHits; Idx++)
	{
	m_ppAlignHitsIdx[Idx]->AlignHitIdx = Idx + 1;
	if(pszCurChrom == NULL || stricmp(m_ppAlignHitsIdx[Idx]->szChromName,pszCurChrom))
		{
		pszCurChrom = m_ppAlignHitsIdx[Idx]->szChromName;
		ChromID += 1;
		}
	m_ppAlignHitsIdx[Idx]->ChromID = ChromID;
	}
m_CurReadsSortMode = SortMode;
return(eBSFSuccess);
}


// SortHitReadIDs
// Sort reads by ascending read identifiers
static int
SortHitReadIDs(const void *arg1, const void *arg2)
{
tsAlignHit *pEl1 = *(tsAlignHit **)arg1;
tsAlignHit *pEl2 = *(tsAlignHit **)arg2;

if(pEl1->ReadID < pEl2->ReadID )
		return(-1);
if(pEl1->ReadID > pEl2->ReadID )
	return(1);
return(0);
}

// SortHitmatch
// Sort by ascending chrom, loci, strand
static int
SortHitMatch(const void *arg1, const void *arg2)
{
tsAlignHit *pEl1 = *(tsAlignHit **)arg1;
tsAlignHit *pEl2 = *(tsAlignHit **)arg2;
int Rslt;

if(pEl1->szChromName[0] < pEl2->szChromName[0] )
		return(-1);
if(pEl1->szChromName[0] > pEl2->szChromName[0] )
	return(1);
if((Rslt = stricmp(pEl1->szChromName,pEl2->szChromName))!=0)
	return(Rslt);

if(pEl1->Loci < pEl2->Loci )
		return(-1);
if(pEl1->Loci > pEl2->Loci )
	return(1);
if(pEl1->Strand < pEl2->Strand )
		return(-1);
if(pEl1->Strand > pEl2->Strand )
	return(1);

return(0);
}


